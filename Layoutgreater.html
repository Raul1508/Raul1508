<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  </head>
  <body>
    <div class="content"></div>
<script type="text/javascript">
!function(){var e={346:function(){const e=document.querySelector("head");e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement("link");n.setAttribute("rel","icon"),n.setAttribute("href",`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute("sizes",`${t}x${t}`),n.setAttribute("type","image/png"),e.appendChild(n)}))},422:function(e,t,n){"use strict";n.r(t),n.d(t,{initLocalFileLoader:function(){return CC},load:function(){return xC}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return T},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return k},fromQuat2:function(){return D},fromRotation:function(){return P},fromRotationTranslation:function(){return V},fromRotationTranslationScale:function(){return F},fromRotationTranslationScaleOrigin:function(){return _},fromScaling:function(){return O},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return E},frustum:function(){return G},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return y},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return Ve},multiplyScalarAndAdd:function(){return De},normalFromMat4:function(){return we},projection:function(){return Oe},rotate:function(){return ye},scale:function(){return be},set:function(){return de},str:function(){return Pe},sub:function(){return Fe},subtract:function(){return Ee},translate:function(){return Te},transpose:function(){return fe}}),n(346);var a=1e-6,i="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],T=n*s-r*i,y=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,O=d*h-p*m,P=d*v-f*m,R=p*v-f*h,M=T*R-y*P+b*O+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*P+c*O)*M,e[1]=(o*P-r*R-a*O)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*y)*M,e[7]=(u*S-p*b+f*y)*M,e[8]=(i*P-s*w+c*A)*M,e[9]=(r*w-n*P-a*A)*M,e[10]=(g*C-m*b+v*T)*M,e[11]=(d*b-u*C-f*T)*M,e[12]=(s*I-i*O-l*A)*M,e[13]=(n*O-r*I+o*A)*M,e[14]=(m*y-g*x-h*T)*M,e[15]=(u*x-d*y+p*T)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function T(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function y(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],T=t[15],y=n[0],b=n[1],x=n[2],C=n[3];return e[0]=y*r+b*s+x*d+C*m,e[1]=y*o+b*l+x*p+C*h,e[2]=y*a+b*c+x*f+C*v,e[3]=y*i+b*u+x*g+C*T,y=n[4],b=n[5],x=n[6],C=n[7],e[4]=y*r+b*s+x*d+C*m,e[5]=y*o+b*l+x*p+C*h,e[6]=y*a+b*c+x*f+C*v,e[7]=y*i+b*u+x*g+C*T,y=n[8],b=n[9],x=n[10],C=n[11],e[8]=y*r+b*s+x*d+C*m,e[9]=y*o+b*l+x*p+C*h,e[10]=y*a+b*c+x*f+C*v,e[11]=y*i+b*u+x*g+C*T,y=n[12],b=n[13],x=n[14],C=n[15],e[12]=y*r+b*s+x*d+C*m,e[13]=y*o+b*l+x*p+C*h,e[14]=y*a+b*c+x*f+C*v,e[15]=y*i+b*u+x*g+C*T,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,T,y,b,x,C,S,A,I,w,O,P,R=r[0],M=r[1],E=r[2],V=Math.hypot(R,M,E);return V<a?null:(R*=V=1/V,M*=V,E*=V,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],T=t[10],y=t[11],b=R*R*s+i,x=M*R*s+E*o,C=E*R*s-M*o,S=R*M*s-E*o,A=M*M*s+i,I=E*M*s+R*o,w=R*E*s+M*o,O=M*E*s-R*o,P=E*E*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+T*C,e[3]=d*b+m*x+y*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+T*I,e[7]=d*S+m*A+y*I,e[8]=l*w+p*O+h*P,e[9]=c*w+f*O+v*P,e[10]=u*w+g*O+T*P,e[11]=d*w+m*O+y*P,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function O(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function P(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function V(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,T=i*c;return e[0]=1-(f+m),e[1]=d+T,e[2]=p-v,e[3]=0,e[4]=d-T,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function D(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),V(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function F(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,T=s*c,y=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+y)*b,e[2]=(f-T)*b,e[3]=0,e[4]=(p-y)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+T)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function _(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,T=l*c,y=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],O=(1-(m+v))*x,P=(f+b)*x,R=(g-y)*x,M=(f-b)*C,E=(1-(p+v))*C,V=(h+T)*C,D=(g+y)*S,L=(h-T)*S,B=(1-(p+m))*S;return e[0]=O,e[1]=P,e[2]=R,e[3]=0,e[4]=M,e[5]=E,e[6]=V,e[7]=0,e[8]=D,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(O*A+M*I+D*w),e[13]=n[1]+I-(P*A+E*I+L*w),e[14]=n[2]+w-(R*A+V*I+B*w),e[15]=1,e}function k(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function G(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],T=t[2],y=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(T-A)<a?g(e):(d=h-C,p=v-S,f=T-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-y*f,s=y*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*T),e[13]=-(l*h+c*v+u*T),e[14]=-(d*h+p*v+f*T),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],T=e[15],y=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],O=t[8],P=t[9],R=t[10],M=t[11],E=t[12],V=t[13],D=t[14],L=t[15];return Math.abs(n-y)<=a*Math.max(1,Math.abs(n),Math.abs(y))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-O)<=a*Math.max(1,Math.abs(d),Math.abs(O))&&Math.abs(p-P)<=a*Math.max(1,Math.abs(p),Math.abs(P))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-E)<=a*Math.max(1,Math.abs(m),Math.abs(E))&&Math.abs(h-V)<=a*Math.max(1,Math.abs(h),Math.abs(V))&&Math.abs(v-D)<=a*Math.max(1,Math.abs(v),Math.abs(D))&&Math.abs(T-L)<=a*Math.max(1,Math.abs(T),Math.abs(L))}var oe=y,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],T=n[6],y=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=T*r+y*i+b*c,e[7]=T*o+y*s+b*u,e[8]=T*a+y*l+b*d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],T=n*s-r*i,y=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,O=d*h-p*m,P=d*v-f*m,R=p*v-f*h,M=T*R-y*P+b*O+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*P+c*O)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*P-s*w+c*A)*M,e[3]=(o*P-r*R-a*O)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*P-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*y)*M,e[8]=(g*C-m*b+v*T)*M,e):null}function Oe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Pe(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function Ee(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function Ve(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function De(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],T=t[6],y=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-T)<=a*Math.max(1,Math.abs(c),Math.abs(T))&&Math.abs(u-y)<=a*Math.max(1,Math.abs(u),Math.abs(y))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,Fe=Ee,_e=n(730),ke=n.n(_e),Ge=n(59);const Ue=n.n(Ge)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error("Invalid VTK object"),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&"object"==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=e=>{throw new Error(`Named parameter '${e}' is missing`)},$e=Symbol("void"),qe={};function Xe(){}["log","debug","info","warn","error","time","timeEnd","group","groupEnd"].forEach((e=>{qe[e]=Xe})),Ue.console=console.hasOwnProperty("log")?console:qe;const Ye={debug:Xe,error:Ue.console.error||Xe,info:Ue.console.info||Xe,log:Ue.console.log||Xe,warn:Ue.console.warn||Xe};function Ze(e,t){Ye[e]&&(Ye[e]=t||Xe)}function Qe(){Ye.log(...arguments)}function Je(){Ye.info(...arguments)}function et(){Ye.debug(...arguments)}function tt(){Ye.error(...arguments)}function nt(){Ye.warn(...arguments)}const rt={};function ot(e){rt[e]||(Ye.error(e),rt[e]=!0)}const at=Object.create(null);at.Float32Array=Float32Array,at.Float64Array=Float64Array,at.Uint8Array=Uint8Array,at.Int8Array=Int8Array,at.Uint16Array=Uint16Array,at.Int16Array=Int16Array,at.Uint32Array=Uint32Array,at.Int32Array=Int32Array,at.Uint8ClampedArray=Uint8ClampedArray;try{at.BigInt64Array=BigInt64Array,at.BigUint64Array=BigUint64Array}catch{}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(at[e]||Float64Array)(...n)}function st(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(at[e]||Float64Array).from(...n)}function lt(e){return e.charAt(0).toUpperCase()+e.slice(1)}function ct(e){return lt("_"===e[0]?e.slice(1):e)}function ut(e){return e.charAt(0).toLowerCase()+e.slice(1)}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=["TB","GB","MB","KB"];let o=Number(e),a="B";for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function pt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:" ";const n=[];let r=e;for(;r>1e3;)n.push(("000"+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function ft(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function gt(e){return e&&e.isA?e.getState():e}function mt(e){setTimeout(e,0)}function ht(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function vt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};ft(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),"classHierarchy"in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He("vtkObject");function r(e){n[e]=null}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?tt("instance deleted - cannot call any method"):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return tt("instance deleted - cannot call any method"),null;const o=n.length;return n.push(e),function(e){return Object.freeze({unsubscribe:function(){r(e)}})}(o)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${lt(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==["mtime"].indexOf(i)||r||nt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||"_"===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(gt):function(e){return Object.values(at).some((t=>e instanceof t))}(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort();Object.keys(o).sort().forEach((e=>{const n=a.indexOf(e);-1===n?r&&et(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&et(`Untouched keys: ${a.join(", ")}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object(e,t,n){return function(){return{...t[n.name]}}}};function yt(e,t,n){n.forEach((n=>{if("object"==typeof n){const r=Tt[n.type];e[`get${ct(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${ct(n)}`]=()=>t[n]}))}const bt={enum(e,t,n){const r=`_on${ct(n.name)}Changed`;return o=>{if("string"==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw tt(`Set Enum with invalid argument ${n}, ${o}`),new RangeError("Set Enum with invalid string argument")}if("number"==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw tt(`Set Enum outside numeric range ${n}, ${o}`),new RangeError("Set Enum outside numeric range")}return!1}throw tt(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError("Set Enum with invalid argument (String/Number)")}},object(e,t,n){1===n.params?.length&&nt('Setter of type "object" with a single "param" field is not supported');const r=`_on${ct(n.name)}Changed`;return function(){for(var o=arguments.length,a=new Array(o),i=0;i<o;i++)a[i]=arguments[i];let s;if(s=a.length>1&&n.params?.length?n.params.reduce(((e,t,n)=>Object.assign(e,{[t]:a[n]})),{}):a[0],!ke()(t[n.name],s)){const o=t[n.name];return t[n.name]=s,t[r]?.(e,t,s,o),e.modified(),!0}return!1}}};function xt(e){if("object"==typeof e){const t=bt[e.type];if(t)return(n,r)=>t(n,r,e);throw tt(`No setter for field ${e}`),new TypeError("No setter for field")}return function(t,n){const r=`_on${ct(e)}Changed`;return function(o){if(n.deleted)return tt("instance deleted - cannot call any method"),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function Ct(e,t,n){n.forEach((n=>{"object"==typeof n?e[`set${ct(n.name)}`]=xt(n)(e,t):e[`set${ct(n)}`]=xt(n)(e,t)}))}function St(e,t,n){yt(e,t,n),Ct(e,t,n)}function At(e,t,n){n.forEach((n=>{e[`get${ct(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${ct(n)}ByReference`]=()=>t[n]}))}function It(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${ct(n)}Changed`;e[`set${ct(n)}`]=function(){if(t.deleted)return tt("instance deleted - cannot call any method"),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${ct(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;At(e,t,n),It(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Pt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?tt("instance deleted - cannot call any method"):r>=t.numberOfInputs?tt(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)tt("instance deleted - cannot call any method");else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=" input ports. To add more input ports, use addInputConnection()",void tt(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(tt("instance deleted - cannot call any method"),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?tt("instance deleted - cannot call any method"):o(e,i())},e.addInputConnection=function(e){t.deleted?tt("instance deleted - cannot call any method"):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.requestData&&e.shouldUpdate()&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"Scalars";for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Rt=Symbol("Event abort");function Mt(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}e[`invoke${ct(n)}`]=function(){if(t.deleted)return void tt("instance deleted - cannot call any method");const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Rt)break}},e[`on${ct(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return tt("instance deleted - cannot call any method"),null;const s=a++;return r.push([s,e,o]),r.sort(((e,t)=>t[2]-e[2])),function(e){return Object.freeze({unsubscribe:function(){i(e)}})}(s)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Et(e,t){const n=function(){const t={};return e(t,{},arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}),Object.freeze(t)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Dt(e){return e&&e.isA&&e.isA("vtkObject")}function Lt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Dt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Lt(e,t,n,r)})):Lt(o,t,n,r)}))}return n}function Bt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=n&&!o;clearTimeout(o),o=setTimeout((()=>{o=null,n||e.apply(l,i)}),t),c&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function Nt(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let _t=1;const kt="__root__";function Gt(e,t){Ft(e,t);const n=e.delete;t.proxyId=""+_t++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),yt(e,t,["proxyId","proxyGroup","proxyName"]),St(e,t,["proxyManager"]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:kt;const r=[],a=t.proxyId,s=function(){return o[arguments.length>0&&void 0!==arguments[0]?arguments[0]:kt]}(n)||[];for(let t=0;t<s.length;t++){const n=s[t],o=e[`get${ct(n)}`],l={id:a,name:n,value:o?o():void 0},c=i(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,kt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,kt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${ct(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${ct(c.propertyName)}`]();if(!function(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}const c={bind:function(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}},unbind:l,unsubscribe:function(){for(;o.length;)o.pop().subscription.unsubscribe()},persistent:n};return t.propertyLinkMap[e]=c,c},e.listPropertyNames=()=>i().map((e=>e.name)),e.getPropertyByName=e=>i().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:i()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,mt((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if("application"===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,"application"),n.bind(e,o,i)}}}))}function Ut(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=ct(l),d=ct(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function zt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${ct(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&yt(e,t,a)}function Wt(e){let t=0,n=0,r=0,o=0;return"detail"in e&&(n=e.detail),"wheelDelta"in e&&(n=-e.wheelDelta/120),"wheelDeltaY"in e&&(n=-e.wheelDeltaY/120),"wheelDeltaX"in e&&(t=-e.wheelDeltaX/120),"axis"in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,"deltaY"in e&&(o=e.deltaY),"deltaX"in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var Ht={algo:Pt,capitalize:lt,chain:Vt,debounce:Bt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Mt,EVENT_ABORT:Rt,formatBytesToProperUnit:dt,formatNumbersWithThousandSeparator:pt,get:yt,getArray:At,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:gt,isVtkObject:Dt,keystore:Ft,measurePromiseExecution:ht,moveToProtected:Ot,newInstance:Et,newTypedArray:it,newTypedArrayFrom:st,normalizeWheel:Wt,obj:vt,proxy:Gt,proxyPropertyMapping:Ut,proxyPropertyState:zt,safeArrays:ft,set:Ct,setArray:It,setGet:St,setGetArray:wt,setImmediate:mt,setLoggerFunction:Ze,throttle:Nt,traverseInstanceTree:Lt,TYPED_ARRAYS:at,uncapitalize:ut,VOID:$e,vtkDebugMacro:et,vtkErrorMacro:tt,vtkInfoMacro:Je,vtkLogMacro:Qe,vtkOnceErrorMacro:ot,vtkWarningMacro:nt,objectSetterMap:bt,requiredParam:Ke},jt=Object.freeze({__proto__:null,requiredParam:Ke,VOID:$e,setLoggerFunction:Ze,vtkLogMacro:Qe,vtkInfoMacro:Je,vtkDebugMacro:et,vtkErrorMacro:tt,vtkWarningMacro:nt,vtkOnceErrorMacro:ot,TYPED_ARRAYS:at,newTypedArray:it,newTypedArrayFrom:st,capitalize:lt,_capitalize:ct,uncapitalize:ut,formatBytesToProperUnit:dt,formatNumbersWithThousandSeparator:pt,setImmediateVTK:mt,measurePromiseExecution:ht,obj:vt,get:yt,set:Ct,setGet:St,getArray:At,setArray:It,setGetArray:wt,moveToProtected:Ot,algo:Pt,EVENT_ABORT:Rt,event:Mt,newInstance:Et,chain:Vt,isVtkObject:Dt,traverseInstanceTree:Lt,debounce:Bt,throttle:Nt,keystore:Ft,proxy:Gt,proxyPropertyMapping:Ut,proxyPropertyState:zt,normalizeWheel:Wt,default:Ht});const{vtkErrorMacro:Kt}=Ht,$t={renderable:null,myFactory:null,children:[],visited:!1};function qt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$t,n),Ht.obj(e,t),Ht.event(e,t,"event"),t._renderableChildMap=new Map,Ht.get(e,t,["visited"]),Ht.setGet(e,t,["_parent","renderable","myFactory"]),Ht.getArray(e,t,["children"]),Ht.moveToProtected(e,t,["parent"]),function(e,t){t.classHierarchy.push("vtkViewNode"),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.getLastAncestorOfType=e=>t._parent?t._parent.getLastAncestorOfType(e)||(t._parent.isA(e)?t._parent:null):null,e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)return r.setVisited(!0),r;const o=e.createViewNode(n);return o?(o.setParent(e),o.setVisited(!0),t._renderableChildMap.set(n,o),t.children.push(o),o):void 0},e.addMissingNodes=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n&&n.length)for(let o=0;o<n.length;++o){const a=n[o],i=e.addMissingNode(a);if(r&&void 0!==i&&t.children[o]!==i)for(let e=o+1;e<t.children.length;++e)if(t.children[e]===i){t.children.splice(e,1),t.children.splice(o,0,i);break}}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];if(-1===t.children.indexOf(o)){o.setParent(e),t.children.push(o);const n=o.getRenderable();n&&t._renderableChildMap.set(n,o)}o.setVisited(!0)}},e.removeNode=e=>{const n=t.children.findIndex((t=>t===e));if(n<0)return!1;const r=e.getRenderable();return r&&t._renderableChildMap.delete(r),e.delete(),t.children.splice(n,1),!0},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return Kt("Cannot create view nodes without my own factory"),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}(e,t)}var Xt={newInstance:Ht.newInstance(qt,"vtkViewNode"),extend:qt,PASS_TYPES:["Build","Render"]};const Yt={};function Zt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yt,n),Ht.obj(e,t),function(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push("vtkViewNodeFactory"),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s}}(e,t)}var Qt={newInstance:Ht.newInstance(Zt,"vtkViewNodeFactory"),extend:Zt};const Jt=Object.create(null);function en(e,t){Jt[e]=t}const tn={};function nn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tn,n),t.overrides=Jt,Qt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLViewNodeFactory")}(0,t)}var rn={newInstance:Ht.newInstance(nn,"vtkOpenGLViewNodeFactory"),extend:nn};const on={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const an=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,on,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},St(e,t,["context","keyMatrixTime"]),function(e,t){t.classHierarchy.push("vtkOpenGLCamera"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),y(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}(e,t)}));en("vtkCamera",an);const{vtkDebugMacro:sn}=jt,ln={context:null,_openGLRenderWindow:null,selector:null};const cn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ln,n),Xt.extend(e,t,n),yt(e,t,["shaderCache"]),St(e,t,["selector"]),Ot(0,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkOpenGLRenderer"),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps(),!0),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(sn("No lights are on, creating one."),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();r.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,r.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}(e,t)}),"vtkOpenGLRenderer");en("vtkRenderer",cn);const un={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const dn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},St(e,t,["context"]),yt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLActor"),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(t._openGLRenderer.getSelector()&&t.renderable.getNestedPickable()),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}(e,t)}));en("vtkActor",dn);const pn={context:null,activeTextures:null};const fn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pn,n),Xt.extend(e,t,n),St(e,t,["context"]),yt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLActor2D"),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}(e,t)}));function gn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function mn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function hn(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function vn(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function Tn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function yn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function bn(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}function xn(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Cn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Sn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function An(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function In(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function wn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function On(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Pn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Rn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}en("vtkActor2D",fn);var Mn=yn,En=bn,Vn=(gn(),Math.sqrt(50)),Dn=Math.sqrt(10),Ln=Math.sqrt(2);function Bn(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Vn?10:a>=Dn?5:a>=Ln?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Vn?10:a>=Dn?5:a>=Ln?2:1)}function Nn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Fn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=Nn,r=(t,n)=>Nn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const _n=Fn(Nn),kn=_n.right;_n.left,Fn((function(e){return null===e?NaN:+e})).center;var Gn=kn;function Un(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function zn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Wn(){}var Hn=.7,jn=1/Hn,Kn="\\s*([+-]?\\d+)\\s*",$n="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",qn="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",Xn=/^#([0-9a-f]{3,8})$/,Yn=new RegExp(`^rgb\\(${Kn},${Kn},${Kn}\\)$`),Zn=new RegExp(`^rgb\\(${qn},${qn},${qn}\\)$`),Qn=new RegExp(`^rgba\\(${Kn},${Kn},${Kn},${$n}\\)$`),Jn=new RegExp(`^rgba\\(${qn},${qn},${qn},${$n}\\)$`),er=new RegExp(`^hsl\\(${$n},${qn},${qn}\\)$`),tr=new RegExp(`^hsla\\(${$n},${qn},${qn},${$n}\\)$`),nr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function rr(){return this.rgb().formatHex()}function or(){return this.rgb().formatRgb()}function ar(e){var t,n;return e=(e+"").trim().toLowerCase(),(t=Xn.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?ir(t):3===n?new cr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?sr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?sr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=Yn.exec(e))?new cr(t[1],t[2],t[3],1):(t=Zn.exec(e))?new cr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=Qn.exec(e))?sr(t[1],t[2],t[3],t[4]):(t=Jn.exec(e))?sr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=er.exec(e))?mr(t[1],t[2]/100,t[3]/100,1):(t=tr.exec(e))?mr(t[1],t[2]/100,t[3]/100,t[4]):nr.hasOwnProperty(e)?ir(nr[e]):"transparent"===e?new cr(NaN,NaN,NaN,0):null}function ir(e){return new cr(e>>16&255,e>>8&255,255&e,1)}function sr(e,t,n,r){return r<=0&&(e=t=n=NaN),new cr(e,t,n,r)}function lr(e,t,n,r){return 1===arguments.length?((o=e)instanceof Wn||(o=ar(o)),o?new cr((o=o.rgb()).r,o.g,o.b,o.opacity):new cr):new cr(e,t,n,null==r?1:r);var o}function cr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function ur(){return`#${gr(this.r)}${gr(this.g)}${gr(this.b)}`}function dr(){const e=pr(this.opacity);return`${1===e?"rgb(":"rgba("}${fr(this.r)}, ${fr(this.g)}, ${fr(this.b)}${1===e?")":`, ${e})`}`}function pr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function fr(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function gr(e){return((e=fr(e))<16?"0":"")+e.toString(16)}function mr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new vr(e,t,n,r)}function hr(e){if(e instanceof vr)return new vr(e.h,e.s,e.l,e.opacity);if(e instanceof Wn||(e=ar(e)),!e)return new vr;if(e instanceof vr)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new vr(i,s,l,e.opacity)}function vr(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Tr(e){return(e=(e||0)%360)<0?e+360:e}function yr(e){return Math.max(0,Math.min(1,e||0))}function br(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function xr(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}Un(Wn,ar,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:rr,formatHex:rr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return hr(this).formatHsl()},formatRgb:or,toString:or}),Un(cr,lr,zn(Wn,{brighter(e){return e=null==e?jn:Math.pow(jn,e),new cr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Hn:Math.pow(Hn,e),new cr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new cr(fr(this.r),fr(this.g),fr(this.b),pr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:ur,formatHex:ur,formatHex8:function(){return`#${gr(this.r)}${gr(this.g)}${gr(this.b)}${gr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:dr,toString:dr})),Un(vr,(function(e,t,n,r){return 1===arguments.length?hr(e):new vr(e,t,n,null==r?1:r)}),zn(Wn,{brighter(e){return e=null==e?jn:Math.pow(jn,e),new vr(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Hn:Math.pow(Hn,e),new vr(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new cr(br(e>=240?e-240:e+120,o,r),br(e,o,r),br(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new vr(Tr(this.h),yr(this.s),yr(this.l),pr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=pr(this.opacity);return`${1===e?"hsl(":"hsla("}${Tr(this.h)}, ${100*yr(this.s)}%, ${100*yr(this.l)}%${1===e?")":`, ${e})`}`}}));var Cr=e=>()=>e;function Sr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Cr(isNaN(e)?t:e)}var Ar=function e(t){var n=function(e){return 1==(e=+e)?Sr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Cr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=lr(e)).r,(t=lr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Sr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+""}}return r.gamma=e,r}(1);function Ir(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=lr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+""}}}function wr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Lr(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Or(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Pr(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Rr(e,t){var n,r={},o={};for(n in null!==e&&"object"==typeof e||(e={}),null!==t&&"object"==typeof t||(t={}),t)n in e?r[n]=Lr(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Ir((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return xr((n-r/t)*t,i,o,a,s)}})),Ir((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return xr((n-r/t)*t,o,a,i,s)}}));var Mr=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,Er=new RegExp(Mr.source,"g");function Vr(e,t){var n,r,o,a=Mr.lastIndex=Er.lastIndex=0,i=-1,s=[],l=[];for(e+="",t+="";(n=Mr.exec(e))&&(r=Er.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Pr(n,r)})),a=Er.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+""}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join("")})}function Dr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Lr(e,t){var n,r=typeof t;return null==t||"boolean"===r?Cr(t):("number"===r?Pr:"string"===r?(n=ar(t))?(t=n,Ar):Vr:t instanceof ar?Ar:t instanceof Date?Or:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Dr:Array.isArray(t)?wr:"function"!=typeof t.valueOf&&"function"!=typeof t.toString||isNaN(t)?Rr:Pr)(e,t)}function Br(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Nr(e){return+e}var Fr=[0,1];function _r(e){return e}function kr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function Gr(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=kr(o,r),a=n(i,a)):(r=kr(r,o),a=n(a,i)),function(e){return a(r(e))}}function Ur(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=kr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=Gn(e,t,1,r)-1;return a[n](o[n](t))}}function zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Wr,Hr=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function jr(e){if(!(t=Hr.exec(e)))throw new Error("invalid format: "+e);var t;return new Kr({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function Kr(e){this.fill=void 0===e.fill?" ":e.fill+"",this.align=void 0===e.align?">":e.align+"",this.sign=void 0===e.sign?"-":e.sign+"",this.symbol=void 0===e.symbol?"":e.symbol+"",this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?"":e.type+""}function $r(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf("e"))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function qr(e){return(e=$r(Math.abs(e)))?e[1]:NaN}function Xr(e,t){var n=$r(e,t);if(!n)return e+"";var r=n[0],o=n[1];return o<0?"0."+new Array(-o).join("0")+r:r.length>o+1?r.slice(0,o+1)+"."+r.slice(o+1):r+new Array(o-r.length+2).join("0")}jr.prototype=Kr.prototype,Kr.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type};var Yr={"%":(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+"",d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString("en").replace(/,/g,""):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>Xr(100*e,t),r:Xr,s:function(e,t){var n=$r(e,t);if(!n)return e+"";var r=n[0],o=n[1],a=o-(Wr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join("0"):a>0?r.slice(0,a)+"."+r.slice(a):"0."+new Array(1-a).join("0")+$r(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function Zr(e){return e}var Qr,Jr,eo,to=Array.prototype.map,no=["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];function ro(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Bn(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Vn?o*=10:a>=Dn?o*=5:a>=Ln&&(o*=2),t<e?-o:o}(e,t,n);switch((r=jr(null==r?",f":r)).type){case"s":var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(qr(t)/3)))-qr(Math.abs(e)))}(a,i))||(r.precision=o),eo(r,i);case"":case"e":case"g":case"p":case"r":null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,qr(t)-qr(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-("e"===r.type));break;case"f":case"%":null!=r.precision||isNaN(o=function(e){return Math.max(0,-qr(Math.abs(e)))}(a))||(r.precision=o-2*("%"===r.type))}return Jr(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Bn(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function oo(){var e=function(){var e,t,n,r,o,a,i=Fr,s=Fr,l=Lr,c=_r;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==_r&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?Ur:Gr,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Pr)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Nr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=Br,u()},d.clamp=function(e){return arguments.length?(c=!!e||_r,u()):c!==_r},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(_r,_r);return e.copy=function(){return t=e,oo().domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());var t},zr.apply(e,arguments),ro(e)}Qr=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?Zr:(t=to.call(e.grouping,Number),n=e.thousands+"",function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?"":e.currency[0]+"",a=void 0===e.currency?"":e.currency[1]+"",i=void 0===e.decimal?".":e.decimal+"",s=void 0===e.numerals?Zr:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(to.call(e.numerals,String)),l=void 0===e.percent?"%":e.percent+"",c=void 0===e.minus?"":e.minus+"",u=void 0===e.nan?"NaN":e.nan+"";function d(e){var t=(e=jr(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,T=e.type;"n"===T?(m=!0,T="g"):Yr[T]||(void 0===h&&(h=12),v=!0,T="g"),(f||"0"===t&&"="===n)&&(f=!0,t="0",n="=");var y="$"===p?o:"#"===p&&/[boxX]/.test(T)?"0"+T.toLowerCase():"",b="$"===p?a:/[%p]/.test(T)?l:"",x=Yr[T],C=/[defgprs%]/.test(T);function S(e){var o,a,l,p=y,S=b;if("c"===T)S=x(e)+S,e="";else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case".":o=t=r;break;case"0":0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&"+"!==d&&(A=!1),p=(A?"("===d?d:c:"-"===d||"("===d?"":d)+p,S=("s"===T?no[8+Wr/3]:"")+S+(A&&"("===d?")":""),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):"";switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=""),n){case"<":e=p+e+S+w;break;case"=":e=p+w+e+S;break;case"^":e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(T)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+""},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=jr(e)).type="f",e)),r=3*Math.max(-8,Math.min(8,Math.floor(qr(t)/3))),o=Math.pow(10,-r),a=no[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:",",grouping:[3],currency:["$",""]}),Jr=Qr.format,eo=Qr.formatPrefix;var ao=n(318),io=n.n(ao);const so=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],lo=[1,0,0,0,1,0,0,0,1],co=1e-6,uo=1e-12,{vtkErrorMacro:po,vtkWarningMacro:fo}=Ht;let go=0;function mo(e){return()=>po(`vtkMath::${e} - NOT IMPLEMENTED`)}function ho(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function vo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function To(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function yo(e){return e/180*Math.PI}function bo(e){return 180*e/Math.PI}const{round:xo,floor:Co,ceil:So,min:Ao,max:Io}=Math;const wo=mo("ceilLog2"),Oo=mo("factorial");function Po(e){let t=1;for(;t<e;)t*=2;return t}function Ro(e){return e===Po(e)}const Mo=mo("gaussian");function Eo(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Vo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function Do(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Lo(e,t){return e[0]*=t,e[1]*=t,e}function Bo(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function No(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Fo(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function _o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function ko(e){const t=_o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function Go(e,t){return e[0]*t[0]+e[1]*t[1]}function Uo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Wo(e){const t=zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Ho(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function jo(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function Ko(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function $o(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function qo(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function Xo(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:co;return e.length===t.length&&e.every((function(e,r){return Math.abs(e-t[r])<=n}))}const Yo=Xo;function Zo(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function Qo(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function Jo(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ea(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes("e"))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split("e");let r="";return+n[1]+t>0&&(r="+"),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ta(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ea(e[0],n),t[1]=ea(e[1],n),t[2]=ea(e[2],n),t}function na(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,T,y;const b=To(t),x=To(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(Qo(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),T=1/Math.sqrt(1+p*p),m=p*T,f=m/(1+T),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return fo("vtkMath::Jacobi: Error extracting eigenfunctions"),0;for(a=0;a<t-1;a++){for(i=a,y=n[i],o=a+1;o<t;o++)(n[o]>=y||Math.abs(n[o]-y)<uo)&&(i=o,y=n[i]);i!==a&&(n[i]=n[a],n[a]=y,vo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function ra(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];na([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function oa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=To(3),r=To(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(vo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,vo(t,3,1,2)),r[2]=2;let u=0;if(qo(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=To(4);if(ra(t,d),Jo(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&vo(t,3,r[1],1),0!==r[0]&&vo(t,3,r[0],0)}function aa(e,t,n){let r,o,a,i,s,l;if(na([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for($o(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,ho(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Fo([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);ko(e);const c=Fo(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void $o(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,ho(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,ho(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);qo(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),$o(n,n)}else Zo(n)}function ia(e,t,n){let r,o,a,i,s,l,c,u=0;const d=To(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return fo("Unable to factor linear system"),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=uo)return fo("Unable to factor linear system"),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function sa(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function la(e,t,n){if(2===n){const n=To(2),r=Ho(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=To(n);return 0===ia(e,r,n)?0:(sa(e,r,t,n),1)}function ca(e,t,n){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const o=(arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)||To(n),a=r||To(n);if(0===ia(e,o,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)a[e]=0;a[r]=1,sa(e,o,a,n);for(let e=0;e<n;e++)t[e*n+r]=a[e]}return t}function ua(e,t,n,r){if(e<n)return fo("Insufficient number of samples. Underdetermined."),0;let o,a,i;const s=To(n*n),l=To(n),c=To(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(na(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function da(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?1/3+s*(i-o)/(l-c):2/3+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function pa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function fa(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function ga(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function ma(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function ha(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function va(e,t){const n=[0,0,0];ha(e,n),ga(n,t)}function Ta(e,t){const n=[0,0,0];fa(e,n),ma(n,t)}function ya(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function ba(e){return!(e[1]-e[0]<0)}function xa(e,t,n){return e<t?t:e>n?n:e}function Ca(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=xa(e[0],t[0],n[0]),r[1]=xa(e[1],t[1],n[1]),r[2]=xa(e[2],t[2],n[2]),r}const Sa=mo("GetScalarTypeFittingRange"),Aa=mo("GetAdjustedScalarRange");const Ia=e=>!Number.isFinite(e),{isFinite:wa,isNaN:Oa}=Number,Pa=Oa;function Ra(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function Ma(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ea(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Va(e){return Math.round(255*e)}var Da,La={Pi:()=>Math.PI,ldexp:function(e,t){return t>1023?e*2**1023*2**(t-1023):t<-1074?5e-324*e*2**(t+1074):e*2**t},radiansFromDegrees:yo,degreesFromRadians:bo,round:xo,floor:Co,ceil:So,ceilLog2:wo,min:Ao,max:Io,arrayMin:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=1/0;for(let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=e.length;r<o;r+=t)e[r]<n&&(n=e[r]);return n},arrayMax:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=-1/0;for(let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=e.length;r<o;r+=t)n<e[r]&&(n=e[r]);return n},arrayRange:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=1/0,r=-1/0;for(let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=e.length;o<a;o+=t)e[o]<n&&(n=e[o]),r<e[o]&&(r=e[o]);return[n,r]},isPowerOfTwo:Ro,nearestPowerOfTwo:Po,factorial:Oo,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=To(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){io()(`${e}`,{global:!0}),go=e},getSeed:function(){return go},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e+((arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)-e)*Math.random()},gaussian:Mo,add:Eo,subtract:Vo,multiplyScalar:Do,multiplyScalar2D:Lo,multiplyAccumulate:Bo,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:No,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Fo,norm:_o,normalize:ko,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=No(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=No(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return Do(n,o),!0},projectVector2D:function(e,t,n){const r=Go(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=Go(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Lo(n,o),!0},distance2BetweenPoints:Uo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Fo(e,t,n),Math.atan2(_o(n),No(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:Go,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:zo,normalize2D:Wo,determinant2x2:Ho,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(ho(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,ho(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Ho(s,u,l,d),f=-Ho(i,c,l,d),g=+Ho(i,c,s,u),m=-Ho(o,u,a,d),h=+Ho(r,c,a,d),v=-Ho(r,c,o,u),T=+Ho(o,s,a,l),y=-Ho(r,i,a,l),b=+Ho(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+T*t[2],S=f*t[0]+h*t[1]+y*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:jo,multiply3x3_mat3:Ko,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&po("Number of columns of A must match number of rows of B.");const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:$o,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Ho(i,c,s,u),p=-Ho(a,l,s,u),f=+Ho(a,l,i,c),g=-Ho(r,c,o,u),m=+Ho(n,l,o,u),h=-Ho(n,l,r,c),v=+Ho(r,i,o,s),T=-Ho(n,a,o,s),y=+Ho(n,a,r,i),b=n*d+r*p+o*f;0===b&&fo("Matrix has 0 determinant"),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=T/b,t[8]=y/b},identity3x3:Zo,identity:Qo,isIdentity:function(e){return Yo(e,so,arguments.length>1&&void 0!==arguments[1]?arguments[1]:co)},isIdentity3x3:function(e){return Yo(e,lo,arguments.length>1&&void 0!==arguments[1]?arguments[1]:co)},determinant3x3:qo,quaternionToMatrix3x3:Jo,areEquals:Xo,areMatricesEqual:Yo,roundNumber:ea,roundVector:ta,matrix3x3ToQuaternion:ra,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],T=e[3]*t[3];n[0]=r-l-f-T,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:oa,diagonalize3x3:aa,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=qo(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];oa(a,t),$o(a,a),Ko(a,t,r),aa(r,n,r),Ko(t,r,t),$o(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:la,invertMatrix:ca,luFactorLinearSystem:ia,luSolveLinearSystem:sa,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return na(e,3,t,n)},jacobiN:na,solveHomogeneousLeastSquares:ua,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return fo("Insufficient number of samples. Underdetermined."),0;const s=To(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>uo&&(p=0,s[u]=0);if(p&&1===o)return fo("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()"),ua(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=To(n),f=ua(e,t,n,l));const m=To(n*n),h=To(n*n),v=To(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const T=ca(m,h,n);if(T)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&T:T},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:da,hsv2rgb:pa,lab2xyz:fa,xyz2lab:ga,xyz2rgb:ma,rgb2xyz:ha,rgb2lab:va,lab2rgb:Ta,uninitializeBounds:ya,areBoundsInitialized:ba,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:xa,clampVector:Ca,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Sa,getAdjustedScalarRange:Aa,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=To(3),a=To(3),i=To(3),s=To(3),l=To(3),c=To(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=_o(s),d=_o(l),p=_o(i),f=To(3);Fo(o,a,f);const g=_o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*No(o,c)/h,T=p*p*No(s,a)/h,y=u*u*No(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+T*t[o]+y*n[o];return m},inf:1/0,negInf:-1/0,isInf:Ia,isNan:Oa,isNaN:Oa,isFinite:wa,createUninitializedBounds:Ra,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:Ma,floatToHex2:Ea,floatRGB2HexCode:function(e){return`${arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#"}${e.map(Ea).join("")}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Va).join(", ")})`:`rgba(${Va(e[0]||0)}, ${Va(e[1]||0)}, ${Va(e[2]||0)}, ${e[3]||0})`}};function Ba(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function Na(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function Fa(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function _a(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}Da=new i(4),i!=Float32Array&&(Da[0]=0,Da[1]=0,Da[2]=0,Da[3]=0);var ka=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};gn(),hn(1,0,0),hn(0,1,0),Na(),Na(),ie();const Ga={};function Ua(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ga,n),Ht.obj(e,t),Ht.setGet(e,t,["transform"]),function(e,t){t.classHierarchy.push("vtkImplicitFunction"),e.functionValue=n=>{if(!t.transform)return e.evaluateFunction(n);const r=[];return t.transform.transformPoint(n,r),e.evaluateFunction(r)},e.evaluateFunction=e=>{Ht.vtkErrorMacro("not implemented")}}(e,t)}var za={newInstance:Ht.newInstance(Ua,"vtkImplicitFunction"),extend:Ua};const Wa=1e-6,Ha="coincide",ja="disjoint";function Ka(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function $a(e,t,n,r){const o=[];Vo(e,t,o);const a=No(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function qa(e,t,n){const r=No(e,t);let o=No(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Xa(e,t,n,r){const o=[];Vo(e,t,o);const a=No(n,o),i=No(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function Ya(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Vo(t,e,a),Vo(n,e,i);const s=No(r,i),l=No(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*Wa:s*Wa,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function Za(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Fo(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<Wa){const r=[];return Vo(e,n,r),0===No(t,r)?o.error=Ha:o.error=ja,o}let s;s=i[0]>i[1]&&i[0]>i[2]?"x":i[1]>i[2]?"y":"z";const l=[],c=-No(t,e),u=-No(r,n);switch(s){case"x":l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case"y":l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case"z":l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Eo(l,a,o.l1),o.intersection=!0,o}const Qa={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ka,projectPoint:$a,projectVector:qa,generalizedProjectPoint:Xa,intersectWithLine:Ya,intersectWithPlane:Za,DISJOINT:ja,COINCIDE:Ha},Ja={normal:[0,0,1],origin:[0,0,0]};function ei(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ja,n),za.extend(e,t,n),Ht.setGetArray(e,t,["normal","origin"],3),function(e,t){t.classHierarchy.push("vtkPlane"),e.distanceToPlane=e=>Ka(e,t.origin,t.normal),e.projectPoint=(e,n)=>{$a(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Xa(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>Ya(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>Za(e,n,t.origin,t.normal)}(e,t)}var ti={newInstance:Ht.newInstance(ei,"vtkPlane"),extend:ei,...Qa};const ni=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function ri(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function oi(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ai(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function ii(e){return ai(e,ni)}function si(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function li(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)si(e,...t[n]);else for(let n=0;n<t.length;n+=3)si(e,...t.slice(n,n+3));return e}function ci(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function ui(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function di(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function pi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function fi(e,t,n,r){return!!oi(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function gi(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function mi(e,t){return e[2*t+1]-e[2*t]}function hi(e){return[mi(e,0),mi(e,1),mi(e,2)]}function vi(e){return e.slice(0,2)}function Ti(e){return e.slice(2,4)}function yi(e){return e.slice(4,6)}function bi(e){const t=hi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function xi(e){if(oi(e)){const t=hi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Ci(e){return[e[0],e[2],e[4]]}function Si(e){return[e[1],e[3],e[5]]}function Ai(e,t){return e<=0&&t>=0||e>=0&&t<=0}function Ii(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function wi(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Oi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=Ii(e,[]);for(let e=0;e<r.length;++e)wn(r[e],r[e],t);return ii(n),li(n,r)}function Pi(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Ri(e,t,n,r){const o=[].concat(ni),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=No(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=No(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=No(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Mi(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ei(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ti.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function Vi(e,t){if(!oi(e)||!oi(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Di(e,t){if(!oi(e)||!oi(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function Li(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Bi(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ti.evaluate(n,t,l)}let i=2;for(;i--&&!(Ai(o[r[i][0]],o[r[i][4]])&&Ai(o[r[i][1]],o[r[i][5]])&&Ai(o[r[i][2]],o[r[i][6]])&&Ai(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class Ni{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(ni))}getBounds(){return this.bounds}equals(e){return ri(this.bounds,e)}isValid(){return oi(this.bounds)}setBounds(e){return ai(this.bounds,e)}reset(){return ii(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return si(this.bounds,...t)}addPoints(e){return li(this.bounds,e)}addBounds(e,t,n,r,o,a){return ci(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return ui(this.bounds,e,t,n)}setMaxPoint(e,t,n){return di(this.bounds,e,t,n)}inflate(e){return pi(this.bounds,e)}scale(e,t,n){return fi(this.bounds,e,t,n)}getCenter(){return gi(this.bounds)}getLength(e){return mi(this.bounds,e)}getLengths(){return hi(this.bounds)}getMaxLength(){return bi(this.bounds)}getDiagonalLength(){return xi(this.bounds)}getMinPoint(){return Ci(this.bounds)}getMaxPoint(){return Si(this.bounds)}getXRange(){return vi(this.bounds)}getYRange(){return Ti(this.bounds)}getZRange(){return yi(this.bounds)}getCorners(e){return Ii(this.bounds,e)}computeCornerPoints(e,t){return wi(this.bounds,e,t)}computeLocalBounds(e,t,n){return Ri(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Oi(this.bounds,e,t)}computeScale3(e){return Pi(this.bounds,e)}cutWithPlane(e,t){return Bi(this.bounds,e,t)}intersectBox(e,t,n,r){return Mi(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ei(this.bounds,e,t)}intersect(e){return Vi(this.bounds,e)}intersects(e){return Di(this.bounds,e)}containsPoint(e,t,n){return Li(this.bounds,e,t,n)}contains(e){return Di(this.bounds,e)}}var Fi={newInstance:function(e){const t=e&&e.bounds;return new Ni(t)},equals:ri,isValid:oi,setBounds:ai,reset:ii,addPoint:si,addPoints:li,addBounds:ci,setMinPoint:ui,setMaxPoint:di,inflate:pi,scale:fi,scaleAboutCenter:function(e,t,n,r){if(!oi(e))return!1;const o=gi(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],fi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:gi,getLength:mi,getLengths:hi,getMaxLength:bi,getDiagonalLength:xi,getMinPoint:Ci,getMaxPoint:Si,getXRange:vi,getYRange:Ti,getZRange:yi,getCorners:Ii,computeCornerPoints:wi,computeLocalBounds:Ri,transformBounds:Oi,computeScale3:Pi,cutWithPlane:Bi,intersectBox:Mi,intersectPlane:Ei,intersect:Vi,intersects:Di,containsPoint:Li,contains:function(e,t){return!!Di(e,t)&&!!Li(e,...Ci(t))&&!!Li(e,...Si(t))},INIT_BOUNDS:ni},_i={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:ki}=_i;function Gi(e){return()=>Ht.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}const Ui={allocatedRenderTime:10,coordinateSystem:ki.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function zi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ui,n),Ht.obj(e,t),Ht.get(e,t,["estimatedRenderTime","allocatedRenderTime"]),Ht.setGet(e,t,["_parentProp","coordinateSystem","dragable","pickable","renderTimeMultiplier","useBounds","visibility"]),Ht.moveToProtected(e,t,["parentProp"]),function(e,t){t.classHierarchy.push("vtkProp"),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=Gi("pick"),e.hasKey=Gi("hasKey"),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(ki.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(ki.DISPLAY)}(e,t)}var Wi={newInstance:Ht.newInstance(zi,"vtkProp"),extend:zi,..._i};const Hi={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[...Fi.INIT_BOUNDS],properties:[],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function ji(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hi,n),Wi.extend(e,t,n),t.matrixMTime={},Ht.obj(t.matrixMTime),Ht.get(e,t,["isIdentity"]),Ht.getArray(e,t,["orientation"]),Ht.setGetArray(e,t,["origin","position","scale"],3),Ht.setGet(e,t,["properties"]),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,function(e,t){t.classHierarchy.push("vtkProp3D"),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=Na();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[bo(r),n[0],n[1],n[2]]},e.getOrientationQuaternion=function(){return N(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t.rotation)},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,yo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,yo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,yo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=yo(n),s=Na();Fa(s,[r,o,a],i);const l=new Float64Array(16);k(l,s),y(t.rotation,t.rotation,l),e.modified()},e.rotateQuaternion=n=>{if(Math.abs(n[3])>=.999999)return;const r=k(new Float64Array(16),n);y(t.rotation,t.rotation,r),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!Yo(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&y(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),y(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getBoundsByReference=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n,t.bounds=[...Fi.INIT_BOUNDS],t.boundsMTime.modified(),n;if(!t.mapperBounds||!n.every(((e,r)=>n[r]===t.mapperBounds[r]))||e.getMTime()>t.boundsMTime.getMTime()){Ht.vtkDebugMacro("Recomputing bounds..."),t.mapperBounds=n,e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),Fi.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}return t.bounds},e.getBounds=()=>{const t=e.getBoundsByReference();try{return[...t]}catch{return t}},e.getCenter=()=>Fi.getCenter(t.bounds),e.getLength=()=>Fi.getLength(t.bounds),e.getXRange=()=>Fi.getXRange(t.bounds),e.getYRange=()=>Fi.getYRange(t.bounds),e.getZRange=()=>Fi.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()})),e.getProperty=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null==t.properties[n]&&(t.properties[n]=e.makeProperty?.()),t.properties[n]},e.setProperty=(e,n)=>{const r=Number.isInteger(e),[o,a]=r?[e,n]:[0,e];return t.properties[o]!==a&&(t.properties[o]=a,!0)},e.getMTime=()=>{let e=t.mtime;return t.properties.forEach((t=>{if(null!==t){const n=t.getMTime();e=n>e?n:e}})),e}}(e,t)}var Ki={newInstance:Ht.newInstance(ji,"vtkProp3D"),extend:ji};const $i={FLAT:0,GOURAUD:1,PHONG:2},qi={POINTS:0,WIREFRAME:1,SURFACE:2};var Xi={Shading:$i,Representation:qi,Interpolation:$i};const{Representation:Yi,Interpolation:Zi}=Xi;function Qi(e){return()=>Ht.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}const Ji={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:Zi.GOURAUD,representation:Yi.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null,ORMTexture:null,RMTexture:null};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),Ht.obj(e,t),Ht.setGet(e,t,["lighting","interpolation","ambient","diffuse","metallic","roughness","normalStrength","emission","baseIOR","specular","specularPower","opacity","edgeVisibility","lineWidth","pointSize","backfaceCulling","frontfaceCulling","representation","diffuseTexture","metallicTexture","roughnessTexture","normalTexture","ambientOcclusionTexture","emissionTexture","ORMTexture","RMTexture"]),Ht.setGetArray(e,t,["ambientColor","specularColor","diffuseColor","edgeColor"],3),function(e,t){t.classHierarchy.push("vtkProperty"),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=Qi("ComputeCompositeColor"),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=Qi("AddShaderVariable"),e.setInterpolationToFlat=()=>e.setInterpolation(Zi.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(Zi.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(Zi.PHONG),e.getInterpolationAsString=()=>Ht.enumToString(Zi,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(Yi.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(Yi.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(Yi.POINTS),e.getRepresentationAsString=()=>Ht.enumToString(Yi,t.representation)}(e,t)}var ts={newInstance:Ht.newInstance(es,"vtkProperty"),extend:es,...Xi};const ns={mapper:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1};function rs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ns,n),Ki.extend(e,t,n),t.boundsMTime={},Ht.obj(t.boundsMTime),Ht.setGet(e,t,["backfaceProperty","forceOpaque","forceTranslucent","mapper"]),function(e,t){t.classHierarchy.push("vtkActor");const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.properties[0]||e.getProperty();let n=t.properties[0].getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(t.properties[0]||e.getProperty(),!e.getIsOpaque()),e.makeProperty=ts.newInstance,e.getMTime=()=>{let e=n.getMTime();if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}(e,t)}var os={newInstance:Ht.newInstance(rs,"vtkActor"),extend:rs};const as={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},is={VOID:"",CHAR:"Int8Array",SIGNED_CHAR:"Int8Array",UNSIGNED_CHAR:"Uint8Array",UNSIGNED_CHAR_CLAMPED:"Uint8ClampedArray",SHORT:"Int16Array",UNSIGNED_SHORT:"Uint16Array",INT:"Int32Array",UNSIGNED_INT:"Uint32Array",FLOAT:"Float32Array",DOUBLE:"Float64Array"};var ss={DefaultDataType:is.FLOAT,DataTypeByteSize:as,VtkDataTypes:is};const{vtkErrorMacro:ls}=jt,{DefaultDataType:cs}=ss;function us(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function ds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return us(r,0,1)}return us(e,t<0?0:t,n)}function ps(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function fs(e){return Object.prototype.toString.call(e).slice(8,-1)}const gs={computeRange:ds,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get(){return{min:e,max:t,count:n,sum:r,mean:r/n}},getRange(){return{min:e,max:t}}}},fastComputeRange:us,getDataType:fs,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=_o(r,t);a>n&&(n=a)}return n}},ms={name:"",numberOfComponents:1,dataType:cs,rangeTuple:[0,0]};function hs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,ms,n),Array.isArray(n.values)&&void 0===n.dataType&&console.warn("vtkDataArray.newInstance: no dataType provided, converting to Float32Array"),!t.empty&&!t.values&&!t.size)throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");if(t.values?Array.isArray(t.values)&&(t.values=st(t.dataType,t.values)):t.values=it(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=fs(t.values)),vt(e,t),Ct(e,t,["name","numberOfComponents"]),t.size%t.numberOfComponents!=0)throw new RangeError("model.size is not a multiple of model.numberOfComponents");!function(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=it(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push("vtkDataArray"),e.dataChange=()=>{t.ranges=null,e.modified()},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=ps(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=ds(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=ps(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.getRanges=function(){if(arguments.length>0&&void 0!==arguments[0]&&!arguments[0])return structuredClone(t.ranges);const n=[];for(let r=0;r<t.numberOfComponents;r++){const[t,o]=e.getRange(r),a={min:t,max:o};n.push(a)}if(t.numberOfComponents>1){const[t,r]=e.getRange(-1),o={min:t,max:r};n.push(o)}return n},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e-6;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:1)*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>vs({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=fs(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),t.ranges=structuredClone(n.getRanges()),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||ls("numberOfComponents must match");const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}(e,t)}const vs=Et(hs,"vtkDataArray");var Ts={newInstance:vs,extend:hs,...gs,...ss};const ys={clippingPlanes:[]};var bs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ys,n),Ht.obj(e,t),Ht.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),function(e,t){t.classHierarchy.push("vtkAbstractMapper"),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA("vtkPlane")&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}Ht.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}(e,t)},xs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,(e=>({bounds:[...Fi.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e}))(n)),bs(e,t,n),Ht.setGet(e,t,["viewSpecificProperties"]),function(e,t){e.getBounds=()=>(Ht.vtkErrorMacro("vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED"),Ra()),e.getCenter=()=>{const n=e.getBounds();return t.center=Fi.isValid(n)?Fi.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return Fi.getDiagonalLength(t)}}(e,t)};const{vtkErrorMacro:Cs,vtkWarningMacro:Ss}=Ht,As={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function Is(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,As,n),Ht.obj(e,t),function(e,t){t.classHierarchy.push("vtkFieldData");const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>"number"==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():""},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else Cs("Unhandled case in passData");else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Ts.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:Ht.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Ss("Unexpected case in interpolateData")}else t.insertTuples(s.getTuples());else Cs("Unhandled case in interpolateData");else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Ts.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:Ht.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}(e,t)}var ws={newInstance:Ht.newInstance(Is,"vtkFieldData"),extend:Is};const Os={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ps={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:Os,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:"vtkGhostType"};const{AttributeTypes:Rs,AttributeCopyOperations:Ms}=Ps,{vtkWarningMacro:Es}=Ht,Vs={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function Ds(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vs,n),ws.extend(e,t,n),Ht.setGet(e,t,["activeScalars","activeNormals","activeTCoords","activeVectors","activeTensors","activeGlobalIds","activePedigreeIds"]),t.arrays||(t.arrays={}),function(e,t){const n=["Scalars","Vectors","Normals","TCoords","Tensors","GlobalIds","PedigreeIds"];function r(e){let t=n.find((t=>Rs[t.toUpperCase()]===e||"number"!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push("vtkDataSetAttributes");const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&"PEDIGREEIDS"===a.toUpperCase()&&!n.isA("vtkDataArray"))return Es(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Es(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if("PEDIGREEIDS"!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA("vtkDataArray"))return Es(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Es(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Ms.PASSDATA][Rs[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Ms.PASSDATA][Rs[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(Ms).filter((e=>"ALLCOPY"!==e)).forEach((e=>{t.copyAttributeFlags[Ms[e]]=Object.keys(Rs).filter((e=>"NUM_ATTRIBUTES"!==e)).reduce(((e,t)=>(e[Rs[t]]=!0,e)),[])})),t.copyAttributeFlags[Ms.COPYTUPLE][Rs.GLOBALIDS]=!1,t.copyAttributeFlags[Ms.INTERPOLATE][Rs.GLOBALIDS]=!1,t.copyAttributeFlags[Ms.COPYTUPLE][Rs.PEDIGREEIDS]=!1},e.initialize=Ht.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||"vtkDataArray"!==t.dataArrays[n].type||e.addArray(Ts.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}(e,t)}var Ls={newInstance:Ht.newInstance(Ds,"vtkDataSetAttributes"),extend:Ds,...Ps};const Bs=["pointData","cellData","fieldData"],Ns={};function Fs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ns,n),Ht.obj(e,t),Ht.setGet(e,t,Bs),function(e,t){t.classHierarchy.push("vtkDataSet"),Bs.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=Ls.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),Bs.forEach((n=>{t[n]=Ls.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}(e,t)}var _s={newInstance:Ht.newInstance(Fs,"vtkDataSet"),extend:Fs,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const ks={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var Gs={StructuredType:ks};const{StructuredType:Us}=Gs;var zs={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?Us.EMPTY:3===t?Us.XYZ_GRID:2===t?e[0]===e[1]?Us.YZ_PLANE:e[2]===e[3]?Us.XZ_PLANE:Us.XY_PLANE:1===t?e[0]<e[1]?Us.X_LINE:e[2]<e[3]?Us.Y_LINE:Us.Z_LINE:Us.SINGLE_POINT},...Gs};const{vtkErrorMacro:Ws}=Ht,Hs={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:ks.EMPTY};function js(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hs,n),_s.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),Ht.get(e,t,["indexToWorld","worldToIndex"]),Ht.setGetArray(e,t,["origin","spacing"],3),Ht.setGetArray(e,t,["direction"],9),Ht.getArray(e,t,["extent"],6),function(e,t){t.classHierarchy.push("vtkImageData"),e.setExtent=function(){if(t.deleted)return Ws("instance deleted - cannot call any method"),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=zs.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)Ws("instance deleted - cannot call any method");else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void Ws("Bad dimension specification");n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return Ws("Requesting a point from an empty image."),null;const o=new Float64Array(3);switch(t.dataDescription){case ks.EMPTY:return null;case ks.SINGLE_POINT:break;case ks.X_LINE:o[0]=n;break;case ks.Y_LINE:o[1]=n;break;case ks.Z_LINE:o[2]=n;break;case ks.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case ks.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case ks.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case ks.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:Ws("Invalid dataDescription")}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>Fi.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>Fi.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return wn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return wn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Fi.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Fi.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>Fi.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];Fi.computeCornerPoints(r,o,a),ta(o,o),ta(a,a);const i=e.getDimensions();Ca(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Ca(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0;return{minimum:d,maximum:u,average:m,variance:h,sigma:Math.sqrt(h),count:g}},e.computeIncrements=function(e){const t=[];let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;for(let r=0;r<3;++r)t[r]=n,n*=e[2*r+1]-e[2*r]+1;return t},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return Ws(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return Ws(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}(e,t)}var Ks={newInstance:Ht.newInstance(js,"vtkImageData"),extend:js};const $s={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var qs={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:$s,Scale:{LINEAR:0,LOG10:1}},Xs={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:Ys,Scale:Zs,VectorMode:Qs}=qs,{VtkDataTypes:Js}=Ts,{ColorMode:el}=Xs,{vtkErrorMacro:tl}=Ht;function nl(e){return e}function rl(e){return Math.floor(255*e+.5)}const ol={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:Qs.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1,scale:Zs.LINEAR};function al(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ol,n),Ht.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],Ht.setGet(e,t,["vectorSize","vectorComponent","vectorMode","alpha","indexedLookup"]),Ht.setArray(e,t,["mappingRange"],2),Ht.getArray(e,t,["mappingRange"]),function(e,t){t.classHierarchy.push("vtkScalarsToColors"),e.setVectorModeToMagnitude=()=>e.setVectorMode(Qs.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(Qs.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(Qs.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)tl("Values and annotations do not have the same number of tuples so ignoring");else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===el.DEFAULT&&(t.getDataType()===Js.UNSIGNED_CHAR||t.getDataType()===Js.UNSIGNED_CHAR_CLAMPED)||n===el.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:"vtkDataArray",name:"temp",numberOfComponents:4,dataType:Js.UNSIGNED_CHAR},i=Ht.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Ts.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,Ys.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,Ys.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===Qs.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==Qs.MAGNITUDE||1!==c&&1!==s||(i=Qs.COMPONENT));let u=0;switch(l>0&&(u=l),i){case Qs.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case Qs.RGBCOLORS:break;case Qs.MAGNITUDE:default:{const o=Ts.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=rl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Js.UNSIGNED_CHAR)return n;const i=Ts.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Js.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=nl;switch(n.getDataType()!==Js.FLOAT&&n.getDataType()!==Js.DOUBLE||(s=rl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return tl("Cannot convert colors"),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==el.DEFAULT||n.getDataType()!==Js.UNSIGNED_CHAR)&&r!==el.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}(e,t)}var il={newInstance:Ht.newInstance(al,"vtkScalarsToColors"),extend:al,...qs};const{vtkErrorMacro:sl}=Ht,ll={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function cl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ll,n),il.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},Ht.obj(t.buildTime),t.opaqueFlagBuildTime={},Ht.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},Ht.obj(t.insertTime,{mtime:0}),Ht.get(e,t,["buildTime"]),Ht.setGet(e,t,["numberOfColors","useAboveRangeColor","useBelowRangeColor"]),Ht.setArray(e,t,["alphaRange","hueRange","saturationRange","valueRange"],2),Ht.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),Ht.getArray(e,t,["hueRange","saturationRange","valueRange","alphaRange","nanColor","belowRangeColor","aboveRangeColor"]),function(e,t){t.classHierarchy.push("vtkLookupTable"),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4-3,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=Pa(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===$s.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===$s.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,pa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return sl("Expected 4 components for RGBA colors"),!1;if(n.getDataType()!==is.UNSIGNED_CHAR)return sl("Expected unsigned char values for RGBA colors"),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}(e,t)}var ul={newInstance:Ht.newInstance(cl,"vtkLookupTable"),extend:cl};const dl={Off:0,PolygonOffset:1};let pl=dl.PolygonOffset,fl=dl.Off;const gl=["VTK_RESOLVE_OFF","VTK_RESOLVE_POLYGON_OFFSET"];function ml(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=fl===e;return fl=e,t}var hl={Resolve:dl,getResolveCoincidentTopologyAsString:function(){return gl[fl]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return pl},getResolveCoincidentTopology:function(){return fl},setResolveCoincidentTopology:ml,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){const t=pl===e;return pl=e,t},setResolveCoincidentTopologyToDefault:function(){return ml(dl.Off)},setResolveCoincidentTopologyToOff:function(){return ml(dl.Off)},setResolveCoincidentTopologyToPolygonOffset:function(){return ml(dl.PolygonOffset)}};function vl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=Ht.objectSetterMap.object(e,t,{name:n.key,params:["factor","offset"]})}))}const Tl=["Polygon","Line","Point"],yl={modified:()=>{}};vl(yl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},Tl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var bl={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),Ht.setGet(e,t,["resolveCoincidentTopology"]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(hl).forEach((t=>{e[t]=hl[t]})),Object.keys(yl).filter((e=>"modified"!==e)).forEach((t=>{e[t]=yl[t]})),vl(e,t.topologyOffset,Tl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=yl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=yl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=yl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:yl,otherStaticMethods:hl,CATEGORIES:Tl,Resolve:dl};const xl={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var Cl={PassTypes:xl};const{FieldAssociations:Sl}=_s,{staticOffsetAPI:Al,otherStaticMethods:Il}=bl,{ColorMode:wl,ScalarMode:Ol,GetArray:Pl}=Xs,{VectorMode:Rl}=qs,{VtkDataTypes:Ml}=Ts;function El(e){return()=>Ht.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function Vl(e,t){const n=e[1]%2==0?1:-1;if(e[0]+=n,e[0]>=t[0]||e[0]<0){const r=e[2]%2==0?1:-1;e[0]-=n,e[1]+=r,(e[1]>=t[1]||e[1]<0)&&(e[1]-=r,e[2]++)}}function Dl(e,t,n){const r=Math.floor(t),o=r%(2*n[0]);let a,i;o<n[0]?(e[0]=o,a=1,i=e[0]===n[0]-1):(e[0]=2*n[0]-1-o,a=-1,i=0===e[0]);const s=Math.floor(r/n[0]),l=s%(2*n[1]);let c,u;l<n[1]?(e[1]=l,c=1,u=e[1]===n[1]-1):(e[1]=2*n[1]-1-l,c=-1,u=0===e[1]),e[2]=Math.floor(s/n[1]);const d=t-r;i?u?e[2]+=d:e[1]+=c*d:e[0]+=a*d,e[0]=(e[0]+.5)/n[0],e[1]=(e[1]+.5)/n[1],e[2]=(e[2]+.5)/n[2]}const Ll=new WeakMap;const Bl={colorMapColors:null,areScalarsMappedFromCells:!1,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,numberOfColorsInRange:0,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function Nl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bl,n),xs(e,t,n),Ht.get(e,t,["areScalarsMappedFromCells","colorCoordinates","colorMapColors","colorTextureMap","numberOfColorsInRange","selectionWebGLIdsToVTKIds"]),Ht.setGet(e,t,["colorByArrayName","arrayAccessMode","colorMode","fieldDataTupleId","interpolateScalarsBeforeMapping","lookupTable","populateSelectionSettings","renderTime","scalarMode","scalarVisibility","static","useLookupTableScalarRange","customShaderAttributes"]),Ht.setGetArray(e,t,["scalarRange"],2),bl.implementCoincidentTopologyMethods(e,t),function(e,t){t.classHierarchy.push("vtkMapper"),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Ra(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=ul.newInstance()},e.getColorModeAsString=()=>Ht.enumToString(wl,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>Ht.enumToString(Ol,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFlag:!1};let i=null,s=!1;if(n===Ol.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===Ol.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===Ol.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===Ol.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===Pl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Ol.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===Pl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Ol.USE_FIELD_DATA){const t=e.getFieldData();i=r===Pl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const{scalars:o,cellFlag:a}=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName);if(t.areScalarsMappedFromCells=a,!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const i=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==i){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(o,a))t.mapScalarsToTexture(o,a,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},t.mapScalarsToTexture=(n,r,o)=>{const a=t.lookupTable.getRange(),i=t.lookupTable.usingLogScale(),s=t.lookupTable.getAlpha(),l=i?[Math.log10(a[0]),Math.log10(a[1])]:a;if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==o){t.lookupTable.setAlpha(o),t.colorTextureMap=null,t.lookupTable.build();const e=t.lookupTable.getNumberOfAvailableColors(),n=2048,a=2,d=r?n**3-3:4094;t.numberOfColorsInRange=Math.min(Math.max(e,a),d);const p=t.numberOfColorsInRange+3,f=t.numberOfColorsInRange+2,g=r?[Math.min(Math.ceil(p/n**0),n),Math.min(Math.ceil(p/n**1),n),Math.min(Math.ceil(p/n**2),n)]:[f,2,1],m=g[0]*g[1]*g[2],h=new Float64Array(m);h.fill(NaN);const v=t.numberOfColorsInRange,T=v+2,y=[0,0,0],b=l[0],x=l[1]-l[0];for(let e=0;e<T;++e){const t=b+x*(e-1)/(v-1),n=i?10**t:t;h[(u=g,(c=y)[0]+u[0]*(c[1]+u[1]*c[2]))]=n,Vl(y,g)}const C=Ts.newInstance({numberOfComponents:1,values:h}),S=t.lookupTable.mapScalars(C,t.colorMode,0);t.colorTextureMap=Ks.newInstance(),t.colorTextureMap.setDimensions(g),t.colorTextureMap.getPointData().setScalars(S),t.lookupTable.setAlpha(s)}var c,u;const d=t.lookupTable.getVectorMode()===Rl.MAGNITUDE&&n.getNumberOfComponents()>1?-1:t.lookupTable.getVectorComponent();t.colorCoordinates=function(e,t,n,r,o,a,i){const s=new Array(arguments.length);for(let e=0;e<arguments.length;++e){const t=arguments[e];s[e]=t.getMTime?.()??t}const l=s.join("/"),c=Ll.get(e);if(c&&c.stringHash===l)return c.textureCoordinates;const u=(n[1]-n[0])/(o-1),[d,p]=[n[0]-u,n[1]+u],f=d-.5*u,g=1/(p-d+u),m=d,h=(o+1)/(p-d),v=e.getData(),T=e.getNumberOfTuples(),y=e.getNumberOfComponents(),b=t<0||t>=y,x=a[2]<=1?2:3,C=Ts.newInstance({numberOfComponents:x,values:new Float32Array(T*x)}),S=C.getData(),A=[0,0,0];Dl(A,o+2,a);let I=0,w=0;const O=[.5,.5,.5];for(let e=0;e<T;++e){let e;if(b){let t=0;for(let e=0;e<y;++e){const n=v[I+e];t+=n*n}e=Math.sqrt(t)}else e=v[I+t];if(r&&(e=Math.log10(e)),I+=y,Pa(e))O[0]=A[0],O[1]=A[1],O[2]=A[2];else if(i){let t=(e-m)*h;t<1?t=0:t>o&&(t=o+1),Dl(O,t,a)}else{O[1]=.49;const t=(e-f)*g;O[0]=t>1e3?1e3:t<-1e3?-1e3:t}for(let e=0;e<x;++e)S[w++]=O[e]}return Ll.set(e,{stringHash:l,textureCoordinates:C}),C}(n,d,l,i,t.numberOfColorsInRange,t.colorTextureMap.getDimensions(),r)},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=(e,n)=>!((!n||t.colorMode===wl.DIRECT_SCALARS)&&(!t.interpolateScalarsBeforeMapping||t.lookupTable&&t.lookupTable.getIndexedLookup()||!e||t.colorMode===wl.DEFAULT&&e.getDataType()===Ml.UNSIGNED_CHAR||t.colorMode===wl.DIRECT_SCALARS)),e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=El("AcquireInvertibleLookupTable"),e.valueToColor=El("ValueToColor"),e.colorToValue=El("ColorToValue"),e.useInvertibleColorFor=El("UseInvertibleColorFor"),e.clearInvertibleColor=El("ClearInvertibleColor"),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer(xl.ID_LOW24),o=e.getRawPixelBuffer(xl.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Sl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Sl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===xl.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer(xl.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===xl.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n];e.getPixelBuffer(xl.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}(e,t)}var Fl={newInstance:Ht.newInstance(Nl,"vtkMapper"),extend:Nl,...Al,...Il,...Xs};function _l(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function kl(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const Gl={extractCellSizes:_l,getNumberOfCells:kl};function Ul(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Ts.extend(e,t,function(e){return{empty:!0,numberOfComponents:1,dataType:is.UNSIGNED_INT,...e}}(n)),function(e,t){t.classHierarchy.push("vtkCellArray");const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=kl(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=_l(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{const r=e.getNumberOfCells();return e.insertNextTuples([n.length,...n]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(n.length),r}}(e,t)}var zl={newInstance:Ht.newInstance(Ul,"vtkCellArray"),extend:Ul,...Gl};const{vtkErrorMacro:Wl}=Ht,Hl=[1,-1,1,-1,1,-1],jl={empty:!0,numberOfComponents:3,dataType:is.FLOAT,bounds:[1,-1,1,-1,1,-1]};function Kl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jl,n),Ts.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkPoints"),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=Ht.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return Wl(`getBounds called on an array with components of\n        ${e.getNumberOfComponents()}`),Hl;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}(e,t)}var $l={newInstance:Ht.newInstance(Kl,"vtkPoints"),extend:Kl};const ql={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function Xl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ql,n),Ht.obj(e,t),t.points||(t.points=$l.newInstance()),Ht.get(e,t,["points","pointsIds"]),function(e,t){t.classHierarchy.push("vtkCell"),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=Ht.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else ya(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{Ht.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.")}}(e,t)}var Yl={newInstance:Ht.newInstance(Xl,"vtkCell"),extend:Xl};const Zl={array:null,maxId:0,extend:0};function Ql(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zl,n),Ht.obj(e,t),function(e,t){t.classHierarchy.push("vtkCellLinks"),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA("vtkPolyData")){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Yl.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Yl.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}(e,t)}var Jl={newInstance:Ht.newInstance(Ql,"vtkCellLinks"),extend:Ql};const ec=0,tc=1,nc=2,rc=3,oc=4,ac=5,ic=6,sc=7,lc=9,cc=21,uc=41,dc=42,pc=["vtkEmptyCell","vtkVertex","vtkPolyVertex","vtkLine","vtkPolyLine","vtkTriangle","vtkTriangleStrip","vtkPolygon","vtkPixel","vtkQuad","vtkTetra","vtkVoxel","vtkHexahedron","vtkWedge","vtkPyramid","vtkPentagonalPrism","vtkHexagonalPrism","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkQuadraticEdge","vtkQuadraticTriangle","vtkQuadraticQuad","vtkQuadraticTetra","vtkQuadraticHexahedron","vtkQuadraticWedge","vtkQuadraticPyramid","vtkBiQuadraticQuad","vtkTriQuadraticHexahedron","vtkQuadraticLinearQuad","vtkQuadraticLinearWedge","vtkBiQuadraticQuadraticWedge","vtkBiQuadraticQuadraticHexahedron","vtkBiQuadraticTriangle","vtkCubicLine","vtkQuadraticPolygon","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkConvexPointSet","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkParametricCurve","vtkParametricSurface","vtkParametricTriSurface","vtkParametricQuadSurface","vtkParametricTetraRegion","vtkParametricHexRegion","UnknownClass","UnknownClass","UnknownClass","vtkHigherOrderEdge","vtkHigherOrderTriangle","vtkHigherOrderQuad","vtkHigherOrderPolygon","vtkHigherOrderTetrahedron","vtkHigherOrderWedge","vtkHigherOrderPyramid","vtkHigherOrderHexahedron"],fc={getClassNameFromTypeId:function(e){return e<pc.length?pc[e]:"UnknownClass"},getTypeIdFromClassName:function(e){return pc.findIndex(e)},isLinear:function(e){return e<cc||e===uc||e===dc},hasSubCells:function(e){return e===ic||e===oc||e===nc}},gc={size:0,maxId:-1,extend:1e3};function mc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gc,n),Ht.obj(e,t),Ht.get(e,t,["size","maxId","extend"]),Ht.getArray(e,t,["typeArray","locationArray"]),function(e,t){t.classHierarchy.push("vtkCellTypes"),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=ec},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}(e,t)}var hc={newInstance:Ht.newInstance(mc,"vtkCellTypes"),extend:mc,...fc},vc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:Tc}=vc;function yc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=No(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Uo(i,e),o}function bc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Vo(t,e,i),Vo(r,n,s),Vo(n,e,l);const c=[No(i,i),-No(i,s),-No(i,s),No(s,s)],u=[];if(u[0]=No(i,l),u[1]=-No(s,l),0===la(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=yc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance,u.t);return Tc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?Tc.YES_INTERSECTION:Tc.NO_INTERSECTION}const xc={distanceToLine:yc,intersection:bc},Cc={orientations:null};function Sc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cc,n),Yl.extend(e,t,n),Ht.setGet(e,t,["orientations"]),function(e,t){t.classHierarchy.push("vtkLine"),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=bc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===Tc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Uo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=yc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=yc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=yc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=yc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}(e,t)}var Ac={newInstance:Ht.newInstance(Sc,"vtkLine"),extend:Sc,...xc,...vc};const Ic={};function wc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ic,n),_s.extend(e,t,n),Ht.setGet(e,t,["points"]),function(e,t){t.classHierarchy.push("vtkPointSet"),t.points?t.points=We(t.points):t.points=$l.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),t.points=$l.newInstance(),t.points.shallowCopy(e.getPoints())}}(e,t)}var Oc={newInstance:Ht.newInstance(wc,"vtkPointSet"),extend:wc};function Pc(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function Rc(e,t,n,r){Pc(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}const Mc={computeNormalDirection:Pc,computeNormal:Rc,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];Rc(e,t,n,d),Rc(r,o,a,p);const f=-No(d,e),g=-No(p,r),m=[No(p,e)+g,No(p,t)+g,No(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[No(d,r)+f,No(d,o)+f,No(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],T=[r,o,a],y=No(d,p),b=(f-g*y)/(y*y-1),x=(g-f*y)/(y*y-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Fo(d,p,[]);ko(S);let A=0,I=0;const w=[],O=[];let P,R,M=50,E=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ti.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=No(a.x,S)-No(C,S));const s=ti.intersectWithLine(T[n],T[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(E=I),O[I++]=No(s.x,S)-No(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=O[2];O[2]=O[E],O[E]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(O[0])||Number.isNaN(O[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(O[0]>O[1]){const e=O[1];O[1]=O[0],O[0]=e}return w[1]<O[0]||O[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<O[0]?w[1]<O[1]?(u[0]=2,u[1]=1,P=O[0],R=w[1]):(u[0]=2,u[1]=2,P=O[0],R=O[1]):w[1]<O[1]?(u[0]=1,u[1]=1,P=w[0],R=w[1]):(u[0]=1,u[1]=2,P=w[0],R=O[1]),Bo(C,S,P,l),Bo(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}},Ec={};function Vc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ec,n),Yl.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkTriangle"),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(Rc(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ti.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Uo(u,d),h=Uo(d,p),v=Uo(p,u);t.line||(t.line=Ac.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const T=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=T.betweenPoints,s.t=T.t,T.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=No(n,e)/v,i[1]=No(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const T=[];let y,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),Pc(l,c,u,d),ti.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(T[s++]=i);for(i=0;i<2;i++)f[i]=I[T[i]]-u[T[i]],g[i]=l[T[i]]-u[T[i]],m[i]=c[T[i]]-u[T[i]];if(h=Ho(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Ho(f,m)/h,r[1]=Ho(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Uo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(y=Uo(e,u),b=Ac.distanceToLine(e,l,u,t,S),x=Ac.distanceToLine(e,u,c,t,A),y<b?(a.dist2=y,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(y=Uo(e,l),b=Ac.distanceToLine(e,l,u,t,S),x=Ac.distanceToLine(e,l,c,t,A),y<b?(a.dist2=y,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(y=Uo(e,c),b=Ac.distanceToLine(e,c,u,t,S),x=Ac.distanceToLine(e,l,c,t,A),y<b?(a.dist2=y,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=Ac.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=Ac.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=Ac.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n}}(e,t)}var Dc={newInstance:Ht.newInstance(Vc,"vtkTriangle"),extend:Vc,...Mc};const Lc=["verts","lines","polys","strips"],{vtkWarningMacro:Bc}=Ht,Nc={[rc]:Ac,[oc]:Ac,[ac]:Dc},Fc={};function _c(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fc,n),Oc.extend(e,t,n),Ht.get(e,t,["cells","links"]),Ht.setGet(e,t,["verts","lines","polys","strips"]),function(e,t){t.classHierarchy.push("vtkPolyData"),Lc.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\w|[A-Z]|\b\w)/g,(e=>e.toUpperCase())).replace(/\s+/g,"")}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=zl.newInstance()})),e.getNumberOfCells=()=>Lc.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),Lc.forEach((n=>{t[n]=zl.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?nc:tc,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?oc:rc,1===t&&Bc("Building VTK_LINE ",n," with only one point, but VTK_LINE needs at least two points. Check the input."),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=ac;break;case 4:l[n]=lc;break;default:l[n]=sc}t<3&&Bc("Building VTK_TRIANGLE ",n," with less than three points, but VTK_TRIANGLE needs at least three points. Check the input."),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(ic,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=hc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=Jl.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case tc:case nc:o=t.verts;break;case rc:case oc:o=t.lines;break;case ac:case lc:case sc:o=t.polys;break;case ic:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||Nc[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}(e,t)}var kc={newInstance:Ht.newInstance(_c,"vtkPolyData"),extend:_c};const Gc={image:null,canvas:null,jsImageData:null,imageBitmap:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function Uc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gc,n),Ht.obj(e,t),Ht.algo(e,t,6,0),Ht.get(e,t,["canvas","image","jsImageData","imageBitmap","imageLoaded","resizable"]),Ht.setGet(e,t,["repeat","edgeClamp","interpolate","mipLevel"]),function(e,t){t.classHierarchy.push("vtkTexture"),e.imageLoaded=()=>{t.image.removeEventListener("load",e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null,t.imageBitmap=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setImageBitmap=n=>{t.imageBitmap!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null,t.jsImageData=null),t.imageBitmap=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.imageBitmap=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null,t.imageBitmap=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener("load",e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),t.imageBitmap&&(n=t.imageBitmap.width,r=t.imageBitmap.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData;if(t.imageBitmap)return t.imageBitmap;if(t.canvas)return t.canvas.getContext("2d").getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=t.image.width,n=t.image.height,r=new OffscreenCanvas(e,n).getContext("2d");return r.translate(0,n),r.scale(1,-1),r.drawImage(t.image,0,0,e,n),r.getImageData(0,0,e,n)}return null}}(e,t)}var zc={newInstance:Ht.newInstance(Uc,"vtkTexture"),extend:Uc,generateMipmaps:(e,t,n)=>{const r=e.createShaderModule({code:"\n    @group(0) @binding(0) var inputTexture: texture_2d<f32>;\n    @group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;\n\n    @compute @workgroup_size(8, 8)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n      let texelCoord = vec2<i32>(global_id.xy);\n      let outputSize = textureDimensions(outputTexture);\n\n      if (texelCoord.x >= i32(outputSize.x) || texelCoord.y >= i32(outputSize.y)) {\n        return;\n      }\n\n      let inputSize = textureDimensions(inputTexture);\n      let scale = vec2<f32>(inputSize) / vec2<f32>(outputSize);\n\n      // Compute the floating-point source coordinate\n      let srcCoord = (vec2<f32>(texelCoord) + 0.5) * scale - 0.5;\n\n      // Get integer coordinates for the four surrounding texels\n      let x0 = i32(floor(srcCoord.x));\n      let x1 = min(x0 + 1, i32(inputSize.x) - 1);\n      let y0 = i32(floor(srcCoord.y));\n      let y1 = min(y0 + 1, i32(inputSize.y) - 1);\n\n      // Compute the weights\n      let wx = srcCoord.x - f32(x0);\n      let wy = srcCoord.y - f32(y0);\n\n      // Fetch the four texels\n      let c00 = textureLoad(inputTexture, vec2<i32>(x0, y0), 0);\n      let c10 = textureLoad(inputTexture, vec2<i32>(x1, y0), 0);\n      let c01 = textureLoad(inputTexture, vec2<i32>(x0, y1), 0);\n      let c11 = textureLoad(inputTexture, vec2<i32>(x1, y1), 0);\n\n      // Bilinear interpolation\n      let color = mix(\n        mix(c00, c10, wx),\n        mix(c01, c11, wx),\n        wy\n      );\n\n      textureStore(outputTexture, texelCoord, color);\n    }\n  "}),o=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm",access:"write-only"}},{binding:2,visibility:GPUShaderStage.COMPUTE,sampler:{type:"filtering"}}]}),a=e.createPipelineLayout({bindGroupLayouts:[o]}),i=e.createComputePipeline({label:"ComputeMipmapPipeline",layout:a,compute:{module:r,entryPoint:"main"}}),s=e.createSampler({magFilter:"linear",minFilter:"linear"});for(let r=1;r<n;r++){const n=t.createView({baseMipLevel:r-1,mipLevelCount:1}),o=t.createView({baseMipLevel:r,mipLevelCount:1}),a=e.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:n},{binding:1,resource:o},{binding:2,resource:s}]}),l=e.createCommandEncoder({label:"MipmapGenerateCommandEncoder"}),c=l.beginComputePass();c.setPipeline(i),c.setBindGroup(0,a);const u=Math.max(1,t.width>>r),d=Math.max(1,t.height>>r),p=Math.ceil(u/8),f=Math.ceil(d/8);c.dispatchWorkgroups(p,f),c.end(),e.queue.submit([l.finish()])}}};const Wc=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],Hc=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],jc=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],Kc=[0,1,0,1,0,1,0,1,2,2,2,2],$c=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],qc=new Float64Array(3),Xc=new Float64Array(3),Yc=new Float64Array(3),Zc=new Float64Array(3),Qc=new Float64Array(3),Jc=new Float64Array(3),eu=new Float64Array(16);function tu(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function nu(e){const t=[],n=[];for(let r=0;r<3;r++){const o=oo().domain([e[2*r],e[2*r+1]]);t[r]=o.ticks(5);const a=o.tickFormat(5);n[r]=t[r].map(a)}return{ticks:t,tickStrings:n}}const ru=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),Ht.obj(e,t),t.tmPolyData=kc.newInstance(),t.tmMapper=Fl.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=os.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),Ht.setGet(e,t,["renderable"]),Ht.get(e,t,["lastSize","lastAspectRatio","axisTextStyle","tickTextStyle","tmActor","ticks"]),t.forceUpdate=!1,t.lastRedrawTime={},Ht.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},Ht.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],function(e,t){t.classHierarchy.push("vtkCubeAxesActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;qc[0]=c[3*n],qc[1]=c[3*n+1],qc[2]=c[3*n+2],wn(Yc,qc,r),Yc[0]+=.1,wn(Xc,Yc,o),yn(Qc,Xc,qc),Yc[0]-=.1,Yc[1]+=.1,wn(Xc,Yc,o),yn(Jc,Xc,qc);for(let e=0;e<3;e++)Qc[e]/=.05*u[0],Jc[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;qc[0]=c[3*n],qc[1]=c[3*n+1],qc[2]=c[3*n+2],a[0]<-.5?xn(Yc,Qc,a[0]*i-l.width):a[0]>.5?xn(Yc,Qc,a[0]*i):xn(Yc,Qc,a[0]*i-l.width/2),Tn(qc,qc,Yc),xn(Yc,Jc,a[1]*i-l.height/2),Tn(qc,qc,Yc),s.points[3*d]=qc[0],s.points[3*d+1]=qc[1],s.points[3*d+2]=qc[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,xn(Yc,Qc,l.width),Tn(qc,qc,Yc),s.points[3*d]=qc[0],s.points[3*d+1]=qc[1],s.points[3*d+2]=qc[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,xn(Yc,Jc,l.height),Tn(qc,qc,Yc),s.points[3*d]=qc[0],s.points[3*d+1]=qc[1],s.points[3*d+2]=qc[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,xn(Yc,Qc,l.width),yn(qc,qc,Yc),s.points[3*d]=qc[0],s.points[3*d+1]=qc[1],s.points[3*d+2]=qc[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(eu,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){qc[0]=f[3*u],qc[1]=f[3*u+1],qc[2]=f[3*u+2],wn(Yc,qc,n),qc[0]=f[3*u+3],qc[1]=f[3*u+4],qc[2]=f[3*u+5],wn(Zc,qc,n),yn(Yc,Yc,Zc);const r=[Yc[0],Yc[1]];Wo(r),e.createPolyDataForOneLabel(g[d],u,n,eu,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,eu,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Ts.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}(e,t)}),"vtkCubeAxesActorHelper");function ou(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};os.extend(e,t,function(e,t,n){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...Fi.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,tickLabelPixelOffset:12,generateTicks:nu,...n,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif",...n?.axisTextStyle},tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif",...n?.tickTextStyle}}}(0,0,n)),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=["X-Axis","Y-Axis","Z-Axis"],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.tmTexture=zc.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=Fl.newInstance(),t.polyData=kc.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=os.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=kc.newInstance(),Ht.setGet(e,t,["axisTitlePixelOffset","boundsScaleFactor","faceVisibilityAngle","gridLines","tickLabelPixelOffset","generateTicks"]),Ht.setGetArray(e,t,["dataBounds"],6),Ht.setGetArray(e,t,["axisLabels"],3),Ht.get(e,t,["axisTextStyle","tickTextStyle","camera","tmTexture","textValues","textPolyData","tickCounts","gridActor"]),function(e,t){t.classHierarchy.push("vtkCubeAxesActor"),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=Fi.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(qc[s]=t.dataBounds[a]-.1*r*Wc[a][s],qc[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),qc[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),wn(Yc,qc,e),qc[s]=t.dataBounds[a],wn(Zc,qc,e),yn(Yc,Zc,Yc),Sn(Yc,Yc),i=Yc[2]>o,t.camera.getParallelProjection()||(Sn(Zc,Zc),i=An(Zc,Yc)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[$c[t][0]].length+2*r[$c[t][1]].length,a+=r[$c[t][0]].length+r[$c[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=jc[e][0],l[3*u+2]=jc[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[$c[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+$c[n][0]]=o[r],s[3*c+$c[n][1]]=t.dataBounds[2*$c[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+$c[n][0]]=o[r],s[3*c+$c[n][1]]=t.dataBounds[2*$c[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[$c[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+$c[n][1]]=o[r],s[3*c+$c[n][0]]=t.dataBounds[2*$c[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+$c[n][1]]=o[r],s[3*c+$c[n][0]]=t.dataBounds[2*$c[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[Kc[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=Hc[a][e];if(1===n[d]){const e=Kc[d],n=3*jc[d][0],p=3*jc[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+$c[a][0]]=.5*(t.dataBounds[2*$c[a][0]]+t.dataBounds[2*$c[a][0]+1]),s[3*l+$c[a][1]]=.5*(t.dataBounds[2*$c[a][1]]+t.dataBounds[2*$c[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[Hc[e][t]]++;const a=t.generateTicks(t.dataBounds);e.updatePolyData(r,n,a.ticks),e.updateTextData(r,n,a.ticks,a.tickStrings),(o||t.forceUpdate)&&e.updateTextureAtlas(a.tickStrings)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){tu(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}tu(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=Po(n),r=Po(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{tu(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),Fi.setBounds(t.bounds,t.gridActor.getBounds()),Fi.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=Ht.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}(e,t)}var au={newInstance:Ht.newInstance(ou,"vtkCubeAxesActor"),extend:ou,newCubeAxesActorHelper:ru,defaultGenerateTicks:nu};const iu={};const su=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,iu,n),Xt.extend(e,t,n),t.CubeAxesActorHelper=au.newCubeAxesActorHelper(),function(e,t){t.classHierarchy.push("vtkOpenGLCubeAxesActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}(e,t)}),"vtkOpenGLCubeAxesActor");en("vtkCubeAxesActor",su);const lu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var cu={ObjectType:lu};const{ObjectType:uu}=cu,du={objectType:uu.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function pu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,du,n),Ht.obj(e,t),Ht.get(e,t,["_openGLRenderWindow","allocatedGPUMemoryInBytes"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){function n(e){switch(e){case uu.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case uu.TEXTURE_BUFFER:if("TEXTURE_BUFFER"in t.context)return t.context.TEXTURE_BUFFER;case uu.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push("vtkOpenGLBufferObject");let r=null,o=null,a=!0,i="";e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i="Trying to upload array buffer to incompatible buffer.",!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}(e,t)}var fu={newInstance:Ht.newInstance(pu),extend:pu,...cu};function gu(e){let t=0,n=0;for(let r=0;r<3;++r){const o=e.getRange(r),a=o[1]-o[0];t+=a*a;const i=.5*(o[1]+o[0]);n+=i*i}const r=t>0&&(Math.abs(n)/t>1e6||Math.abs(Math.log10(t))>3||0===t&&n>1e6);if(r){const t=new Float64Array(3),n=new Float64Array(3);for(let r=0;r<3;++r){const o=e.getRange(r),a=o[1]-o[0];t[r]=.5*(o[1]+o[0]),n[r]=a>0?1/a:1}return{useShiftAndScale:r,coordShift:t,coordScale:n}}return{useShiftAndScale:r,coordShift:new Float32Array([0,0,0]),coordScale:new Float32Array([1,1,1])}}const{vtkErrorMacro:mu}=Ht;const hu={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function vu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hu,n),fu.extend(e,t,n),Ht.setGet(e,t,["colorBO","elementCount","stride","colorBOStride","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorOffset","colorComponents","customData"]),Ht.get(e,t,["coordShift","coordScale","coordShiftAndScaleEnabled","inverseShiftAndScaleMatrix"]),function(e,t){t.classHierarchy.push("vtkOpenGLCellArrayBufferObject"),e.setType(lu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=fu.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,T=0,y=0;const b={anythingToPoints(e,t,n,r){for(let o=0;o<e;++o)f(t[n+o],r)},linesToWireframe(e,t,n,r){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r)},polysToWireframe(e,t,n,r){if(e>2)for(let o=0;o<e;++o)f(t[n+o],r),f(t[n+(o+1)%e],r)},stripsToWireframe(e,t,n,r){if(e>2){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r);for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+2],r)}},polysToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+0],r),f(t[n+o+1],r),f(t[n+o+2],r)},stripsToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+1+o%2],r),f(t[n+o+1+(o+1)%2],r)}},x={anythingToPoints(e,t){return e},linesToWireframe(e,t){return e>1?2*(e-1):0},polysToWireframe(e,t){return e>2?2*e:0},stripsToWireframe(e,t){return e>2?4*e-6:0},polysToSurface(e,t){return e>2?3*(e-2):0},stripsToSurface(e,t,n){return e>2?3*(e-2):0}};let C=null,S=null;o===qi.POINTS||"verts"===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===qi.WIREFRAME||"lines"===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let O=null;const P=new Float32Array(w*t.blockSize);u&&(O=new Uint8Array(4*w));let R=0,M=0;const{useShiftAndScale:E,coordShift:V,coordScale:D}=gu(a.points);if(E?e.setCoordShiftAndScale(V,D):!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null),i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e,n){if(i&&(i.points[L]=e,i.cells[L]=y+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(P[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],P[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],P[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(P[R++]=s[g++],P[R++]=s[g++],P[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(y+a.cellOffset):3*e,P[R++]=l[m++],P[R++]=l[m++],P[R++]=l[m++]),t.customData.forEach((t=>{T=e*t.components;for(let e=0;e<t.components;++e)P[R++]=t.data[T++]})),null!==c){h=a.useTCoordsPerCell?n*p:e*p;for(let e=0;e<p;++e)P[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(y+a.cellOffset)*d:e*d,O[M++]=u[v++],O[M++]=u[v++],O[M++]=u[v++],O[M++]=4===d?u[v++]:255)};for(let e=0;e<I;e+=A[e]+1,y++)C(A[e],A,e+1,y+a.cellOffset);return t.elementCount=w,e.upload(P,lu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(O,lu.ARRAY_BUFFER)),y},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Rn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Rn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Pn(e,[0,0,0])&&Pn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Cn(n,t);const r=new Float64Array(16);return F(r,Na(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):mu("Wrong type for coordScale, expected vec3 or null"):mu("Wrong type for coordShift, expected vec3 or null")}}(e,t)}var Tu={newInstance:Ht.newInstance(vu),extend:vu};const{vtkErrorMacro:yu}=Ht,bu={shaderType:"Unknown",source:"",error:"",handle:0,dirty:!1,context:null};function xu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bu,n),Ht.obj(e,t),Ht.setGet(e,t,["shaderType","source","error","handle","context"]),function(e,t){t.classHierarchy.push("vtkShader"),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||"Unknown"===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e="Fragment"===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return yu(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}(e,t)}var Cu={newInstance:Ht.newInstance(xu,"vtkShader"),extend:xu};const{vtkErrorMacro:Su}=Ht,Au={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:"",handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function Iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Au,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=Cu.newInstance(),t.vertexShader.setShaderType("Vertex"),t.fragmentShader=Cu.newInstance(),t.fragmentShader.setShaderType("Fragment"),t.geometryShader=Cu.newInstance(),t.geometryShader.setShaderType("Geometry"),Ht.obj(e,t),Ht.get(e,t,["lastCameraMTime"]),Ht.setGet(e,t,["error","handle","compiled","bound","md5Hash","vertexShader","fragmentShader","geometryShader","linked"]),function(e,t){t.classHierarchy.push("vtkShaderProgram"),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(Su(`Links failed: ${t.error}`),0):(Su(t.error),0):(Su(t.fragmentShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),Su(t.fragmentShader.getError()),0):(Su(t.vertexShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),Su(t.vertexShader.getError()),0),e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error="Program has not been initialized, and/or does not have shaders.",!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return Su(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(Su("attempt to find uniform when the shader program is not linked"),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return Su("attempt to find uniform when the shader program is not linked"),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error="Shader object was not initialized, cannot attach it.",!1;if("Unknown"===n.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error="Could not create shader program.",!1;t.handle=e,t.linked=!1}return"Vertex"===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),"Fragment"===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error="shader object was not initialized, cannot attach it.",!1;if("Unknown"===e.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;switch(0===t.handle&&(t.error="This shader program has not been initialized yet."),e.getShaderType()){case"Vertex":return t.vertexShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case"Fragment":return t.fragmentShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}(e,t)}var wu={newInstance:Ht.newInstance(Iu,"vtkShaderProgram"),extend:Iu,substitute:function(e,t,n,r){const o="string"==typeof n?n:n.join("\n"),a=!1===r?t:new RegExp(t,"g"),i=e.replace(a,o);return{replace:i!==o,result:i}}};const Ou={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function Pu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ou,n),t.buffers=[],Ht.obj(e,t),Ht.get(e,t,["supported"]),Ht.setGet(e,t,["forceEmulation"]),function(e,t){t.classHierarchy.push("vtkOpenGLVertexArrayObject"),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension("ANGLE_instanced_arrays")),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension("OES_vertex_array_object"),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==lu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}(e,t)}var Ru={newInstance:Ht.newInstance(Pu,"vtkOpenGLVertexArrayObject"),extend:Pu};const Mu={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6},Eu={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function Vu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Eu,n),Ht.obj(e,t),t.shaderSourceTime={},Ht.obj(t.shaderSourceTime),t.attributeUpdateTime={},Ht.obj(t.attributeUpdateTime),Ht.setGet(e,t,["program","shaderSourceTime","VAO","attributeUpdateTime","CABO","primitiveType","pointPicking"]),t.program=wu.newInstance(),t.VAO=Ru.newInstance(),t.CABO=Tu.newInstance(),function(e,t){t.classHierarchy.push("vtkOpenGLHelper"),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===qi.POINTS||n===Mu.Points?t.context.POINTS:e===qi.WIREFRAME||n===Mu.Lines||n===Mu.TrisEdges||n===Mu.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f("viewportSize",o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf("lineWidthStepSize",t/Math.ceil(t)),e.getProgram().setUniformf("halfLineWidth",n)}t.primitiveType===Mu.Points||r.getProperty().getRepresentation()===qi.POINTS?e.getProgram().setUniformf("pointSize",r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf("pointSize",e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=wu.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform float pointSize;"]).result,a=wu.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl","  gl_PointSize = pointSize;"],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=wu.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform vec2 viewportSize;","uniform float lineWidthStepSize;","uniform float halfLineWidth;"]).result,a=wu.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl"," if (halfLineWidth > 0.0)","   {","   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;","   vec4 tmpPos = gl_Position;","   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;","   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];","   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];","   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);","   }"]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===Mu.Points?2:t.primitiveType===Mu.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}(e,t)}var Du={newInstance:Ht.newInstance(Vu),extend:Vu,primTypes:Mu};const Lu={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},Bu={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var Nu={Wrap:Lu,Filter:Bu};const Fu=new Float32Array(1),_u=new Int32Array(Fu.buffer);var ku={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Fu[0]=e;const t=_u[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};let Gu;const{Wrap:Uu,Filter:zu}=Nu,{VtkDataTypes:Wu}=Ts,{vtkDebugMacro:Hu,vtkErrorMacro:ju,vtkWarningMacro:Ku,requiredParam:$u}=jt,{toHalf:qu}=ku;function Xu(e,t){function n(){return{internalFormat:t.internalFormat,format:t.format,openGLDataType:t.openGLDataType,width:t.width,height:t.height}}t.classHierarchy.push("vtkOpenGLTexture"),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow")),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(zu.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(zu.LINEAR),e.setMagnificationFilter(zu.LINEAR)):(e.setMinificationFilter(zu.NEAREST),e.setMagnificationFilter(zu.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Uu.REPEAT),e.setWrapS(Uu.REPEAT),e.setWrapT(Uu.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImageBitmap()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(zu.LINEAR_MIPMAP_LINEAR)),t.renderable.getImageBitmap()&&t.renderable.getImageLoaded()&&(e.create2DFromImageBitmap(t.renderable.getImageBitmap()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(zu.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(zu.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw({width:n.width,height:n.height,numComps:4,dataType:Wu.UNSIGNED_CHAR,data:n,flip:!0}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(zu.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw({width:n.width,height:n.height,numComps:4,dataType:Wu.UNSIGNED_CHAR,data:n.data,flip:!0}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(zu.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:a}):e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()};const r=()=>{if(t.minificationFilter!==zu.LINEAR&&t.magnificationFilter!==zu.LINEAR||(void 0===Gu&&(Gu=function(){try{const e=4,t=2,n=1,r=new Int16Array([0,32767]),o=[1,1],a=document.createElement("canvas");a.width=e,a.height=e;const i=a.getContext("webgl2");if(!i)return!1;const s=i.getExtension("EXT_texture_norm16");if(!s)return!1;const l=`#version 300 es\n    void main() {\n      gl_PointSize = ${e.toFixed(1)};\n      gl_Position = vec4(0, 0, 0, 1);\n    }\n  `,c="#version 300 es\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n\n    uniform sampler2D u_image;\n\n    out vec4 color;\n\n    void main() {\n        vec4 intColor = texture(u_image, gl_PointCoord.xy);\n        color = vec4(vec3(intColor.rrr), 1);\n    }\n    ",u=i.createShader(i.VERTEX_SHADER);if(i.shaderSource(u,l),i.compileShader(u),!i.getShaderParameter(u,i.COMPILE_STATUS))return!1;const d=i.createShader(i.FRAGMENT_SHADER);if(i.shaderSource(d,c),i.compileShader(d),!i.getShaderParameter(d,i.COMPILE_STATUS))return!1;const p=i.createProgram();if(i.attachShader(p,u),i.attachShader(p,d),i.linkProgram(p),!i.getProgramParameter(p,i.LINK_STATUS))return!1;const f=i.createTexture();i.bindTexture(i.TEXTURE_2D,f),i.texImage2D(i.TEXTURE_2D,0,s.R16_SNORM_EXT,t,n,0,i.RED,i.SHORT,r),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.LINEAR),i.useProgram(p),i.drawArrays(i.POINTS,0,1);const g=new Uint8Array(4);i.readPixels(o[0],o[1],1,1,i.RGBA,i.UNSIGNED_BYTE,g);const[m,h,v]=g,T=i.getExtension("WEBGL_lose_context");return T&&T.loseContext(),m===h&&h===v&&0!==m}catch(e){return!1}}()),Gu))return t.oglNorm16Ext};function o(e){const[t,n,r,o,a,i]=e;return[n-t+1,o-r+1,i-a+1]}function a(e){const[t,n,r]=o(e);return t*n*r}function i(e,n){const r=new((arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)||e.constructor)(n.reduce(((e,t)=>e+a(t)),0)),o=[t.width,t.height,t.depth];let i=0;return n.forEach((t=>{!function(e,t,n,r,o){const[a,i,s,l,c,u]=n,[d,p]=t,f=d*p;let g=o;for(let t=c;t<=u;t++){const n=t*f;for(let t=s;t<=l;t++){const o=n+t*d;for(let t=o+a,n=o+i;t<=n;t++,g++)r[g]=e[t]}}}(e,o,t,r,i),i+=a(t)})),r}function s(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Ro(r)||!Ro(o))){const i=t.context.getExtension("OES_texture_half_float"),s=Po(r),l=Po(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?ku.toHalf(ku.fromHalf(e[u][l+s+t])*h*(1-v)+ku.fromHalf(e[u][l+p+t])*h*v+ku.fromHalf(e[u][c+s+t])*m*(1-v)+ku.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function l(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&r())||e!==Wu.UNSIGNED_SHORT&&e!==Wu.SHORT)))}function c(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);const i=function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a;let s=!1;if(t._openGLRenderWindow.getWebgl2())s=t.openGLDataType===t.context.FLOAT&&null===t.context.getExtension("OES_texture_float_linear")&&i||t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");s=e&&t.openGLDataType===e.HALF_FLOAT_OES}t.canUseHalfFloat=s&&i}(a,c.offset,c.scale,r),e.useHalfFloat()||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t._prevTexParams=null,t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t._prevTexParams=null,t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:Ku("impossible case"),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Hu(`Unable to find suitable internal format for T=${n} NC= ${r}`),[t.context.R32F,t.context.RG32F,t.context.RGB32F,t.context.RGBA32F].includes(t.internalFormat)&&!t.context.getExtension("OES_texture_float_linear")&&Ku("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats."),t.internalFormat),e.getDefaultInternalFormat=(n,o)=>{let a=0;return a=t._openGLRenderWindow.getDefaultTextureInternalFormat(n,o,r(),e.useHalfFloat()),a||(a||(Hu("Unsupported internal texture type!"),Hu(`Unable to find suitable internal format for T=${n} NC= ${o}`)),a)},e.useHalfFloat=()=>t.enableUseHalfFloat&&t.canUseHalfFloat,e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t._prevTexParams=null,t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=n=>{const o=e.useHalfFloat();if(t._openGLRenderWindow.getWebgl2())switch(n){case Wu.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case r()&&!o&&Wu.SHORT:return t.context.SHORT;case r()&&!o&&Wu.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case o&&Wu.SHORT:case o&&Wu.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case Wu.FLOAT:case Wu.VOID:default:return t.context.FLOAT}switch(n){case Wu.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case Wu.FLOAT:case Wu.VOID:default:if(t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))return t.context.FLOAT;{const e=t.context.getExtension("OES_texture_half_float");if(e&&t.context.getExtension("OES_texture_half_float_linear"))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case zu.NEAREST:return t.context.NEAREST;case zu.LINEAR:return t.context.LINEAR;case zu.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case zu.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case zu.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case zu.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Uu.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Uu.REPEAT:return t.context.REPEAT;case Uu.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.updateArrayDataTypeForGL=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];const a=[];let s=t.width*t.height*t.components;r&&(s*=t.depth);const l=!!o.length;if(e!==Wu.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e])if(l)a.push(i(n[e],o,Float32Array));else{const t=n[e].length>s?n[e].subarray(0,s):n[e];a.push(new Float32Array(t))}else a.push(null);if(e!==Wu.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e])if(l)a.push(i(n[e],o,Uint8Array));else{const t=n[e].length>s?n[e].subarray(0,s):n[e];a.push(new Uint8Array(t))}else a.push(null);let c=!1;if(t._openGLRenderWindow.getWebgl2())c=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");c=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(c)for(let e=0;e<n.length;e++)if(n[e]){const t=l?i(n[e],o):n[e],r=new Uint16Array(l?t.length:s),c=r.length;for(let e=0;e<c;e++)r[e]=qu(t[e]);a.push(r)}else a.push(null);if(0===a.length)for(let e=0;e<n.length;e++)a.push(l&&n[e]?i(n[e],o):n[e]);return a},e.create2DFromRaw=function(){let{width:n=$u("width"),height:o=$u("height"),numComps:a=$u("numComps"),dataType:i=$u("dataType"),data:c=$u("data"),flip:u=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(e.getOpenGLDataType(i,!0),e.getInternalFormat(i,a),e.getFormat(i,a),!t.internalFormat||!t.format||!t.openGLDataType)return ju("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=a,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=s(e.updateArrayDataTypeForGL(i,d));return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(i)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=p[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,p[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,p[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*a*t._openGLRenderWindow.getDefaultTextureByteSize(i,r(),e.useHalfFloat()),e.deactivate(),!0},e.createCubeFromRaw=function(){let{width:n=$u("width"),height:o=$u("height"),numComps:a=$u("numComps"),dataType:i=$u("dataType"),data:c=$u("data")}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(e.getOpenGLDataType(i),e.getInternalFormat(i,a),e.getFormat(i,a),!t.internalFormat||!t.format||!t.openGLDataType)return ju("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=a,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=s(e.updateArrayDataTypeForGL(i,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=it(i,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(i)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,o=t.height;for(;r>=1&&o>=1;){let a=null;n<=t.maxLevel&&(a=d[6*n+e]),l(i)?null!=a&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,o,t.format,t.openGLDataType,a):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,o,0,t.format,t.openGLDataType,a),n++,r/=2,o/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*a*t._openGLRenderWindow.getDefaultTextureByteSize(i,r(),e.useHalfFloat()),e.deactivate(),!0},e.createDepthFromRaw=function(){let{width:n=$u("width"),height:o=$u("height"),dataType:a=$u("dataType"),data:i=$u("data")}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.getOpenGLDataType(a),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?a===Wu.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(a)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=i&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,i)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,i),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(a,r(),e.useHalfFloat()),e.deactivate(),!0):(ju("Failed to determine texture parameters."),!1)},e.create2DFromImage=n=>{if(e.getOpenGLDataType(Wu.UNSIGNED_CHAR),e.getInternalFormat(Wu.UNSIGNED_CHAR,4),e.getFormat(Wu.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return ju("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const o=!(t._openGLRenderWindow.getWebgl2()||Ro(n.width)&&Ro(n.height));let a=n,i=n.width,s=n.height,c=!0;const u=window.chrome;if(o||u){const e=new OffscreenCanvas(Po(n.width),Po(n.height));i=e.width,s=e.height;const t=e.getContext("2d");t.translate(0,e.height),t.scale(1,-1),t.drawImage(n,0,0,n.width,n.height,0,0,e.width,e.height),a=e,c=!1}return t.width=i,t.height=s,t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,c),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(Wu.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,a)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,a),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(Wu.UNSIGNED_CHAR,r(),e.useHalfFloat()),e.deactivate(),!0},e.create2DFromImageBitmap=n=>(e.getOpenGLDataType(Wu.UNSIGNED_CHAR),e.getInternalFormat(Wu.UNSIGNED_CHAR,4),e.getFormat(Wu.UNSIGNED_CHAR,4),t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),t.width=n.width,t.height=n.height,l(Wu.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,n)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,n),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(Wu.UNSIGNED_CHAR,r(),e.useHalfFloat()),e.deactivate(),!0):(ju("Failed to determine texture parameters."),!1)),e.create2DFilterableFromRaw=function(){let{width:t=$u("width"),height:n=$u("height"),numComps:r=$u("numComps"),dataType:o=$u("dataType"),data:a=$u("data"),preferSizeOverAccuracy:i=!1,ranges:s}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.create2DFilterableFromDataArray({width:t,height:n,dataArray:Ts.newInstance({numComps:r,dataType:o,values:a,ranges:s}),preferSizeOverAccuracy:i})},e.create2DFilterableFromDataArray=function(){let{width:t=$u("width"),height:n=$u("height"),dataArray:r=$u("dataArray"),preferSizeOverAccuracy:o=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{numComps:a,dataType:i,data:s}=c(r,o);e.create2DFromRaw({width:t,height:n,numComps:a,dataType:i,data:s})},e.updateVolumeInfoForGL=(n,o)=>{let a=!1;const i=e.useHalfFloat();t.volumeInfo?.scale&&t.volumeInfo?.offset||(t.volumeInfo={scale:new Array(o),offset:new Array(o)});for(let e=0;e<o;++e)t.volumeInfo.scale[e]=1,t.volumeInfo.offset[e]=0;if(r()&&!i&&n===Wu.SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=32767;a=!0}if(r()&&!i&&n===Wu.UNSIGNED_SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=65535;a=!0}if(n===Wu.UNSIGNED_CHAR){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=255;a=!0}return(n===Wu.FLOAT||i&&(n===Wu.SHORT||n===Wu.UNSIGNED_SHORT))&&(a=!0),a},e.create3DFromRaw=function(){let{width:i=$u("width"),height:c=$u("height"),depth:u=$u("depth"),numComps:d=$u("numComps"),dataType:p=$u("dataType"),data:f=$u("data"),updatedExtents:g=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},m=p,h=f;if(!e.updateVolumeInfoForGL(m,d)&&h){const e=i*c*u,n=structuredClone(t.volumeInfo),r=new Float32Array(e*d);t.volumeInfo.offset=n.offset,t.volumeInfo.scale=n.scale;let o=0;const a=n.scale.map((e=>1/e));for(let t=0;t<e;t++)for(let e=0;e<d;e++)r[o]=(h[o]-n.offset[e])*a[e],o++;m=Wu.FLOAT,h=r}if(e.getOpenGLDataType(m),e.getInternalFormat(m,d),e.getFormat(m,d),!t.internalFormat||!t.format||!t.openGLDataType)return ju("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_3D,t.components=d,t.width=i,t.height=c,t.depth=u,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const v=g.length>0,T=!v||!ke()(t._prevTexParams,n()),y=[h],b=s(e.updateArrayDataTypeForGL(m,y,!0,T?[]:g));if(t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),T)l(m)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=b[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,b[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,b[0]),t._prevTexParams=n();else if(v){const e=b[0];let n=0;for(let r=0;r<g.length;r++){const i=g[r],s=o(i),l=a(i),c=new e.constructor(e.buffer,n,l);n+=c.byteLength,t.context.texSubImage3D(t.target,0,i[0],i[2],i[4],s[0],s[1],s[2],t.format,t.openGLDataType,c)}}return t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(m,r(),e.useHalfFloat()),e.deactivate(),!0},e.create3DFilterableFromRaw=function(){let{width:t=$u("width"),height:n=$u("height"),depth:r=$u("depth"),numComps:o=$u("numComps"),dataType:a=$u("dataType"),data:i=$u("data"),preferSizeOverAccuracy:s=!1,ranges:l,updatedExtents:c=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.create3DFilterableFromDataArray({width:t,height:n,depth:r,dataArray:Ts.newInstance({numComps:o,dataType:a,values:i,ranges:l}),preferSizeOverAccuracy:s,updatedExtents:c})},e.create3DFilterableFromDataArray=function(){let{width:n=$u("width"),height:r=$u("height"),depth:o=$u("depth"),dataArray:a=$u("dataArray"),preferSizeOverAccuracy:i=!1,updatedExtents:s=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{numComps:u,dataType:d,data:p,scaleOffsets:f}=c(a,i),g=[],m=[];for(let e=0;e<u;++e)g[e]=0,m[e]=1;if(t.volumeInfo={scale:m,offset:g,dataComputedScale:f.scale,dataComputedOffset:f.offset,width:n,height:r,depth:o},t._openGLRenderWindow.getWebgl2())return e.create3DFromRaw({width:n,height:r,depth:o,numComps:u,dataType:d,data:p,updatedExtents:s});const h=n*r*o,v=structuredClone(f);let T=(e,t,n,r,o)=>{e[t]=n},y=Wu.UNSIGNED_CHAR;if(d===Wu.UNSIGNED_CHAR)for(let e=0;e<u;++e)v.offset[e]=0,v.scale[e]=255;else t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear")?(y=Wu.FLOAT,T=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=Wu.UNSIGNED_CHAR,T=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,u),e.getFormat(y,u),!t.internalFormat||!t.format||!t.openGLDataType)return ju("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=u,t.depth=1,t.numberOfDimensions=2;let b=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);b>4096&&(y===Wu.FLOAT||u>=3)&&(b=4096);let x=1,C=1;h>b*b&&(x=Math.ceil(Math.sqrt(h/(b*b))),C=x);let S=Math.sqrt(h)/x;S=Po(S);const A=Math.floor(S*x/n),I=Math.ceil(o/A),w=Po(r*I/C);let O;t.width=S,t.height=w,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=A,t.volumeInfo.yreps=I,t.volumeInfo.xstride=x,t.volumeInfo.ystride=C,t.volumeInfo.offset=v.offset,t.volumeInfo.scale=v.scale;const P=S*w*u;O=y===Wu.FLOAT?new Float32Array(P):new Uint8Array(P);let R=0;const M=Math.floor(n/x),E=Math.floor(r/C);for(let e=0;e<I;e++){const a=Math.min(A,o-e*A),i=u*(t.width-a*Math.floor(n/x));for(let t=0;t<E;t++){for(let o=0;o<a;o++){const a=u*((e*A+o)*n*r+C*t*n);for(let e=0;e<M;e++)for(let t=0;t<u;t++)T(O,R,p[a+x*e*u+t],v.offset[t],v.scale[t]),R++}R+=i}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=O&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,O)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,O),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1,e.enableUseHalfFloat=e=>{t.enableUseHalfFloat=e}}const Yu={_openGLRenderWindow:null,_forceInternalFormat:!1,_prevTexParams:null,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Uu.CLAMP_TO_EDGE,wrapT:Uu.CLAMP_TO_EDGE,wrapR:Uu.CLAMP_TO_EDGE,minificationFilter:zu.NEAREST,magnificationFilter:zu.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0,enableUseHalfFloat:!0,canUseHalfFloat:!1};function Zu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yu,n),Xt.extend(e,t,n),t.sendParametersTime={},vt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},vt(t.textureBuildTime,{mtime:0}),Ct(e,t,["format","openGLDataType"]),St(e,t,["keyMatrixTime","minificationFilter","magnificationFilter","wrapS","wrapT","wrapR","generateMipmap","oglNorm16Ext"]),yt(e,t,["width","height","volumeInfo","components","handle","target","allocatedGPUMemoryInBytes"]),Ot(0,t,["openGLRenderWindow"]),Xu(e,t)}const Qu=Et(Zu,"vtkOpenGLTexture");var Ju={newInstance:Qu,extend:Zu,...Nu};en("vtkTexture",Qu);var ed="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n",td="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",nd=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=wu.substitute(e,"//VTK::Coincident::Dec",["uniform float cfactor;","uniform float coffset;"]).result,t.context.getExtension("EXT_frag_depth")&&(0!==a.factor?(e=wu.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=wu.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=wu.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=wu.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=wu.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=wu.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result),n.Fragment=e}}},rd=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=wu.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&""!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&""!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:od}=_s,{primTypes:ad}=Du,{Representation:id,Shading:sd}=ts,{ScalarMode:ld}=Fl,{Filter:cd,Wrap:ud}=Ju,{vtkErrorMacro:dd}=jt,pd={type:"StartEvent"},fd={type:"EndEvent"},{CoordinateSystem:gd}=Wi;const md={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:xl.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function hd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,md,n),Xt.extend(e,t,n),nd(e,t,n),rd(e,t,n),t.primitives=[],t.primTypes=ad,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=ad.Start;e<ad.End;e++)t.primitives[e]=Du.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);St(e,t,["context"]),t.VBOBuildTime={},vt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},vt(t.selectionStateChanged,{mtime:0}),function(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push("vtkOpenGLPolyDataMapper"),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType("vtkOpenGLActor"),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=ad.Start;e<ad.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=ed,e.Fragment=td,e.Geometry=""},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName("lastLightComplexity");let l=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity","uniform vec3 ambientColorUniform;","uniform vec3 diffuseColorUniform;"];s&&(l=l.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let c=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];s&&(c=c.concat(["  vec3 specularColor;","  float specularPower;"])),c=c.concat(["  ambientColor = ambientColorUniform;","  diffuseColor = diffuseColorUniform;","  opacity = opacityUniform;"]),s&&(c=c.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat(["varying vec4 vertexColorVSOutput;"]),o=wu.substitute(o,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,o=wu.substitute(o,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,a=wu.substitute(a,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,a=wu.substitute(a,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?(t.renderable.getAreScalarsMappedFromCells()||t.renderable.getInterpolateScalarsBeforeMapping())&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=wu.substitute(i,"//VTK::Color::Impl",c.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  ambientColor = texColor.rgb;","  opacity = opacity*texColor.a;"])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat(["uniform float opacityUniformBF; // the fragment opacity","uniform float ambientIntensityBF; // the material ambient","uniform float diffuseIntensityBF; // the material diffuse","uniform vec3 ambientColorUniformBF; // ambient material color","uniform vec3 diffuseColorUniformBF; // diffuse material color"]),s?(l=l.concat(["uniform float specularIntensityBF; // the material specular intensity","uniform vec3 specularColorUniformBF; // intensity weighted color","uniform float specularPowerUniformBF;"]),c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  specularColor = specularIntensityBF * specularColorUniformBF;","  specularPower = specularPowerUniformBF;","  opacity = opacityUniformBF; }"])):c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  opacity = opacityUniformBF; }"])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat(["uniform samplerBuffer texture1;"])),i=wu.substitute(i,"//VTK::Color::Impl",c).result):i=wu.substitute(i,"//VTK::Color::Impl",c.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result,i=wu.substitute(i,"//VTK::Color::Dec",l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity"),i=t.lastBoundBO.getReferenceByName("lastLightCount");let s=[];switch(a){case 0:o=wu.substitute(o,"//VTK::Light::Impl",["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);","  //VTK::Light::Impl"],!1).result;break;case 1:o=wu.substitute(o,"//VTK::Light::Impl",["  float df = max(0.0, normalVCVSOutput.z);","  float sf = pow(df, specularPower);","  vec3 diffuseL = df * diffuseColor;","  vec3 specularL = sf * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=wu.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  float df;"];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,"    {",`    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=wu.substitute(o,"//VTK::Light::Impl",s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=wu.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  vec3 vertLightDirectionVC;","  float attenuation;","  float df;"];for(let e=0;e<i;++e)s=s.concat(["  attenuation = 1.0;",`  if (lightPositional${e} == 0)`,"    {",`      vertLightDirectionVC = lightDirectionVC${e};`,"    }","  else","    {",`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,"    float distanceVC = length(vertLightDirectionVC);","    vertLightDirectionVC = normalize(vertLightDirectionVC);","    attenuation = 1.0 /",`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,"    // per OpenGL standard cone angle is 90 or less for a spot light",`    if (lightConeAngle${e} <= 90.0)`,"      {",`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,"      // if inside the cone",`      if (coneDot >= cos(radians(lightConeAngle${e})))`,"        {",`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,"        }","      else","        {","        attenuation = 0.0;","        }","      }","    }","    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));",`    diffuseL += ((df) * lightColor${e});`,"    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)","      {",`      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${e},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=wu.substitute(o,"//VTK::Light::Impl",s,!1).result;break;default:dd("bad light complexity")}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=wu.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=wu.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * normalMC;"]).result,o=wu.substitute(o,"//VTK::Normal::Dec",["in vec3 normalVCVSOutput[];","out vec3 normalVCGSOutput;"]).result,o=wu.substitute(o,"//VTK::Normal::Impl",["normalVCGSOutput = normalVCVSOutput[i];"]).result,a=wu.substitute(a,"//VTK::Normal::Dec",["varying vec3 normalVCVSOutput;"]).result,a=wu.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalVCVSOutput);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.haveCellNormals?(a=wu.substitute(a,"//VTK::Normal::Dec",["uniform mat3 normalMatrix;","uniform samplerBuffer textureN;"]).result,a=wu.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalMatrix *","    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=wu.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=wu.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput;","  if (abs(fdx.x) > 0.0)","    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }","  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result):(a=wu.substitute(a,"//VTK::Normal::Dec",["uniform int cameraParallel;"]).result,a=wu.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=wu.substitute(a,"//VTK::Normal::Impl",["  fdx = normalize(fdx);","  fdy = normalize(fdy);","  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));","  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }","  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(o=wu.substitute(o,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,o=wu.substitute(o,"//VTK::PositionVC::Impl",["vertexVCVSOutput = MCVCMatrix * vertexMC;","  gl_Position = MCPCMatrix * vertexMC;"]).result,o=wu.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result,a=wu.substitute(a,"//VTK::PositionVC::Dec",["in vec4 vertexVCVSOutput[];","out vec4 vertexVCGSOutput;"]).result,a=wu.substitute(a,"//VTK::PositionVC::Impl",["vertexVCGSOutput = vertexVCVSOutput[i];"]).result,i=wu.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=wu.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;"]).result):(o=wu.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,o=wu.substitute(o,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=wu.substitute(n,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=wu.substitute(n,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result,r=wu.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];","out vec2 tcoordVCGSOutput;"]).result,r=wu.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=wu.substitute(o,"//VTK::TCoord::Dec",["varying vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,a&&a.length>=1)switch(i){case 1:o=wu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=wu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=wu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}}else switch(n=wu.substitute(n,"//VTK::TCoord::Dec","attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result,r=wu.substitute(r,"//VTK::TCoord::Dec",["in vec3 tcoordVCVSOutput[];","out vec3 tcoordVCGSOutput;"]).result,r=wu.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=wu.substitute(o,"//VTK::TCoord::Dec",["varying vec3 tcoordVCVSOutput;","uniform samplerCube texture1;"]).result,i){case 1:o=wu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=wu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=wu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=wu.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=wu.substitute(o,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=wu.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`varying float clipDistancesVSOutput[${e}];`]).result,a=wu.substitute(a,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()==dl.PolygonOffset||o.getEdgeVisibility()&&o.getRepresentation()===id.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===ad.Points||o.getRepresentation()===id.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===ad.Lines||o.getRepresentation()===id.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==ad.Tris&&e!==ad.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==ad.TrisEdges&&e!==ad.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===od.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=wu.substitute(o,"//VTK::Picking::Dec",["uniform int picking;","//VTK::Picking::Dec"]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==xl.ID_LOW24&&t.lastSelectionState!==xl.ID_HIGH24||(a=wu.substitute(a,"//VTK::Picking::Dec",["flat out int vertexIDVSOutput;\n","uniform int VertexIDOffset;\n"]).result,a=wu.substitute(a,"//VTK::Picking::Impl","  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n").result,o=wu.substitute(o,"//VTK::Picking::Dec","flat in int vertexIDVSOutput;\n").result,o=wu.substitute(o,"//VTK::Picking::Impl",["  int idx = vertexIDVSOutput;","//VTK::Picking::Impl"]).result),t.lastSelectionState){case xl.ID_LOW24:o=wu.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;break;case xl.ID_HIGH24:o=wu.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;break;default:o=wu.substitute(o,"//VTK::Picking::Dec","uniform vec3 mapperIndex;").result,o=wu.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=wu.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=wu.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===sd.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName("lastLightComplexity"),h=t.lastBoundBO.getReferenceByName("lastLightCount");return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed("PrimitiveIDOffset")&&n.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),n.getProgram().isUniformUsed("VertexIDOffset")&&n.getProgram().setUniformi("VertexIDOffset",t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName("lastLightComplexity");n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||dd("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("normalMC")&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"normalMC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||dd("Error setting normalMC in shader VAO."):n.getVAO().removeAttributeArray("normalMC"),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||dd(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||dd("Error setting tcoordMC in shader VAO."):n.getVAO().removeAttributeArray("tcoordMC"),n.getProgram().isAttributeUsed("scalarColor")&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),"scalarColor",n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||dd("Error setting scalarColor in shader VAO."):n.getVAO().removeAttributeArray("scalarColor"),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),y(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",r)}t.internalColorTexture&&n.getProgram().isUniformUsed("texture1")&&n.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray("mapperIndex",i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi("picking",i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],ko(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],ko(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);wn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===gd.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,y(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix("MCPCMatrix",t.tmpMat4)}else s.setUniformMatrix("MCPCMatrix",n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed("MCVCMatrix")&&s.setUniformMatrix("MCVCMatrix",n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed("normalMatrix")&&s.setUniformMatrix3x3("normalMatrix",n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf("opacityUniform",i),o.setUniform3fArray("ambientColorUniform",s),o.setUniform3fArray("diffuseColorUniform",l),o.setUniformf("ambient",c),o.setUniformf("diffuse",u);const f=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray("specularColorUniform",g),o.setUniformf("specularPowerUniform",p),o.setUniformf("specular",d),o.isUniformUsed("ambientIntensityBF")){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf("ambientIntensityBF",c),o.setUniformf("diffuseIntensityBF",u),o.setUniformf("opacityUniformBF",i),o.setUniform3fArray("ambientColorUniformBF",s),o.setUniform3fArray("diffuseColorUniformBF",l),f<1)return;o.setUniformf("specularIntensityBF",d),o.setUniform3fArray("specularColorUniformBF",g),o.setUniformf("specularPowerUniformBF",p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===od.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():xl.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===id.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===od.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===xl.ID_LOW24||t.lastSelectionState===xl.ID_HIGH24);for(let i=ad.Start;i<ad.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===ad.TrisEdges||i===ad.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(pd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(fd),!t.currentInput)return void dd("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n),e.updateMaximumPointCellIds()},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==ld.USE_CELL_DATA&&a!==ld.USE_CELL_FIELD_DATA&&a!==ld.USE_FIELD_DATA&&r.getPointData().getScalars()||a===ld.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));let i=n.getProperty().getInterpolation()!==sd.FLAT?r.getPointData().getNormals():null;null===i&&r.getCellData().getNormals()&&(t.haveCellNormals=!0,i=r.getCellData().getNormals());const s=n.getProperty().getRepresentation();let l=r.getPointData().getTCoords();t.openGLActor.getActiveTextures()||(l=null);let c=!1;if(t.renderable.getColorCoordinates()){l=t.renderable.getColorCoordinates(),c=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=Ju.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(cd.NEAREST),e.setMagnificationFilter(cd.NEAREST),e.setWrapS(ud.CLAMP_TO_EDGE),e.setWrapT(ud.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),e.deactivate()}const u=`${r.getMTime()}A${s}B${r.getMTime()}C${i?i.getMTime():1}D${o?o.getMTime():1}E${n.getProperty().getEdgeVisibility()}F${l?l.getMTime():1}`;if(t.VBOBuildString!==u){const e={points:r.getPoints(),normals:i,tcoords:l,colors:o,cellOffset:0,vertexOffset:0,useTCoordsPerCell:c,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const a=[{inRep:"verts",cells:r.getVerts()},{inRep:"lines",cells:r.getLines()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()}],d=n.getProperty().getEdgeVisibility()&&s===id.SURFACE;for(let n=ad.Start;n<ad.End;n++)n!==ad.TrisEdges&&n!==ad.TriStripsEdges?(e.cellOffset+=t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,s,e,t.selectionWebGLIdsToVTKIds),e.vertexOffset+=t.primitives[n].getCABO().getElementCount()):d?t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,id.WIREFRAME,{...e,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[n].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),t.VBOBuildString=u}t.VBOBuildTime.modified()},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}(e,t)}const vd=Et(hd,"vtkOpenGLPolyDataMapper");var Td={newInstance:vd,extend:hd};en("vtkMapper",vd);const{ColorMode:yd,ScalarMode:bd,GetArray:xd}=Xs,Cd={static:!1,lookupTable:null,scalarVisibility:!1,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,transformCoordinate:null,viewSpecificProperties:null,customShaderAttributes:[]};function Sd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cd,n),bs(e,t,n),Ht.get(e,t,["colorMapColors"]),Ht.setGet(e,t,["arrayAccessMode","colorByArrayName","colorMode","lookupTable","renderTime","scalarMode","scalarVisibility","static","transformCoordinate","useLookupTableScalarRange","viewSpecificProperties","customShaderAttributes"]),Ht.setGetArray(e,t,["scalarRange"],2),t.viewSpecificProperties||(t.viewSpecificProperties={}),function(e,t){t.classHierarchy.push("vtkMapper2D"),e.createDefaultLookupTable=()=>{t.lookupTable=ul.newInstance()},e.getColorModeAsString=()=>Ht.enumToString(yd,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>Ht.enumToString(bd,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===bd.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===bd.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===bd.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===bd.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===xd.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===bd.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===xd.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===bd.USE_FIELD_DATA){const t=e.getFieldData();i=r===xd.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString===a)return;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]);const i=e.getLookupTable();i&&(i.build(),t.colorMapColors=i.mapScalars(o,t.colorMode,t.fieldDataTupleId)),t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}}}(e,t)}var Ad={newInstance:Ht.newInstance(Sd,"vtkMapper2D"),extend:Sd};const Id=1,{primTypes:wd}=Du,{ScalarMode:Od}=Ad,{vtkErrorMacro:Pd}=jt,Rd={type:"StartEvent"},Md={type:"EndEvent"},Ed={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const Vd=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ed,n),Xt.extend(e,t,n),nd(e,t,n),rd(e,t,n),t.primitives=[],t.primTypes=wd,t.tmpMat4=g(new Float64Array(16));for(let e=wd.Start;e<wd.End;e++)t.primitives[e]=Du.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);St(e,t,["context"]),t.VBOBuildTime={},vt(t.VBOBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkOpenGLPolyDataMapper2D"),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType("vtkOpenGLActor2D"),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n",e.Geometry=""},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=wd.Start;e<wd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{e.invokeEvent(Rd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Md),t.currentInput?t.currentInput.getPoints&&t.currentInput.getPoints().getNumberOfValues()&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Pd("No input!")},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==Od.USE_CELL_DATA&&a!==Od.USE_CELL_FIELD_DATA&&a!==Od.USE_FIELD_DATA&&r.getPointData().getScalars()||a===Od.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));const i=n.getProperty().getRepresentation();let s=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(s=null);const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${i}B${r.getMTime()}C${o?o.getMTime():1}D${s?s.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=$l.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const a={points:n,tcoords:s,colors:o,cellOffset:0,haveCellScalars:t.haveCellSCalars,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};a.cellOffset+=t.primitives[wd.Points].getCABO().createVBO(r.getVerts(),"verts",i,a),a.cellOffset+=t.primitives[wd.Lines].getCABO().createVBO(r.getLines(),"lines",i,a),a.cellOffset+=t.primitives[wd.Tris].getCABO().createVBO(r.getPolys(),"polys",i,a),a.cellOffset+=t.primitives[wd.TriStrips].getCABO().createVBO(r.getStrips(),"strips",i,a),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=wd.Start;a<wd.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.haveCellScalars&&(i=wu.substitute(i,"//VTK::Color::Dec",["uniform samplerBuffer texture1;"]).result,i=wu.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);"]).result),0!==t.lastBoundBO.getCABO().getColorComponents()?(o=wu.substitute(o,"//VTK::Color::Dec",["in vec4 diffuseColor;","out vec4 fcolorVSOutput;"]).result,o=wu.substitute(o,"//VTK::Color::Impl",["fcolorVSOutput = diffuseColor;"]).result,a=wu.substitute(a,"//VTK::Color::Dec",["in vec4 fcolorVSOutput[];\n","out vec4 fcolorGSOutput;"]).result,a=wu.substitute(a,"//VTK::Color::Impl",["fcolorGSOutput = fcolorVSOutput[i];"]).result,i=wu.substitute(i,"//VTK::Color::Dec",["in vec4 fcolorVSOutput;"]).result,i=wu.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = fcolorVSOutput;"]).result):(i=wu.substitute(i,"//VTK::Color::Dec",["uniform vec4 diffuseColor;"]).result,i=wu.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = diffuseColor;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=wu.substitute(n,"//VTK::TCoord::Dec",["in float tcoordMC;","out float tcoordVCVSOutput;"]).result,n=wu.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=wu.substitute(r,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput[];\n","out float tcoordVCGSOutput;"]).result,r=wu.substitute(r,["//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=wu.substitute(o,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=wu.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result):2===a&&(n=wu.substitute(n,"//VTK::TCoord::Dec",["in vec2 tcoordMC;","out vec2 tcoordVCVSOutput;"]).result,n=wu.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=wu.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];\n","out vec2 tcoordVCGSOutput;"]).result,r=wu.substitute(r,"//VTK::TCoord::Impl",["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=wu.substitute(o,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=wu.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result),t.haveCellScalars&&(r=wu.substitute(r,"//VTK::PrimID::Impl",["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=wu.substitute(r,"//VTK::Picking::Dec",["uniform vec3 mapperIndex;","uniform int picking;"]).result,r=wu.substitute(r,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed("PrimitiveIDOffset")&&e.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),e.getProgram().isAttributeUsed("vertexWC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"vertexWC",e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||Pd("Error setting vertexWC in shader VAO.")),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||Pd(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed("tcoordMC")&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"tcoordMC",e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||Pd("Error setting tcoordMC in shader VAO."):e.getVAO().removeAttributeArray("tcoordMC"),t.internalColorTexture&&e.getProgram().isUniformUsed("texture1")&&e.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray("mapperIndex",a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi("picking",a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity(),a=n.getColor(),i=[a[0],a[1],a[2],o];t.setUniform4f("diffuseColor",i)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=xo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=xo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=xo(c[0]-(d[0]-l[0])*p[0]),h=xo(c[1]-(d[1]-l[1])*p[1]),v=-f;let T=-f+s[0];const y=-h;let b=-h+s[1];v===T&&(T=v+1),y===b&&(b=y+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(T-v),x[5]=2/(b-y),x[3]=-1*(T+v)/(T-v),x[7]=-1*(b+y)/(b-y),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===Id?-1:1,x[15]=1,m(x,x),a.setUniformMatrix("WCVCMatrix",(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}(e,t)}),"vtkOpenGLPolyDataMapper2D");en("vtkMapper2D",Vd);const{VectorMode:Dd}=il;function Ld(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Bd(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Nd(e,t){return e=>{const t=e.getLastTickBounds(),n=oo().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}const Fd=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),Ht.obj(e,t),Ht.setGet(e,t,["axisTitlePixelOffset","tickLabelPixelOffset","renderable","topTitle","ticks","tickStrings","tickPositions"]),Ht.get(e,t,["lastSize","lastAspectRatio","lastTickBounds","axisTextStyle","tickTextStyle","barActor","tmActor"]),Ht.getArray(e,t,["boxPosition","boxSize"]),Ht.setArray(e,t,["boxPosition","boxSize"],2),t.forceUpdate=!1,t.lastRebuildTime={},Ht.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.barMapper=Fl.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=kc.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=os.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=kc.newInstance(),t.tmMapper=Fl.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=zc.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=os.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],function(e,t){t.classHierarchy.push("vtkScalarBarActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left";const n={},r=new Map;let o=0,a=1;Ld(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,Ld(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),"NaN","Below","Above"];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=Po(o),a=Po(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{Ld(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s("NaN",[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s("Below",[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s("ticks",t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s("Above",[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p="vertical"===a?[1,0]:[0,1];"vertical"===a?(d[0]=l.width,d[1]=-l.height,"middle"===o[0]?n[1]-=l.width/2:"right"===o[0]&&(n[1]-=l.width),"middle"===o[1]?n[0]+=l.height/2:"top"===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,"middle"===o[0]?n[0]-=l.width/2:"right"===o[0]&&(n[0]-=l.width),"middle"===o[1]?n[1]-=l.height/2:"top"===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?["right","middle"]:["middle","bottom"];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","top"],"vertical",[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];"ticks"===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,"horizontal",g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),T=e.getTicks(),y=e.getTickStrings(),b=e.getTickPositions();for(let n=0;n<T.length;n++){const o=b?b[n]:(T[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(y[n],r,p,"horizontal",g,c)}const x=Ts.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(x),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Dd.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Ts.newInstance({numberOfComponents:i,values:c,name:"Scalars"});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}(e,t)}),"vtkScalarBarActorHelper");function _d(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,function(e){return{automated:!0,autoLayout:null,axisLabel:"Scalar Value",barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif"},tickLabelPixelOffset:14,tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif"},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}(n)),t.autoLayout||(t.autoLayout=Bd(0,t)),t.generateTicks||(t.generateTicks=Nd()),os.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),Ht.setGet(e,t,["automated","autoLayout","axisTitlePixelOffset","axisLabel","scalarsToColors","tickLabelPixelOffset","generateTicks","drawNanAnnotation","drawBelowRangeSwatch","drawAboveRangeSwatch"]),Ht.get(e,t,["axisTextStyle","tickTextStyle"]),Ht.getArray(e,t,["barPosition","barSize","boxPosition","boxSize"]),Ht.setArray(e,t,["barPosition","barSize","boxPosition","boxSize"],2),function(e,t){t.classHierarchy.push("vtkScalarBarActor"),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(Bd(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Nd())}}(e,t)}var kd={newInstance:Ht.newInstance(_d,"vtkScalarBarActor"),extend:_d,newScalarBarActorHelper:Fd};const Gd={};const Ud=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gd,n),Xt.extend(e,t,n),t.scalarBarActorHelper=kd.newScalarBarActorHelper(),function(e,t){t.classHierarchy.push("vtkOpenGLScalarBarActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}(e,t)}),"vtkOpenGLScalarBarActor");en("vtkScalarBarActor",Ud);const{vtkErrorMacro:zd}=jt,Wd={context:null};const Hd=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wd,n),Xt.extend(e,t,n),t.openGLTexture=Ju.newInstance(),t.tris=Du.newInstance(),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},St(e,t,["context"]),yt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLSkybox"),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi("sbtexture",n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix("IMCPCMatrix",a),"box"===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f("camPos",e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Ts.newInstance({numberOfComponents:3,values:e});n.setName("points");const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Ts.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,"polys",qi.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),"box"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec3 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = wpos.xyz/wpos.w;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec3 TexCoords;\n             uniform samplerCube sbtexture;\n             uniform vec3 camPos;\n             void main () {\n               // skybox looks from inside out\n               // which means we have to adjust\n               // our tcoords. Otherwise text would\n               // be flipped\n               vec3 tc = normalize(TexCoords - camPos);\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\n               {\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\n               }\n               else\n               {\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\n               }\n               gl_FragData[0] = textureCube(sbtexture, tc);\n             }","")),"background"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec2 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec2 TexCoords;\n             uniform sampler2D sbtexture;\n             void main () {\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\n             }","")),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),"vertexMC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||zd("Error setting vertexMC in shader VAO."));const e=t.renderable.getTextures();e.length||zd("vtkSkybox requires a texture map"),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}(e,t)}));en("vtkSkybox",Hd);const{FieldAssociations:jd}=_s,Kd={fieldAssociation:jd.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function $d(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kd,n),Ht.obj(e,t),Ht.setGet(e,t,["fieldAssociation","captureZValues"]),function(e,t){t.classHierarchy.push("vtkHardwareSelector"),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}(e,t)}var qd={newInstance:Ht.newInstance($d,"vtkHardwareSelector"),extend:$d};const Xd={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function Yd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xd,n),vt(e,t),t.colorBuffers&&tt("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead."),t.colorBuffers=[],At(e,t,["colorBuffers"]),function(e,t){t.classHierarchy.push("vtkFramebuffer"),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void tt("you must set the OpenGLRenderWindow before calling saveCurrentBindings");const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void tt("you must set the OpenGLRenderWindow before calling restorePreviousBindings");const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;null===n&&(n=t.context.FRAMEBUFFER),t.context.bindFramebuffer(n,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):tt("you must set the OpenGLRenderWindow before calling create")},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void tt("you must set the OpenGLRenderWindow before calling setColorBuffer");let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void tt("Using multiple framebuffer attachments requires WebGL 2");o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void tt("you must set the OpenGLRenderWindow before calling removeColorBuffer");let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void tt("Using multiple framebuffer attachments requires WebGL 2");r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else tt("Attaching depth buffer textures to fbo requires WebGL 2");else tt("you must set the OpenGLRenderWindow before calling setDepthBuffer")},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else tt("Attaching depth buffer textures to framebuffers requires WebGL 2");else tt("you must set the OpenGLRenderWindow before calling removeDepthBuffer")},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>null==t.glFramebuffer?null:[t.glFramebuffer.width,t.glFramebuffer.height],e.populateFramebuffer=()=>{if(!t.context)return void tt("you must set the OpenGLRenderWindow before calling populateFrameBuffer");e.bind();const n=t.context,r=Ju.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(Bu.LINEAR),r.setMagnificationFilter(Bu.LINEAR),r.create2DFromRaw({width:t.glFramebuffer.width,height:t.glFramebuffer.height,numComps:4,dataType:is.UNSIGNED_CHAR,data:null}),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}(e,t)}var Zd={newInstance:Et(Yd,"vtkFramebuffer"),extend:Yd};const Qd={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function Jd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qd,n),Ht.obj(e,t),t.properties={},Ht.setGet(e,t,["contentType","fieldType","properties","selectionList"]),function(e,t){t.classHierarchy.push("vtkSelectionNode"),e.getBounds=()=>t.points.getBounds()}(e,t)}var ep={newInstance:Ht.newInstance(Jd,"vtkSelectionNode"),extend:Jd,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:tp}=Cl,{SelectionContent:np,SelectionField:rp}=ep,{FieldAssociations:op}=_s,{vtkErrorMacro:ap}=Ht;function ip(e){return`${e.propID} ${e.compositeID}`}function sp(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function lp(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function cp(e,t){let n=t;return n<<=24,n|=e,n}function up(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=lp(n[0],n[1],e.pixBuffer[tp.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=lp(n[0],n[1],e.pixBuffer[tp.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[tp.ID_LOW24]&&0===sp(n[0],n[1],e.pixBuffer[tp.ID_LOW24],e.area))return a;const s=lp(n[0],n[1],e.pixBuffer[tp.ID_LOW24],e.area),l=lp(n[0],n[1],e.pixBuffer[tp.ID_HIGH24],e.area);return a.attributeID=cp(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=up(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=up(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=up(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=up(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=up(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function dp(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=ep.newInstance();switch(l.setContentType(np.INDICES),e){case op.FIELD_ASSOCIATION_CELLS:l.setFieldType(rp.CELL);break;case op.FIELD_ASSOCIATION_POINTS:l.setFieldType(rp.POINT);break;default:ap("Unknown field association")}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}const pp={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function fp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pp,n),qd.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),Ht.setGetArray(e,t,["area"],4),Ht.setGet(e,t,["_renderer","currentPass","_openGLRenderWindow","maximumPointId","maximumCellId"]),Ht.setGetArray(e,t,["propColorValue"],3),Ht.moveToProtected(e,t,["renderer","openGLRenderWindow"]),Ht.event(e,t,"event"),function(e,t){t.classHierarchy.push("vtkOpenGLHardwareSelector"),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e&&e[0]===n[0]&&e[1]===n[1]?t.framebuffer.bind():(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer())}else t.framebuffer=Zd.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===op.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=up(e,[n,t],0,u);if(r&&r.valid){const t=ip(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return dp(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return ap("Renderer and view must be set before calling Select."),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:"StartEvent"}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();e.beginSelection();const r=[];for(t.currentPass=tp.MIN_KNOWN_PASS;t.currentPass<=tp.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===tp.ACTOR_PASS&&"function"==typeof n[0].requestDepth&&"function"==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),r.push(t.currentPass));return r.forEach((n=>{t.currentPass=n,e.processPixelBuffers()})),t.currentPass=tp.MAX_KNOWN_PASS,e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:"EndEvent"}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===tp.ID_HIGH24){if(t.fieldAssociation===op.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===op.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===tp.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if("function"==typeof e[0].requestDepth&&"function"==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=lp(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===tp.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===tp.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>Ht.enumToString(tp,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=lp(e[0],e[1],t.pixBuffer[tp.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=lp(e[0],e[1],t.pixBuffer[tp.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[tp.ID_LOW24]&&0===sp(e[0],e[1],t.pixBuffer[tp.ID_LOW24],t.area))return a;const s=lp(e[0],e[1],t.pixBuffer[tp.ID_LOW24],t.area),l=lp(e[0],e[1],t.pixBuffer[tp.ID_HIGH24],t.area);return a.attributeID=cp(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=ip(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return dp(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}(e,t)}var gp={newInstance:Ht.newInstance(fp,"vtkOpenGLHardwareSelector"),extend:fp,...Cl};const{vtkErrorMacro:mp}=jt,{Representation:hp}=ts,{ObjectType:vp}=fu,{PassTypes:Tp}=gp,yp={type:"StartEvent"},bp={type:"EndEvent"},xp={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const Cp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xp,n),Td.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},vt(t.glyphBOBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkOpenGLGlyph3DMapper");const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(yp),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(bp),!t.currentInput)return void mp("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension("ANGLE_instanced_arrays"),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],T=t[14],y=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*T,e[3]=b*s+x*d+C*m+S*y,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*T,e[7]=b*s+x*d+C*m+S*y,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*T,e[11]=b*s+x*d+C*m+S*y,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*T,e[15]=b*s+x*d+C*m+S*y},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=wu.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","attribute mat3 gNormal;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=wu.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * gNormal * normalMC;"]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity"];a&&(i=i.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let s=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];a&&(s=s.concat(["  vec3 specularColor;","  float specularPower;"])),s=s.concat(["  opacity = opacityUniform;"]),a&&(s=s.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),t.drawingEdges||(i=i.concat(["varying vec4 vertexColorVSOutput;"]),n=wu.substitute(n,"//VTK::Color::Dec",["attribute vec4 gColor;","varying vec4 vertexColorVSOutput;"]).result,n=wu.substitute(n,"//VTK::Color::Impl",["vertexColorVSOutput = gColor;"]).result,r=wu.substitute(r,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,r=wu.substitute(r,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,s=s.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])),o=wu.substitute(o,"//VTK::Color::Impl",s).result,o=wu.substitute(o,"//VTK::Color::Dec",i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(n=wu.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","vertexVCVSOutput = MCVCMatrix * gVertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result,n=wu.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result):(n=wu.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;"]).result,n=wu.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=wu.substitute(n,"//VTK::Picking::Dec",["attribute vec3 mapperIndexVS;","varying vec3 mapperIndexVSOutput;"]).result,n=wu.substitute(n,"//VTK::Picking::Impl","  mapperIndexVSOutput = mapperIndexVS;").result,e.Vertex=n,t=wu.substitute(t,"//VTK::Picking::Dec",["varying vec3 mapperIndexVSOutput;","uniform vec3 mapperIndex;","uniform int picking;"]).result,t=wu.substitute(t,"//VTK::Picking::Impl",["  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);","  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],T=n[r+1],y=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+T*d+y*g,o[1]=v*i+T*p+y*m,o[2]=v*c+T*f+y*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3("normalMatrix",t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix("MCPCMatrix",t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix("MCVCMatrix",t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray("ambientColorUniform",t.tmpColor),u.setUniform3fArray("diffuseColorUniform",t.tmpColor)}c&&u.setUniform3fArray("mapperIndex",c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===hp.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),y(t.mcpcMatrix,s.wcpc,l.mcwc),y(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===Tp.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed("normalMatrix"),v=g.isUniformUsed("MCVCMatrix");if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed("gMatrix")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,"gMatrix",0,64,t.context.FLOAT,4,!1,1)||mp("Error setting gMatrix in shader VAO."):e.getVAO().removeAttributeArray("gMatrix"),e.getProgram().isAttributeUsed("gNormal")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,"gNormal",0,36,t.context.FLOAT,3,!1,1)||mp("Error setting gNormal in shader VAO."):e.getVAO().removeAttributeArray("gNormal"),e.getProgram().isAttributeUsed("gColor")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,"gColor",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||mp("Error setting gColor in shader VAO."):e.getVAO().removeAttributeArray("gColor"),e.getProgram().isAttributeUsed("mapperIndexVS")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,"mapperIndexVS",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||mp("Error setting mapperIndexVS in shader VAO."):e.getVAO().removeAttributeArray("mapperIndexVS"),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=fu.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=fu.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=fu.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=fu.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,vp.ARRAY_BUFFER),t.normalBuffer.upload(n,vp.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),vp.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,vp.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}(e,t)}),"vtkOpenGLGlyph3DMapper");en("vtkGlyph3DMapper",Cp);const{vtkErrorMacro:Sp}=Ht;class Ap{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}const Ip={};function wp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ip,n),Ht.obj(e,t),Ht.algo(e,t,1,1),function(e,t){t.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter"),e.requestData=(e,t)=>{const n=e[0];if(!n)return void Sp("Invalid or missing input");const r=kc.newInstance();r.shallowCopy(n);const o=new Ap,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(zl.newInstance({values:c,name:"faces"})),t[0]=r}}(e,t)}var Op={newInstance:Ht.newInstance(wp,"vtkClosedPolyLineToSurfaceFilter"),extend:wp};const{vtkErrorMacro:Pp}=jt;function Rp(e,t){t.classHierarchy.push("vtkCutter");const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void Pp("Invalid or missing input");if(!t.cutFunction)return void Pp("Missing cut function");const o=kc.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=r.getNumberOfPoints(),i=[],s=[],l=[];(!t.cutScalars||t.cutScalars.length<a)&&(t.cutScalars=new Float32Array(a));let c=0,u=0;for(;c<o.length;)t.cutScalars[u++]=t.cutFunction.evaluateFunction(o[c++],o[c++],o[c++]);const d=[],p=new Array(3),f=new Array(3),g=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error("Iterator is done");r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)g[e]=t.cutScalars[n.cell[e++]];const e=g[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(g[t]>0!==e){r=!1;break}if(r)continue;const a=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,i=g[e]>0;if(g[r]>0===i)continue;let s=e,l=r,c=g[l]-g[s];c<=0&&(s=r,l=e,c*=-1);let u=0;0!==c&&(u=(t.cutValue-g[s])/c);const d=n.cell[s],m=n.cell[l];p[0]=o[3*d],p[1]=o[3*d+1],p[2]=o[3*d+2],f[0]=o[3*m],f[1]=o[3*m+1],f[2]=o[3*m+2];const h=[p[0]+u*(f[0]-p[0]),p[1]+u*(f[1]-p[1]),p[2]+u*(f[2]-p[2])];a.push({pointEdge1:d,pointEdge2:m,intersectedPoint:h,newPointID:-1})}for(let e=0;e<a.length;e++){const t=a[e];let n=!1;for(let r=0;r<d.length;r++){const o=d[r],i=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(i||s){n=!0,a[e].newPointID=d[r].newPointID;break}}n||(i.push(t.intersectedPoint[0]),i.push(t.intersectedPoint[1]),i.push(t.intersectedPoint[2]),a[e].newPointID=i.length/3-1,d.push(a[e]))}const c=a.length;2===c?s.push(c,a[0].newPointID,a[1].newPointID):c>2&&(l.push(c),a.forEach((e=>{l.push(e.newPointID)})))}n.getPoints().setData(st(r.getDataType(),i),3),0!==s.length&&n.getLines().setData(Uint16Array.from(s)),0!==l.length&&n.getPolys().setData(Uint16Array.from(l))})(r,o),n[0]=o}}const Mp={cutFunction:null,cutScalars:null,cutValue:0};function Ep(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mp,n),vt(e,t),Pt(e,t,1,1),St(e,t,["cutFunction","cutValue"]),Rp(e,t)}var Vp={newInstance:Et(Ep,"vtkCutter"),extend:Ep};const Dp=e=>e,Lp=1e-6;class Bp{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:Dp}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);vn(n,e[0],e[1],e[2]),vn(r,t[0],t[1],t[2]),Sn(n,n),Sn(r,r);const a=An(n,r);return a>=1||(In(this.tmp,n,r),mn(this.tmp)<Lp&&(In(this.tmp,[1,0,0],e),mn(this.tmp)<Lp&&In(this.tmp,[0,1,0],e)),P(o,Math.acos(a),this.tmp),y(this.matrix,this.matrix,o)),this}rotate(e,t){return vn(this.tmp,...t),Sn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return vn(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return vn(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return y(this.matrix,this.matrix,e),this}multiply3x3(e){return y(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(Yo(so,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)vn(this.tmp,e[n],e[n+1],e[n+2]),wn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var Np=function(){return new Bp(!0)},Fp=function(){return new Bp(!1)};const _p=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],kp=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22],Gp={xLength:1,yLength:1,zLength:1,pointType:"Float64Array",generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function Up(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gp,n),Ht.obj(e,t),Ht.setGet(e,t,["xLength","yLength","zLength","generate3DTextureCoordinates","generateFaces","generateLines"]),Ht.setGetArray(e,t,["center","rotations"],3),Ht.setGetArray(e,t,["matrix"],16),t._polys=zl.newInstance({values:Uint16Array.from(kp)}),t._lineCells=zl.newInstance({values:Uint16Array.from(_p)}),Ht.moveToProtected(e,t,["polys","lineCells"]),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkCubeSource"),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=kc.newInstance();n[0]=r;const o=Ht.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=Ht.newTypedArray(t.pointType,72),i=Ts.newInstance({name:"Normals",values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=Ht.newTypedArray(t.pointType,24*s),c=Ts.newInstance({name:"TextureCoordinates",values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&Np().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Fp().translate(...t.center).apply(o),t.matrix){Fp().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Fp().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}(e,t)}var zp={newInstance:Ht.newInstance(Up,"vtkCubeSource"),extend:Up};const{vtkErrorMacro:Wp}=Ht,Hp={};function jp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hp,n),Ht.obj(e,t),Ht.algo(e,t,1,1),t._cubeSource=zp.newInstance(),Ht.moveToProtected(e,t,["cubeSource","tmpOut"]),function(e,t){t.classHierarchy.push("vtkImageDataOutlineFilter");const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA("vtkImageData"))return void Wp("Invalid or missing input");const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):Wp("Unable to fetch spatial extents of input image.")},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}(e,t)}var Kp={newInstance:Ht.newInstance(jp,"vtkImageDataOutlineFilter"),extend:jp};let $p;const qp={preMultiplyFlag:!1,matrix:[...so]};function Xp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qp,n),Ht.obj(e,t),Ht.setGet(e,t,["preMultiplyFlag"]),Ht.setGetArray(e,t,["matrix"],16),function(e,t){t.classHierarchy.push("vtkAbstractTransform","vtkHomogeneousTransform","vtkTransform"),e.transformPoint=(e,n)=>(wn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],wn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?y(n,t.matrix,e):y(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>y(o,t.matrix,r):()=>y(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>$p({matrix:La.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag})}(e,t)}$p=Ht.newInstance(Xp,"vtkTransform");var Yp={newInstance:$p,extend:Xp};function Zp(e,t,n){return e.length>0?`${e.map((e=>e?.getMTime()??"x")).join("/")}-${t}-${n}`:"0"}function Qp(e,t){return`${t.getMTime()}`}const Jp={NEAREST:0,LINEAR:1};var ef={InterpolationType:Jp};const{vtkErrorMacro:tf}=jt;function nf(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}const rf={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastNumberOfComponents:0,lastMultiTexturePerVolumeEnabled:!1,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,scalarTextures:[],_scalarTexturesCore:[],colorTexture:null,_colorTextureCore:null,pwfTexture:null,_pwfTextureCore:null,_externalOpenGLTexture:!1,resliceGeom:null,resliceGeomUpdateString:null,tris:null};const of=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rf,n),Xt.extend(e,t,n),nd(e,t,n),rd(e,t,n),t.tris=Du.newInstance(),t.scalarTextures=[],t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},vt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=Kp.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=kc.newInstance(),t.cutter=Vp.newInstance(),t.lineToSurfaceFilter=Op.newInstance(),t.transform=Yp.newInstance(),yt(e,t,["scalarTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLImageResliceMapper");const n=new Map;function o(t,r,o){r!==o&&(function(t,r){if(!r)return;const o=(n.get(r)??0)-1;o<=0?(t.unregisterGraphicsResourceUser(r,e),n.delete(r)):n.set(r,o)}(t,r),function(t,r){if(!r)return;const o=n.get(r)??0,a=o+1;n.set(r,a),o<=0&&t.registerGraphicsResourceUser(r,e)}(t,o))}function a(t){[...n.keys()].forEach((n=>t.unregisterGraphicsResourceUser(n,e)))}e.buildPass=n=>{if(n){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const n=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera());const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&a(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==dl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update();const o=t.renderable.getNumberOfInputPorts();t.currentValidInputs=[];for(let e=0;e<o;++e){const n=t.renderable.getInputData(e);n&&!n.isDeleted()&&t.currentValidInputs.push({imageData:n,inputIndex:e})}const a=t.currentValidInputs.length;if(a<=0)return void tf("No input!");const i=t.currentValidInputs[0].imageData.getPointData().getScalars();t.multiTexturePerVolumeEnabled=a>1,t.numberOfComponents=t.multiTexturePerVolumeEnabled?a:i.getNumberOfComponents(),e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:"EndEvent"})},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r);const o=r.getProperties();t.currentValidInputs.forEach((e=>{let{inputIndex:n}=e;const r=o[n].getInterpolationType(),a=t.scalarTextures[n];r===Jp.NEAREST?(a.setMinificationFilter(Bu.NEAREST),a.setMagnificationFilter(Bu.NEAREST)):(a.setMinificationFilter(Bu.LINEAR),a.setMagnificationFilter(Bu.LINEAR))}));const a=t.currentValidInputs[0];o[a.inputIndex].getInterpolationType()===Jp.NEAREST?(t.colorTexture.setMinificationFilter(Bu.NEAREST),t.colorTexture.setMagnificationFilter(Bu.NEAREST),t.pwfTexture.setMinificationFilter(Bu.NEAREST),t.pwfTexture.setMagnificationFilter(Bu.NEAREST)):(t.colorTexture.setMinificationFilter(Bu.LINEAR),t.colorTexture.setMagnificationFilter(Bu.LINEAR),t.pwfTexture.setMinificationFilter(Bu.LINEAR),t.pwfTexture.setMagnificationFilter(Bu.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context,a=[...t.scalarTextures,t.colorTexture,t.pwfTexture];a.forEach((e=>e.activate())),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),a.forEach((e=>e.deactivate()))},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty(t.currentValidInputs[0].inputIndex)?.getMTime()||t.currentValidInputs.some((e=>{let{imageData:n}=e;return t.VBOBuildTime.getMTime()<n.getMTime()}))||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime()||t.scalarTextures.length!==t.currentValidInputs.length||!t.scalarTextures.every((e=>!!e?.getHandle()))||!t.colorTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(e,n)=>{const r=n.getProperties();t.currentValidInputs.forEach(((e,n)=>{let{imageData:a}=e;const i=a.getPointData().getScalars(),s=t._openGLRenderWindow.getGraphicsResourceForObject(i),l=Qp(0,i),c=!s?.oglObject?.getHandle()||s?.hash!==l,u=r[n],d=u.getUpdatedExtents(),p=!!d.length;if(c&&!p){const e=Ju.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);const r=a.getDimensions();e.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),e.resetFormatAndType(),e.create3DFilterableFromDataArray({width:r[0],height:r[1],depth:r[2],dataArray:i}),t._openGLRenderWindow.setGraphicsResourceForObject(i,e,l),t.scalarTextures[n]=e}else t.scalarTextures[n]=s.oglObject;if(p){u.setUpdatedExtents([]);const e=a.getDimensions();t.scalarTextures[n].create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:i,updatedExtents:d})}o(t._openGLRenderWindow,t._scalarTexturesCore[n],i),t._scalarTexturesCore[n]=i}));const a=t.currentValidInputs[0],i=r[a.inputIndex],s=i.getIndependentComponents(),l=s?t.numberOfComponents:1,c=s?2*l:1,u=[];for(let e=0;e<l;++e)u.push(i.getRGBTransferFunction(e));const d=Zp(u,s,l),p=i.getRGBTransferFunction(),f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.oglObject?.getHandle()&&f?.hash===d)t.colorTexture=f.oglObject;else{let e=t.renderable.getColorTextureWidth();e<=0&&(e=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const n=new Uint8ClampedArray(e*c*3),r=Ju.newInstance();if(r.setOpenGLRenderWindow(t._openGLRenderWindow),p){const t=new Float32Array(3*e);for(let r=0;r<l;r++){const o=i.getRGBTransferFunction(r),a=o.getRange();if(o.getTable(a[0],a[1],e,t,1),s)for(let o=0;o<3*e;o++)n[r*e*6+o]=255*t[o],n[r*e*6+o+3*e]=255*t[o];else for(let o=0;o<3*e;o++)n[r*e*3+o]=255*t[o]}r.resetFormatAndType(),r.create2DFromRaw({width:e,height:c,numComps:3,dataType:is.UNSIGNED_CHAR,data:n})}else{for(let t=0;t<3*e;++t){const r=255*t/(3*(e-1));for(let o=0;o<c;++o)n[o*e*3+t+0]=r,n[o*e*3+t+1]=r,n[o*e*3+t+2]=r}r.resetFormatAndType(),r.create2DFromRaw({width:e,height:1,numComps:3,dataType:is.UNSIGNED_CHAR,data:n})}p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,r,d),t.colorTexture=r}o(t._openGLRenderWindow,t._colorTextureCore,p),t._colorTextureCore=p;const g=[];for(let e=0;e<l;++e)g.push(i.getPiecewiseFunction(e));const m=Zp(g,s,l),h=i.getPiecewiseFunction(),v=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(v?.oglObject?.getHandle()&&v?.hash===m)t.pwfTexture=v.oglObject;else{let e=t.renderable.getOpacityTextureWidth();e<=0&&(e=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const n=e*c,r=new Uint8ClampedArray(n),o=Ju.newInstance();if(o.setOpenGLRenderWindow(t._openGLRenderWindow),h){const t=new Float32Array(n),r=new Float32Array(e);for(let n=0;n<l;++n){const o=i.getPiecewiseFunction(n);if(null===o)t.fill(1);else{const a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),s)for(let o=0;o<e;o++)t[n*e*2+o]=r[o],t[n*e*2+o+e]=r[o];else for(let n=0;n<e;n++)t[n]=r[n]}}o.resetFormatAndType(),o.create2DFromRaw({width:e,height:c,numComps:1,dataType:is.FLOAT,data:t})}else r.fill(255),o.resetFormatAndType(),o.create2DFromRaw({width:e,height:c,numComps:1,dataType:is.UNSIGNED_CHAR,data:r});h&&t._openGLRenderWindow.setGraphicsResourceForObject(h,o,m),t.pwfTexture=o}o(t._openGLRenderWindow,t._pwfTextureCore,h),t._pwfTextureCore=h;const T=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==T){const e=Ts.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName("points");const n=Ts.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:tf("Slab mode requested without normals")}t.tris.getCABO().createVBO(n,"polys",qi.SURFACE,r)}t.VBOBuildString=T,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.currentValidInputs[0].imageData;if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){t.scalarTextures.forEach(((e,t)=>{a.setUniformi(`volumeTexture[${t}]`,e.getTextureUnit())})),a.isAttributeUsed("vertexWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexWC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tf("Error setting vertexWC in shader VAO.")),a.isAttributeUsed("normalWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"normalWC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tf("Error setting normalWC in shader VAO.")),a.isUniformUsed("slabThickness")&&a.setUniformf("slabThickness",t.renderable.getSlabThickness()),a.isUniformUsed("spacing")&&a.setUniform3fv("spacing",i.getSpacing()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabTrapezoid")&&a.setUniformi("slabTrapezoid",t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed("WCTCMatrix")){const n=i.getDimensions();d(t.tmpMat4,i.getIndexToWorld()),b(t.tmpMat4,t.tmpMat4,[-.5,-.5,-.5]),x(t.tmpMat4,t.tmpMat4,n),h(t.tmpMat4,t.tmpMat4),e&&y(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix("WCTCMatrix",t.tmpMat4)}a.isUniformUsed("vboScaling")&&a.setUniform3fv("vboScaling",n.getCABO().getCoordScale()??[1,1,1]),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed("MCPCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCPCMatrix",nf([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed("MCVCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCVCMatrix",nf([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(t.currentValidInputs[0].inputIndex),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.numberOfComponents,l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));for(let e=0;e<s;e++){const n=t.multiTexturePerVolumeEnabled,r=n?e:0,i=n?0:e,s=t.scalarTextures[r].getVolumeInfo(),c=s.scale[i],u=s.offset[i],d=l?e:0;let p=a.getColorWindow(),f=a.getColorLevel();const g=a.getRGBTransferFunction(d);if(g&&a.getUseLookupTableScalarRange()){const e=g.getRange();p=e[1]-e[0],f=.5*(e[1]+e[0])}const m=c/p,h=(u-f)/p+.5;o.setUniformf(`cshift${e}`,h),o.setUniformf(`cscale${e}`,m);let v=1,T=0;const y=a.getPiecewiseFunction(d);if(y){const e=y.getRange(),t=e[1]-e[0];v=c/t,T=(u-.5*(e[0]+e[1]))/t+.5}o.setUniformf(`pwfshift${e}`,T),o.setUniformf(`pwfscale${e}`,v)}const c=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",u),o.setUniform4fv("backgroundColor",t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=r.getProperty(t.currentValidInputs[0].inputIndex).getIndependentComponents(),a=t.renderable.getSlabThickness(),i=t.renderable.getSlabType(),s=t.renderable.getSlabTrapezoidIntegration();let l=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(l=!0),!(!l&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&t.lastNumberOfComponents===t.numberOfComponents&&t.lastMultiTexturePerVolumeEnabled===t.multiTexturePerVolumeEnabled&&0!==e.getProgram()?.getHandle()&&t.lastIndependentComponents===o&&t.lastSlabThickness===a&&t.lastSlabType===i&&t.lastSlabTrapezoidIntegration===s||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastNumberOfComponents=t.numberOfComponents,t.lastMultiTexturePerVolumeEnabled=t.multiTexturePerVolumeEnabled,t.lastIndependentComponents=o,t.lastSlabThickness=a,t.lastSlabType=i,t.lastSlabTrapezoidIntegration=s,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model coordinates\n// WC - World coordinates\n// VC - View coordinates\n// DC - Display coordinates\n// TC - Texture coordinates\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvoid main()\n{\n  //VTK::PositionVC::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Picking::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the gpu image mapper fragment shader\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=wu.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=wu.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=wu.substitute(o,"//VTK::TCoord::Dec",["uniform mat4 WCTCMatrix;","out vec3 fragTexCoord;"]).result,o=wu.substitute(o,"//VTK::TCoord::Impl",["fragTexCoord = (WCTCMatrix * vertexWC).xyz;"]).result;const l=t.numberOfComponents,c=r.getProperty(t.currentValidInputs[0].inputIndex).getIndependentComponents();let u=["in vec3 fragTexCoord;",`uniform highp sampler3D volumeTexture[${t.scalarTextures.length}];`,"uniform mat4 WCTCMatrix;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;"];if(u.push("vec4 rawSampleTexture(vec3 pos) {"),t.multiTexturePerVolumeEnabled){u.push("vec4 rawSample;");for(let e=0;e<t.scalarTextures.length;++e)u.push(`rawSample[${e}] = texture(volumeTexture[${e}], pos)[0];`);u.push("return rawSample;","}")}else u.push("return texture(volumeTexture[0], pos);","}");if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:u=u.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:tf("Unsupported number of independent coordinates.")}}s>0&&(u=u.concat(["uniform vec3 spacing;","uniform float slabThickness;","uniform int slabType;","uniform int slabTrapezoid;","uniform vec3 vboScaling;"]),u=u.concat(["vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)","{","  vec4 retVal = vec4(1.0);","  if (slabType == 0) // min","  {","    retVal = min(currVal, valToComp);","  }","  else if (slabType == 1) // max","  {","    retVal = max(currVal, valToComp);","  }","  else if (slabType == 3) // sum","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  else // mean","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  return retVal;","}"])),i=wu.substitute(i,"//VTK::TCoord::Dec",u).result;let d=["if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}","vec4 tvalue = rawSampleTexture(fragTexCoord);"];if(s>0&&(d=d.concat(["// Get the first and last samples","int numSlices = 1;","float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;","vec3 normalxspacing = scaling * normalWCVSOutput;","float distTraveled = length(normalxspacing);","int trapezoid = 0;","while (distTraveled < slabThickness * 0.5)","{","  distTraveled += length(normalxspacing);","  float fnumSlices = float(numSlices);","  if (distTraveled > slabThickness * 0.5)","  {","    // Before stepping outside the slab, sample at the boundaries","    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;","    trapezoid = slabTrapezoid;","  }","  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = rawSampleTexture(fragTCoordNeg);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = rawSampleTexture(fragTCoordPos);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","}","// Finally, if slab type is *mean*, divide the sum by the numSlices","if (slabType == 2)","{","  tvalue = tvalue / float(numSlices);","}"])),c){const e=["r","g","b","a"];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:d=d.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:tf("Unsupported number of independent coordinates.")}}else switch(l){case 1:d=d.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:d=d.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=wu.substitute(i,"//VTK::TCoord::Impl",d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=["attribute vec4 vertexWC;"];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat(["attribute vec3 normalWC;","varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),a=wu.substitute(a,"//VTK::PositionVC::Dec",c).result;let u=["gl_Position = MCPCMatrix * vertexWC;"];l>0&&(u=u.concat(["normalWCVSOutput = normalWC;","vertexWCVSOutput = vertexWC;"])),a=wu.substitute(a,"//VTK::PositionVC::Impl",u).result,a=wu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result;let d=[];l>0&&(d=d.concat(["varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),s=wu.substitute(s,"//VTK::PositionVC::Dec",d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e="";const n=t.currentValidInputs[0].imageData,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`);const t=ie();n&&(e=e.concat(`Image${n.getMTime()}`),de(t,...n.getDirection()),ge(t,t));const r=[...s.getNormal()];On(r,r,t),[o,a]=function(e){La.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=La.dot(e,t);if(o<-.999999||o>.999999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ti.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=kc.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getSpatialExtent();let l=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[l+a]=r[a],e[l+o[0]]=i[2*o[0]+n],e[l+o[1]]=i[2*o[1]+t],l+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const c=new Uint16Array(8);c[0]=3,c[1]=0,c[2]=1,c[3]=3,c[4]=3,c[5]=0,c[6]=3,c[7]=2;const u=s.getNormal();La.normalize(u);const d=new Float32Array(12);for(let e=0;e<4;++e)d[3*e]=u[0],d[3*e+1]=u[1],d[3*e+2]=u[2];t.resliceGeom||(t.resliceGeom=kc.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(c,1);const p=Ts.newInstance({numberOfComponents:3,values:d,name:"Normals"});t.resliceGeom.getPointData().setNormals(p)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=kc.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();La.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Ts.newInstance({numberOfComponents:3,values:a,name:"Normals"});t.resliceGeom.getPointData().setNormals(i)}else tf("Something went wrong.","A default slice plane should have been created in the beginning of","updateResliceGeometry.");t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setScalarTextures=e=>{t.scalarTextures=[...e],t._externalOpenGLTexture=!0},e.delete=Vt((()=>{t._openGLRenderWindow&&a(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageResliceMapper");en("vtkImageResliceMapper",of);var af={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:sf}=jt,{SlicingMode:lf}=af;function cf(e){const t=e.split("\n"),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}const uf={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0};const df=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uf,n),Xt.extend(e,t,n),nd(e,t,n),rd(e,t,n),t.tris=Du.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),St(e,t,[]),t.VBOBuildTime={},vt(t.VBOBuildTime),function(e,t){function n(n){t.openGLTexture.releaseGraphicsResources(n),[t._colorTransferFunc,t._pwFunc,t._labelOutlineThicknessArray].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),t.renderable.isA("vtkImageMapper")&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(o.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==dl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=ed,e.Fragment=td,e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=wu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=wu.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result,a=wu.substitute(a,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result,a=wu.substitute(a,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=["varying vec2 tcoordVCVSOutput;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D texture1;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform sampler2D labelOutlineTexture1;","uniform float opacity;","uniform float outlineOpacity;"];if(l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:c=c.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:sf("Unsupported number of independent coordinates.")}}if(i=wu.substitute(i,"//VTK::TCoord::Dec",c).result,!0===o.getProperty().getUseLabelOutline()&&(i=wu.substitute(i,"//VTK::LabelOutline::Dec",["uniform int outlineThickness;","uniform float vpWidth;","uniform float vpHeight;","uniform float vpOffsetX;","uniform float vpOffsetY;","uniform mat4 PCWCMatrix;","uniform mat4 vWCtoIDX;","uniform ivec3 imageDimensions;","uniform int sliceAxis;"]).result,i=wu.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result,i=wu.substitute(i,"//VTK::LabelOutlineHelperFunction",["#ifdef vtkImageLabelOutlineOn","vec3 fragCoordToIndexSpace(vec4 fragCoord) {","  vec4 pcPos = vec4(","    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,","    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,","    (fragCoord.z - 0.5) * 2.0,","    1.0);","","  vec4 worldCoord = PCWCMatrix * pcPos;","  vec4 vertex = (worldCoord/worldCoord.w);","","  vec3 index = (vWCtoIDX * vertex).xyz;","","  // half voxel fix for labelmapOutline","  return (index + vec3(0.5)) / vec3(imageDimensions);","}","vec2 getSliceCoords(vec3 coord, int axis) {","  if (axis == 0) return coord.yz;","  if (axis == 1) return coord.xz;","  if (axis == 2) return coord.xy;","}","#endif"]).result),l){const e=["r","g","b","a"];let t=["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);break;case 2:t=t.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:sf("Unsupported number of independent coordinates.")}i=wu.substitute(i,"//VTK::TCoord::Impl",t).result}else switch(s){case 1:i=wu.substitute(i,"//VTK::TCoord::Impl",[...cf("\n                #ifdef vtkImageLabelOutlineOn\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);\n                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;\n                  bool pixelOnBorder = false;\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\n                  float opacityToUse = scalarOpacity * opacity;\n                  int segmentIndex = int(centerValue * 255.0);\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\n                  int actualThickness = int(textureValue * 255.0);\n\n                  if (segmentIndex == 0){\n                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);\n                    return;\n                  }\n\n                  for (int i = -actualThickness; i <= actualThickness; i++) {\n                    for (int j = -actualThickness; j <= actualThickness; j++) {\n                      if (i == 0 || j == 0) {\n                        continue;\n                      }\n                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n                        gl_FragCoord.y + float(j),\n                        gl_FragCoord.z, gl_FragCoord.w);\n                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;\n                      if (value != centerValue) {\n                        pixelOnBorder = true;\n                        break;\n                      }\n                    }\n                    if (pixelOnBorder == true) {\n                      break;\n                    }\n                  }\n                  if (pixelOnBorder == true) {\n                    gl_FragData[0] = vec4(tColor, outlineOpacity);\n                  }\n                  else {\n                    gl_FragData[0] = vec4(tColor, opacityToUse);\n                  }\n                #else\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\n                #endif\n                ")]).result;break;case 2:i=wu.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","float intensity = tcolor.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;break;case 3:i=wu.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;break;default:i=wu.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result}t.haveSeenDepthRequest&&(i=wu.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=wu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(tt("OpenGL has a limit of 6 clipping planes"),e=6),o=wu.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=wu.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=wu.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=wu.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!(!i&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,0))},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||sf("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||sf("Error setting tcoordMC in shader VAO.")),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi("texture1",a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();n.getProgram().setUniformi("pwfTexture1",u);const p=t.labelOutlineThicknessTexture.getTextureUnit();if(n.getProgram().setUniformi("labelOutlineTexture1",p),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(tt("OpenGL has a limit of 6 clipping planes"),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),y(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),y(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",i)}if(!0===o.getProperty().getUseLabelOutline()){const e=o.getProperty().getLabelOutlineOpacity();n.getProgram().setUniformf("outlineOpacity",e)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();y(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(y(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();y(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix("MCPCMatrix",t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();let i=t.renderable.getClosestIJKAxis().ijkMode;i===lf.NONE&&(i=lf.K),a.setUniform3i("imageDimensions",o[0],o[1],o[2]),a.setUniformi("sliceAxis",i),a.setUniformMatrix("vWCtoIDX",n);const l=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,l.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const c=e.getRenderTargetSize();a.setUniformf("vpWidth",c[0]),a.setUniformf("vpHeight",c[1]);const u=e.getRenderTargetOffset();a.setUniformf("vpOffsetX",u[0]/c[0]),a.setUniformf("vpOffsetY",u[1]/c[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf("opacity",o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):sf("No input!")},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=[];for(let e=0;e<d;++e)f.push(l.getRGBTransferFunction(e));const g=Zp(f,u,d),m=l.getRGBTransferFunction(),h=t._openGLRenderWindow.getGraphicsResourceForObject(m);if(h?.oglObject?.getHandle()&&h?.hash===g)t.colorTexture=h.oglObject;else{t.colorTexture=Ju.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(n*p*3);if(c===Jp.NEAREST?(t.colorTexture.setMinificationFilter(Bu.NEAREST),t.colorTexture.setMagnificationFilter(Bu.NEAREST)):(t.colorTexture.setMinificationFilter(Bu.LINEAR),t.colorTexture.setMagnificationFilter(Bu.LINEAR)),m){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:p,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.create2DFromRaw({width:n,height:1,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}m&&(t._openGLRenderWindow.setGraphicsResourceForObject(m,t.colorTexture,g),m!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(m,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=m)}const v=[];for(let e=0;e<d;++e)v.push(l.getPiecewiseFunction(e));const T=Zp(v,u,d),y=l.getPiecewiseFunction(),b=t._openGLRenderWindow.getGraphicsResourceForObject(y);if(b?.oglObject?.getHandle()&&b?.hash===T)t.pwfTexture=b.oglObject;else{let n=t.renderable.getOpacityTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=Ju.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),c===Jp.NEAREST?(t.pwfTexture.setMinificationFilter(Bu.NEAREST),t.pwfTexture.setMagnificationFilter(Bu.NEAREST)):(t.pwfTexture.setMinificationFilter(Bu.LINEAR),t.pwfTexture.setMagnificationFilter(Bu.LINEAR)),y){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=l.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:p,numComps:1,dataType:is.FLOAT,data:e})}else o.fill(255),t.pwfTexture.create2DFromRaw({width:n,height:1,numComps:1,dataType:is.UNSIGNED_CHAR,data:o});y&&(t._openGLRenderWindow.setGraphicsResourceForObject(y,t.pwfTexture,T),y!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(y,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=y)}e.updatelabelOutlineThicknessTexture(r);const{ijkMode:x}=t.renderable.getClosestIJKAxis();let C=t.renderable.getSlice();x!==t.renderable.getSlicingMode()&&(C=t.renderable.getSliceAtPosition(C));const S=t.renderable.isA("vtkImageArrayMapper")?t.renderable.getSubSlice():Math.round(C),A=o.getExtent();let I;x===lf.I&&(I=S-A[0]),x===lf.J&&(I=S-A[2]),x!==lf.K&&x!==lf.NONE||(I=S-A[4]);const w=`${C}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==w){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=Ju.newInstance({resizable:!0})),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),c===Jp.NEAREST?(new Set([1,3,4]).has(s)&&i===is.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Bu.NEAREST)):t.openGLTexture.setMinificationFilter(Bu.NEAREST),t.openGLTexture.setMagnificationFilter(Bu.NEAREST)):(4!==s||i!==is.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(Bu.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Bu.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(Bu.LINEAR)),t.openGLTexture.setWrapS(Lu.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Lu.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[lf.X,lf.Y,lf.Z].includes(t.renderable.getSlicingMode())?C:S,p=o.getSpatialExtent(),f=a.getData();let g=null;if(x===lf.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(I+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(x===lf.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+I*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else x===lf.K||x===lf.NONE?(g=f.subarray(I*n,(I+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):sf("Reformat slicing not yet supported.");const m=a.getRanges();t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw({width:e[0],height:e[1],numComps:s,dataType:a.getDataType(),data:g,preferSizeOverAccuracy:!!t.renderable.getPreferSizeOverAccuracy?.(),ranges:m}),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const h=Ts.newInstance({numberOfComponents:3,values:r});h.setName("points");const v=Ts.newInstance({numberOfComponents:2,values:l});v.setName("tcoords");const T=new Uint16Array(8);T[0]=3,T[1]=0,T[2]=1,T[3]=3,T[4]=3,T[5]=0,T[6]=3,T[7]=2;const y=Ts.newInstance({numberOfComponents:1,values:T});t.tris.getCABO().createVBO(y,"polys",qi.SURFACE,{points:h,tcoords:v,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=w}},e.updatelabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThicknessByReference(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture=Ju.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(Bu.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(Bu.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw({width:n,height:o,numComps:1,dataType:is.UNSIGNED_CHAR,data:i}),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.delete=Vt((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageMapper");en("vtkAbstractImageMapper",df);const pf=0,ff=1,gf=2,{vtkErrorMacro:mf}=Ht,hf={currentRenderPass:null,volumeTexture:null,colorTexture:null,pwfTexture:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const vf=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hf,n),Xt.extend(e,t,n),nd(e,t,n),Ht.algo(e,t,2,0),t.tris=Du.newInstance(),t.volumeTexture=null,t.colorTexture=null,t.pwfTexture=null,t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},Ht.obj(t.VBOBuildTime,{mtime:0}),function(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageCPRMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()===dl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),e.invokeEvent({type:"EndEvent"}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(n,r)=>{e.getNeedToRebuildBufferObjects(n,r)&&e.buildBufferObjects(n,r),r.getProperty().getInterpolationType()===Jp.NEAREST?(t.volumeTexture.setMinificationFilter(Bu.NEAREST),t.volumeTexture.setMagnificationFilter(Bu.NEAREST),t.colorTexture.setMinificationFilter(Bu.NEAREST),t.colorTexture.setMagnificationFilter(Bu.NEAREST),t.pwfTexture.setMinificationFilter(Bu.NEAREST),t.pwfTexture.setMagnificationFilter(Bu.NEAREST)):(t.volumeTexture.setMinificationFilter(Bu.LINEAR),t.volumeTexture.setMagnificationFilter(Bu.LINEAR),t.colorTexture.setMinificationFilter(Bu.LINEAR),t.colorTexture.setMagnificationFilter(Bu.LINEAR),t.pwfTexture.setMinificationFilter(Bu.LINEAR),t.pwfTexture.setMagnificationFilter(Bu.LINEAR))},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()||!t.volumeTexture?.getHandle()},e.buildBufferObjects=(n,r)=>{const o=t.currentImageDataInput,a=t.currentCenterlineInput,i=r.getProperty(),s=o?.getPointData()?.getScalars();if(!s)return;const l=t._openGLRenderWindow.getGraphicsResourceForObject(s),c=Qp(0,s),u=!l?.oglObject?.getHandle()||l?.hash!==c,d=i.getUpdatedExtents(),p=!!d.length;if(u){t.volumeTexture=Ju.newInstance(),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.volumeTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromDataArray({width:n[0],height:n[1],depth:n[2],dataArray:s,preferSizeOverAccuracy:t.renderable.getPreferSizeOverAccuracy()}),t._openGLRenderWindow.setGraphicsResourceForObject(s,t.volumeTexture,c),s!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(s,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=s}else t.volumeTexture=l.oglObject;if(p){i.setUpdatedExtents([]);const e=o.getDimensions();t.volumeTexture.create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:s,updatedExtents:d})}const f=s.getNumberOfComponents(),g=r.getProperty(),m=g.getIndependentComponents(),h=m?f:1,v=m?2*h:1,T=[];for(let e=0;e<h;++e)T.push(g.getRGBTransferFunction(e));const y=Zp(T,m,h),b=g.getRGBTransferFunction(),x=t._openGLRenderWindow.getGraphicsResourceForObject(b);if(x?.oglObject?.getHandle()&&x?.hash===y)t.colorTexture=x.oglObject;else{let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(n*v*3);if(t.colorTexture=Ju.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),b){const e=new Float32Array(3*n);for(let t=0;t<h;t++){const o=g.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),m)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:v,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:1,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}b&&(t._openGLRenderWindow.setGraphicsResourceForObject(b,t.colorTexture,y),b!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(b,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=b)}const C=[];for(let e=0;e<h;++e)C.push(g.getPiecewiseFunction(e));const S=Zp(C,m,h),A=g.getPiecewiseFunction(),I=t._openGLRenderWindow.getGraphicsResourceForObject(A);if(I?.oglObject?.getHandle()&&I?.hash===S)t.pwfTexture=I.oglObject;else{let n=t.renderable.getOpacityTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=n*v,o=new Uint8ClampedArray(r);if(t.pwfTexture=Ju.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),A){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<h;++t){const r=g.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),m)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:v,numComps:1,dataType:is.FLOAT,data:e})}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:1,numComps:1,dataType:is.UNSIGNED_CHAR,data:o});A&&(t._openGLRenderWindow.setGraphicsResourceForObject(A,t.pwfTexture,S),A!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(A,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=A)}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<a.getMTime()){const e=a.getNumberOfPoints(),n=e<=1?0:e-1,r=a.getDistancesToFirstPoint(),o=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,o-r[e],0],t),t+=3,s.set([l,o-r[e],0],t),t+=3,s.set([l,o-r[e+1],0],t),t+=3,s.set([0,o-r[e+1],0],t),t+=3;const c=Ts.newInstance({numberOfComponents:3,values:s});c.setName("points");const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Ts.newInstance({numberOfComponents:1,values:u}),p=a.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Ts.newInstance({numberOfComponents:3,values:f,name:"centerlinePosition"}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const T=[h,Ts.newInstance({numberOfComponents:1,values:v,name:"quadIndex"})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getOrientedCenterline().getOrientations()??[],r=new Float32Array(4*i),o=new Float32Array(4*i);for(let t=0;t<n;++t){const n=e[t],a=e[t+1];for(let e=0;e<4;++e){const i=4*(e+4*t);r.set(n,i),o.set(a,i)}}const a=Ts.newInstance({numberOfComponents:4,values:r,name:"centerlineTopOrientation"}),s=Ts.newInstance({numberOfComponents:4,values:o,name:"centerlineBotOrientation"});T.push(a,s)}t.tris.getCABO().createVBO(d,"polys",qi.SURFACE,{points:c,customAttributes:T}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation(),l=t.renderable.isProjectionEnabled()&&t.renderable.getProjectionMode();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastProjectionMode!==l||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastProjectionMode=l,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;const s=["vec3 applyQuaternionToVec(vec4 q, vec3 v) {","  float uvx = q.y * v.z - q.z * v.y;","  float uvy = q.z * v.x - q.x * v.z;","  float uvz = q.x * v.y - q.y * v.x;","  float uuvx = q.y * uvz - q.z * uvy;","  float uuvy = q.z * uvx - q.x * uvz;","  float uuvz = q.x * uvy - q.y * uvx;","  float w2 = q.w * 2.0;","  uvx *= w2;","  uvy *= w2;","  uvz *= w2;","  uuvx *= 2.0;","  uuvy *= 2.0;","  uuvz *= 2.0;","  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);","}"];a=wu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=wu.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result;const l=["attribute vec3 centerlinePosition;","attribute float quadIndex;","uniform float width;","out vec2 quadOffsetVSOutput;","out vec3 centerlinePosVSOutput;"],c=t.renderable.isProjectionEnabled(),u=t.renderable.getUseUniformOrientation();u?(l.push("out vec3 samplingDirVSOutput;","uniform vec4 centerlineOrientation;","uniform vec3 tangentDirection;",...s),c&&l.push("out vec3 projectionDirVSOutput;","uniform vec3 bitangentDirection;")):l.push("out vec4 centerlineTopOrientationVSOutput;","out vec4 centerlineBotOrientationVSOutput;","attribute vec4 centerlineTopOrientation;","attribute vec4 centerlineBotOrientation;"),a=wu.substitute(a,"//VTK::Color::Dec",l).result;const d=["quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);","centerlinePosVSOutput = centerlinePosition;"];u?(d.push("samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);"),c&&d.push("projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);")):d.push("centerlineTopOrientationVSOutput = centerlineTopOrientation;","centerlineBotOrientationVSOutput = centerlineBotOrientation;"),a=wu.substitute(a,"//VTK::Color::Impl",d).result;const p=t.volumeTexture.getComponents(),f=o.getProperty().getIndependentComponents();let g=["uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates","in vec2 quadOffsetVSOutput;","in vec3 centerlinePosVSOutput;","uniform highp sampler3D volumeTexture;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;"];c&&g.push("uniform vec3 volumeSizeMC;","uniform int projectionSlabNumberOfSamples;","uniform float projectionConstantOffset;","uniform float projectionStepLength;"),u?(g.push("in vec3 samplingDirVSOutput;"),c&&g.push("in vec3 projectionDirVSOutput;")):(g.push("uniform vec3 tangentDirection;","in vec4 centerlineTopOrientationVSOutput;","in vec4 centerlineBotOrientationVSOutput;",...s),c&&g.push("uniform vec3 bitangentDirection;"));const m=t.renderable.getCenterPoint();if(m&&g.push("uniform vec3 globalCenterPoint;"),f){for(let e=1;e<p;e++)g=g.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(p){case 1:g=g.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:g=g.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:mf("Unsupported number of independent coordinates.")}}i=wu.substitute(i,"//VTK::TCoord::Dec",g).result;let h=[];if(u?(h.push("vec3 samplingDirection = samplingDirVSOutput;"),c&&h.push("vec3 projectionDirection = projectionDirVSOutput;")):(h.push("vec4 q0 = centerlineBotOrientationVSOutput;","vec4 q1 = centerlineTopOrientationVSOutput;","float qCosAngle = dot(q0, q1);","vec4 interpolatedOrientation;","if (qCosAngle > 0.999 || qCosAngle < -0.999) {","  // Use LERP instead of SLERP when the two quaternions are close or opposite","  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));","} else {","  float omega = acos(qCosAngle);","  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);","}","vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);"),c&&h.push("vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);")),m?h.push("float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);","float horizontalOffset = quadOffsetVSOutput.x + baseOffset;"):h.push("float horizontalOffset = quadOffsetVSOutput.x;"),h.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;","vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;","if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}"),c){const e=t.renderable.getProjectionMode();switch(e===ff?h.push("const vec4 initialProjectionTextureValue = vec4(1.0);"):h.push("const vec4 initialProjectionTextureValue = vec4(0.0);"),h.push("vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;","vec3 projectionStep = projectionStepLength * projectionScaledDirection;","vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;","vec4 tvalue = initialProjectionTextureValue;","for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {","  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;","  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);"),e){case pf:h.push("  tvalue = max(tvalue, sampledTextureValue);");break;case ff:h.push("  tvalue = min(tvalue, sampledTextureValue);");break;default:h.push("  tvalue = tvalue + sampledTextureValue;")}h.push("}"),e===gf&&h.push("tvalue = tvalue / float(projectionSlabNumberOfSamples);")}else h.push("vec4 tvalue = texture(volumeTexture, volumePosTC);");if(f){const e=["r","g","b","a"];for(let t=0;t<p;++t)h=h.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(p){case 1:h=h.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:h=h.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:mf("Unsupported number of independent coordinates.")}}else switch(p){case 1:h=h.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:h=h.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=wu.substitute(i,"//VTK::TCoord::Impl",h).result,t.haveSeenDepthRequest&&(i=wu.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=wu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(Ht.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6),o=wu.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=wu.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=wu.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=wu.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=ed,e.Fragment=td,e.Geometry=""},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=n.getCABO();i.getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(a,i,"vertexMC",i.getVertexOffset(),i.getStride(),t.context.FLOAT,3,t.context.FALSE)||mf("Error setting vertexMC in shader VAO.")),n.getCABO().getCustomData().forEach((e=>{e&&a.isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(a,i,e.name,e.offset,i.getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&mf(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const s=t.volumeTexture.getTextureUnit();if(a.setUniformi("volumeTexture",s),a.setUniformf("width",t.renderable.getWidth()),n.getProgram().setUniform4fv("backgroundColor",t.renderable.getBackgroundColor()),a.isUniformUsed("tangentDirection")){const e=t.renderable.getTangentDirection();n.getProgram().setUniform3fArray("tangentDirection",e)}if(a.isUniformUsed("bitangentDirection")){const e=t.renderable.getBitangentDirection();n.getProgram().setUniform3fArray("bitangentDirection",e)}if(a.isUniformUsed("centerlineOrientation")){const e=t.renderable.getUniformOrientation();n.getProgram().setUniform4fv("centerlineOrientation",e)}if(a.isUniformUsed("globalCenterPoint")){const e=t.renderable.getCenterPoint();a.setUniform3fArray("globalCenterPoint",e)}if(t.renderable.isProjectionEnabled()){const e=t.currentImageDataInput,n=e.getSpacing(),r=e.getDimensions(),o=t.renderable.getProjectionSlabThickness(),i=t.renderable.getProjectionSlabNumberOfSamples(),s=En([],n,r);a.setUniform3fArray("volumeSizeMC",s),a.setUniformi("projectionSlabNumberOfSamples",i);const l=-.5*o;a.setUniformf("projectionConstantOffset",l);const c=o/(i-1);a.setUniformf("projectionStepLength",c)}const l=t.currentImageDataInput,c=l.getWorldToIndex(),u=O(new Float32Array(16),Cn([],l.getDimensions())),p=oe(u,u,c);if(a.setUniformMatrix("MCTCMatrix",p),t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(Ht.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6);const n=i.getCoordShiftAndScaleEnabled()?i.getInverseShiftAndScaleMatrix():null,r=n?d(t.imagematinv,o.getMatrix()):o.getMatrix();n&&(m(r,r),y(r,r,n),m(r,r)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),y(t.imagematinv,r,t.imagemat);const s=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)s.push(e[t])}a.setUniformi("numClipPlanes",e),a.setUniform4fv("clipPlanes",s)}if(a.isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);a.setUniformf("coffset",t.offset),a.isUniformUsed("cfactor")&&a.setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(y(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();y(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix("MCPCMatrix",t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.delete=Ht.chain((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageCPRMapper");en("vtkImageCPRMapper",vf);const Tf={context:null,keyMatrixTime:null,keyMatrices:null};const yf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},St(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLImageSlice"),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}(e,t)}),"vtkOpenGLImageSlice");en("vtkImageSlice",yf);const bf={};const xf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bf,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),St(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLVolume"),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}(e,t)}),"vtkOpenGLVolume");en("vtkVolume",xf);const Cf={NEAREST:0,LINEAR:1,FAST_LINEAR:2},Sf={FRACTIONAL:0,PROPORTIONAL:1},Af={DEFAULT:0,ADDITIVE:1,COLORIZE:2,CUSTOM:3};var If={InterpolationType:Cf,OpacityMode:Sf,ColorMixPreset:Af,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const wf={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5,LABELMAP_EDGE_PROJECTION_BLEND:6};var Of={BlendMode:wf};const{vtkWarningMacro:Pf,vtkErrorMacro:Rf}=jt,Mf={idxToView:g(new Float64Array(16)),vecISToVCMatrix:pe(new Float64Array(9)),modelToView:g(new Float64Array(16)),projectionToView:g(new Float64Array(16)),projectionToWorld:g(new Float64Array(16))};const Ef={context:null,VBOBuildTime:null,scalarTextures:[],_scalarTexturesCore:[],opacityTexture:null,_opacityTextureCore:null,colorTexture:null,_colorTextureCore:null,labelOutlineThicknessTexture:null,_labelOutlineThicknessTextureCore:null,jitterTexture:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,fullViewportTime:1,idxToView:null,vecISToVCMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0};const Vf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ef,n),Xt.extend(e,t,n),rd(e,t,n),t.VBOBuildTime={},vt(t.VBOBuildTime,{mtime:0}),t.tris=Du.newInstance(),t.jitterTexture=Ju.newInstance(),t.jitterTexture.setWrapS(Lu.REPEAT),t.jitterTexture.setWrapT(Lu.REPEAT),t.framebuffer=Zd.newInstance(),St(e,t,["context"]),function(e,t){function n(e){return e.getUseLabelOutline()||t.renderable.getBlendMode()===wf.LABELMAP_EDGE_PROJECTION_BLEND}t.classHierarchy.push("vtkOpenGLVolumeMapper");const r=new Map;function o(t,n,o){n!==o&&(function(t,n){if(!n)return;const o=(r.get(n)??0)-1;o<=0?(t.unregisterGraphicsResourceUser(n,e),r.delete(n)):r.set(n,o)}(t,n),function(t,n){if(!n)return;const o=r.get(n)??0,a=o+1;r.set(n,a),o<=0&&t.registerGraphicsResourceUser(n,e)}(t,o))}function a(t){[...r.keys()].forEach((n=>t.unregisterGraphicsResourceUser(n,e)))}e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(n,r)=>{if(n){const n=t._openGLRenderWindow;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),n&&!n.isDeleted()&&n!==t._openGLRenderWindow&&a(n),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType("vtkOpenGLVolume");const r=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),e.renderPiece(o,r)}},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the volume mappers fragment shader\n\nconst float infinity = 3.402823466e38;\n\n// the output of this shader\n//VTK::Output::Dec\n\nin vec3 vertexVCVSOutput;\n\n// From Sources\\Rendering\\Core\\VolumeProperty\\Constants.js\n#define COMPOSITE_BLEND 0\n#define MAXIMUM_INTENSITY_BLEND 1\n#define MINIMUM_INTENSITY_BLEND 2\n#define AVERAGE_INTENSITY_BLEND 3\n#define ADDITIVE_INTENSITY_BLEND 4\n#define RADON_TRANSFORM_BLEND 5\n#define LABELMAP_EDGE_PROJECTION_BLEND 6\n\n#define vtkNumberOfLights //VTK::NumberOfLights\n#define vtkMaxLaoKernelSize //VTK::MaxLaoKernelSize\n#define vtkNumberOfComponents //VTK::NumberOfComponents\n#define vtkBlendMode //VTK::BlendMode\n#define vtkMaximumNumberOfSamples //VTK::MaximumNumberOfSamples\n\n//VTK::EnabledColorFunctions\n\n//VTK::EnabledLightings\n\n//VTK::EnabledMultiTexturePerVolume\n\n//VTK::EnabledGradientOpacity\n\n//VTK::EnabledIndependentComponents\n\n//VTK::vtkProportionalComponents\n\n//VTK::vtkForceNearestComponents\n\nuniform int twoSidedLighting;\n\n#if vtkMaxLaoKernelSize > 0\n  vec2 kernelSample[vtkMaxLaoKernelSize];\n#endif\n\n// Textures\n#ifdef EnabledMultiTexturePerVolume\n  #define vtkNumberOfVolumeTextures vtkNumberOfComponents\n#else\n  #define vtkNumberOfVolumeTextures 1\n#endif\nuniform highp sampler3D volumeTexture[vtkNumberOfVolumeTextures];\nuniform sampler2D colorTexture;\nuniform sampler2D opacityTexture;\nuniform sampler2D jtexture;\nuniform sampler2D labelOutlineThicknessTexture;\n\nstruct Volume {\n  // ---- Volume geometry settings ----\n\n  vec3 originVC;          // in VC\n  vec3 spacing;           // in VC per IC\n  vec3 inverseSpacing;    // 1/spacing\n  ivec3 dimensions;       // in IC\n  vec3 inverseDimensions; // 1/vec3(dimensions)\n  mat3 vecISToVCMatrix;   // convert from IS to VC without translation\n  mat3 vecVCToISMatrix;   // convert from VC to IS without translation\n  mat4 PCWCMatrix;\n  mat4 worldToIndex;\n  float diagonalLength; // in VC, this is: length(size)\n\n  // ---- Texture settings ----\n\n  // Texture shift and scale\n  vec4 colorTextureScale;\n  vec4 colorTextureShift;\n  vec4 opacityTextureScale;\n  vec4 opacityTextureShift;\n\n  // The heights defined below are the locations for the up to four components\n  // of the transfer functions. The transfer functions have a height of (2 *\n  // numberOfComponents) pixels so the values are computed to hit the middle of\n  // the two rows for that component\n  vec4 transferFunctionsSampleHeight;\n\n  // ---- Mode specific settings ----\n\n  // Independent component default preset settings per component\n  vec4 independentComponentMix;\n\n  // Additive / average blending mode settings\n  vec4 ipScalarRangeMin;\n  vec4 ipScalarRangeMax;\n\n  // ---- Rendering settings ----\n\n  // Lighting\n  float ambient;\n  float diffuse;\n  float specular;\n  float specularPower;\n  int computeNormalFromOpacity;\n\n  // Gradient opacity\n  vec4 gradientOpacityScale;\n  vec4 gradientOpacityShift;\n  vec4 gradientOpacityMin;\n  vec4 gradientOpacityMax;\n\n  // Volume shadow\n  float volumetricScatteringBlending;\n  float globalIlluminationReach;\n  float anisotropy;\n  float anisotropySquared;\n\n  // LAO\n  int kernelSize;\n  int kernelRadius;\n\n  // Label outline\n  float outlineOpacity;\n};\nuniform Volume volume;\n\nstruct Light {\n  vec3 color;\n  vec3 positionVC;\n  vec3 directionVC; // normalized\n  vec3 halfAngleVC;\n  vec3 attenuation;\n  float exponent;\n  float coneAngle;\n  int isPositional;\n};\n#if vtkNumberOfLights > 0\n  uniform Light lights[vtkNumberOfLights];\n#endif\n\nuniform float vpWidth;\nuniform float vpHeight;\nuniform float vpOffsetX;\nuniform float vpOffsetY;\n\n// Bitmasks for label outline\nconst int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum\n#define MAX_SEGMENTS 256\n#define UINT_SIZE 32\n// We add UINT_SIZE - 1, as we want the ceil of the division instead of the\n// floor\n#define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)\nuint labelOutlineBitmasks[BITMASK_SIZE];\n\n// Set the corresponding bit in the bitmask\nvoid setLabelOutlineBit(int segmentIndex) {\n  int arrayIndex = segmentIndex / UINT_SIZE;\n  int bitIndex = segmentIndex % UINT_SIZE;\n  labelOutlineBitmasks[arrayIndex] |= 1u << bitIndex;\n}\n\n// Check if a bit is set in the bitmask\nbool isLabelOutlineBitSet(int segmentIndex) {\n  int arrayIndex = segmentIndex / UINT_SIZE;\n  int bitIndex = segmentIndex % UINT_SIZE;\n  return ((labelOutlineBitmasks[arrayIndex] & (1u << bitIndex)) != 0u);\n}\n\n// if you want to see the raw tiled\n// data in webgl1 uncomment the following line\n// #define debugtile\n\n// camera values\nuniform float camThick;\nuniform float camNear;\nuniform float camFar;\nuniform int cameraParallel;\n\n//VTK::ClipPlane::Dec\n\n// A random number between 0 and 1 that only depends on the fragment\n// It uses the jtexture, so this random seed repeats by blocks of 32 fragments\n// in screen space\nfloat fragmentSeed;\n\n// sample texture is global\nuniform float sampleDistance;\nuniform float volumeShadowSampleDistance;\n\n// declaration for intermixed geometry\n//VTK::ZBuffer::Dec\n\n//=======================================================================\n// global and custom variables (a temporary section before photorealistics\n// rendering module is complete)\nvec3 rayDirVC;\n\n#define INV4PI 0.0796\n#define EPSILON 0.001\n#define PI 3.1415\n#define PI2 9.8696\n\nvec4 rawSampleTexture(vec3 pos) {\n  #ifdef EnabledMultiTexturePerVolume\n    vec4 rawSample;\n    rawSample[0] = texture(volumeTexture[0], pos)[0];\n  #if vtkNumberOfComponents > 1\n    rawSample[1] = texture(volumeTexture[1], pos)[0];\n  #endif\n  #if vtkNumberOfComponents > 2\n    rawSample[2] = texture(volumeTexture[2], pos)[0];\n  #endif\n  #if vtkNumberOfComponents > 3\n    rawSample[3] = texture(volumeTexture[3], pos)[0];\n  #endif\n    return rawSample;\n  #else\n    return texture(volumeTexture[0], pos);\n  #endif\n}\n\nvec4 rawFetchTexture(ivec3 pos) {\n  #ifdef EnabledMultiTexturePerVolume\n    vec4 rawSample;\n    #if vtkNumberOfComponents > 0\n      rawSample[0] = texelFetch(volumeTexture[0], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 1\n      rawSample[1] = texelFetch(volumeTexture[1], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 2\n      rawSample[2] = texelFetch(volumeTexture[2], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 3\n      rawSample[3] = texelFetch(volumeTexture[3], pos, 0)[0];\n    #endif\n    return rawSample;\n  #else\n    return texelFetch(volumeTexture[0], pos, 0);\n  #endif\n}\n\nvec4 getTextureValue(vec3 pos) {\n  vec4 tmp = rawSampleTexture(pos);\n\n  // Force nearest\n  #if defined(vtkComponent0ForceNearest) || \\\n      defined(vtkComponent1ForceNearest) || \\\n      defined(vtkComponent2ForceNearest) || \\\n      defined(vtkComponent3ForceNearest)\n    vec3 nearestPos = (floor(pos * vec3(volume.dimensions)) + 0.5) *\n                      volume.inverseDimensions;\n    vec4 nearestValue = rawSampleTexture(nearestPos);\n    #ifdef vtkComponent0ForceNearest\n      tmp[0] = nearestValue[0];\n    #endif\n    #ifdef vtkComponent1ForceNearest\n      tmp[1] = nearestValue[1];\n    #endif\n    #ifdef vtkComponent2ForceNearest\n      tmp[2] = nearestValue[2];\n    #endif\n    #ifdef vtkComponent3ForceNearest\n      tmp[3] = nearestValue[3];\n    #endif\n  #endif\n\n  // Set alpha when using dependent components\n  #ifndef EnabledIndependentComponents\n    #if vtkNumberOfComponents == 1\n      tmp.a = tmp.r;\n    #endif\n    #if vtkNumberOfComponents == 2\n      tmp.a = tmp.g;\n    #endif\n    #if vtkNumberOfComponents == 3\n      tmp.a = length(tmp.rgb);\n    #endif\n  #endif\n\n  return tmp;\n}\n\n// `height` is usually `volume.transferFunctionsSampleHeight[component]`\n// when using independent component and `0.5` otherwise. Don't move the if\n// statement in these function, as the callers usually already knows if it is\n// using independent component or not\nfloat getOpacityFromTexture(float scalar, int component, float height) {\n  float scaledScalar = scalar * volume.opacityTextureScale[component] +\n                       volume.opacityTextureShift[component];\n  return texture2D(opacityTexture, vec2(scaledScalar, height)).r;\n}\nvec3 getColorFromTexture(float scalar, int component, float height) {\n  float scaledScalar = scalar * volume.colorTextureScale[component] +\n                       volume.colorTextureShift[component];\n  return texture2D(colorTexture, vec2(scaledScalar, height)).rgb;\n}\n\n//=======================================================================\n// transformation between VC and IS space\n\n// convert vector position from idx to vc\nvec3 posIStoVC(vec3 posIS) {\n  return volume.vecISToVCMatrix * posIS + volume.originVC;\n}\n\n// convert vector position from vc to idx\nvec3 posVCtoIS(vec3 posVC) {\n  return volume.vecVCToISMatrix * (posVC - volume.originVC);\n}\n\n// Rotate vector to view coordinate\nvec3 vecISToVC(vec3 dirIS) {\n  return volume.vecISToVCMatrix * dirIS;\n}\n\n// Rotate vector to idx coordinate\nvec3 vecVCToIS(vec3 dirVC) {\n  return volume.vecVCToISMatrix * dirVC;\n}\n\n//=======================================================================\n// Given a normal compute the gradient opacity factors\nfloat computeGradientOpacityFactor(float normalMag, int component) {\n  float goscale = volume.gradientOpacityScale[component];\n  float goshift = volume.gradientOpacityShift[component];\n  float gomin = volume.gradientOpacityMin[component];\n  float gomax = volume.gradientOpacityMax[component];\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\n}\n\n#ifdef vtkClippingPlanesOn\n  bool isPointClipped(vec3 posVC) {\n    for (int i = 0; i < clip_numPlanes; ++i) {\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0) {\n        return true;\n      }\n    }\n    return false;\n  }\n#endif\n\n//=======================================================================\n// compute the normal and gradient magnitude for a position, uses forward\n// difference\n\n// The output normal is in VC\nvec4 computeDensityNormal(vec3 opacityUCoords[2], float opacityTextureHeight,\n                          float gradientOpacity, int component) {\n  // Pass the scalars through the opacity functions\n  vec4 opacityG;\n  opacityG.x += getOpacityFromTexture(opacityUCoords[0].x, component,\n                                      opacityTextureHeight);\n  opacityG.y += getOpacityFromTexture(opacityUCoords[0].y, component,\n                                      opacityTextureHeight);\n  opacityG.z += getOpacityFromTexture(opacityUCoords[0].z, component,\n                                      opacityTextureHeight);\n  opacityG.x -= getOpacityFromTexture(opacityUCoords[1].x, component,\n                                      opacityTextureHeight);\n  opacityG.y -= getOpacityFromTexture(opacityUCoords[1].y, component,\n                                      opacityTextureHeight);\n  opacityG.z -= getOpacityFromTexture(opacityUCoords[1].z, component,\n                                      opacityTextureHeight);\n\n  // Divide by spacing and convert to VC\n  opacityG.xyz *= gradientOpacity * volume.inverseSpacing;\n  opacityG.w = length(opacityG.xyz);\n  if (opacityG.w == 0.0) {\n    return vec4(0.0);\n  }\n\n  // Normalize\n  opacityG.xyz = normalize(vecISToVC(opacityG.xyz));\n\n  return opacityG;\n}\n\n// The output normal is in VC\nvec4 computeNormalForDensity(vec3 posIS, out vec3 scalarInterp[2],\n                             const int opacityComponent) {\n  vec3 offsetedPosIS;\n  for (int axis = 0; axis < 3; ++axis) {\n    // Positive direction\n    offsetedPosIS = posIS;\n    offsetedPosIS[axis] += volume.inverseDimensions[axis];\n    scalarInterp[0][axis] =\n        getTextureValue(offsetedPosIS)[opacityComponent];\n    #ifdef vtkClippingPlanesOn\n      if (isPointClipped(posIStoVC(offsetedPosIS))) {\n        scalarInterp[0][axis] = 0.0;\n      }\n    #endif\n\n    // Negative direction\n    offsetedPosIS = posIS;\n    offsetedPosIS[axis] -= volume.inverseDimensions[axis];\n    scalarInterp[1][axis] =\n        getTextureValue(offsetedPosIS)[opacityComponent];\n    #ifdef vtkClippingPlanesOn\n      if (isPointClipped(posIStoVC(offsetedPosIS))) {\n        scalarInterp[1][axis] = 0.0;\n      }\n    #endif\n  }\n\n  vec4 result;\n  result.xyz = (scalarInterp[0] - scalarInterp[1]) * volume.inverseSpacing;\n  result.w = length(result.xyz);\n  if (result.w == 0.0) {\n    return vec4(0.0);\n  }\n  result.xyz = normalize(vecISToVC(result.xyz));\n  return result;\n}\n\nvec4 fragCoordToPCPos(vec4 fragCoord) {\n  return vec4((fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\n              (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\n              (fragCoord.z - 0.5) * 2.0, 1.0);\n}\n\nvec4 pcPosToWorldCoord(vec4 pcPos) {\n  return volume.PCWCMatrix * pcPos;\n}\n\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\n  vec4 pcPos = fragCoordToPCPos(fragCoord);\n  vec4 worldCoord = pcPosToWorldCoord(pcPos);\n  vec4 vertex = (worldCoord / worldCoord.w);\n\n  vec3 index = (volume.worldToIndex * vertex).xyz;\n\n  // half voxel fix for labelmapOutline\n  return (index + vec3(0.5)) * volume.inverseDimensions;\n}\n\nvec3 fragCoordToWorld(vec4 fragCoord) {\n  vec4 pcPos = fragCoordToPCPos(fragCoord);\n  vec4 worldCoord = pcPosToWorldCoord(pcPos);\n  return worldCoord.xyz;\n}\n\n//=======================================================================\n// Compute the normals and gradient magnitudes for a position for independent\n// components The output normals are in VC\nmat4 computeMat4Normal(vec3 posIS, vec4 tValue) {\n  vec3 xvec = vec3(volume.inverseDimensions.x, 0.0, 0.0);\n  vec3 yvec = vec3(0.0, volume.inverseDimensions.y, 0.0);\n  vec3 zvec = vec3(0.0, 0.0, volume.inverseDimensions.z);\n\n  vec4 distX = getTextureValue(posIS + xvec) - getTextureValue(posIS - xvec);\n  vec4 distY = getTextureValue(posIS + yvec) - getTextureValue(posIS - yvec);\n  vec4 distZ = getTextureValue(posIS + zvec) - getTextureValue(posIS - zvec);\n\n  // divide by spacing\n  distX *= 0.5 * volume.inverseSpacing.x;\n  distY *= 0.5 * volume.inverseSpacing.y;\n  distZ *= 0.5 * volume.inverseSpacing.z;\n\n  mat4 result;\n\n  // optionally compute the 1st component\n  #if vtkNumberOfComponents > 0 && !defined(vtkComponent0Proportional)\n    {\n      const int component = 0;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 2nd component\n  #if vtkNumberOfComponents > 1 && !defined(vtkComponent1Proportional)\n    {\n      const int component = 1;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 3rd component\n  #if vtkNumberOfComponents > 2 && !defined(vtkComponent2Proportional)\n    {\n      const int component = 2;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 4th component\n  #if vtkNumberOfComponents > 3 && !defined(vtkComponent3Proportional)\n    {\n      const int component = 3;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  return result;\n}\n\n//=======================================================================\n// global shadow - secondary ray\n\n// henyey greenstein phase function\nfloat phaseFunction(float cos_angle) {\n  // divide by 2.0 instead of 4pi to increase intensity\n  float anisotropy = volume.anisotropy;\n  if (abs(anisotropy) <= EPSILON) {\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\n    return 0.5;\n  }\n  float anisotropy2 = volume.anisotropySquared;\n  return ((1.0 - anisotropy2) /\n          pow(1.0 + anisotropy2 - 2.0 * anisotropy * cos_angle, 1.5)) /\n         2.0;\n}\n\n// Compute the two intersection distances of the ray with the volume in VC\n// The entry point is `rayOriginVC + distanceMin * rayDirVC` and the exit point\n// is `rayOriginVC + distanceMax * rayDirVC` If distanceMin < distanceMax, the\n// volume is not intersected The ray origin is inside the box when distanceMin <\n// 0.0 < distanceMax\nvec2 rayIntersectVolumeDistances(vec3 rayOriginVC, vec3 rayDirVC) {\n  // Compute origin and direction in IS\n  vec3 rayOriginIS = posVCtoIS(rayOriginVC);\n  vec3 rayDirIS = vecVCToIS(rayDirVC);\n  // Don't check for infinity as the min/max combination afterward will always\n  // find an intersection before infinity\n  vec3 invDir = 1.0 / rayDirIS;\n\n  // We have: bound = origin + t * dir\n  // So: t = (1/dir) * (bound - origin)\n  vec3 distancesTo0 = invDir * (vec3(0.0) - rayOriginIS);\n  vec3 distancesTo1 = invDir * (vec3(1.0) - rayOriginIS);\n  // Min and max distances to plane intersection per plane\n  vec3 dMinPerAxis = min(distancesTo0, distancesTo1);\n  vec3 dMaxPerAxis = max(distancesTo0, distancesTo1);\n  // Overall first and last intersection\n  float distanceMin = max(dMinPerAxis.x, max(dMinPerAxis.y, dMinPerAxis.z));\n  float distanceMax = min(dMaxPerAxis.x, min(dMaxPerAxis.y, dMaxPerAxis.z));\n  return vec2(distanceMin, distanceMax);\n}\n\n//=======================================================================\n// local ambient occlusion\n#if vtkMaxLaoKernelSize > 0\n\n  // Return a random point on the unit sphere\n  vec3 sampleDirectionUniform(int rayIndex) {\n    // Each ray of each fragment should be different, two sources of randomness\n    // are used. Only depends on ray index\n    vec2 rayRandomness = kernelSample[rayIndex];\n    // Only depends on fragment\n    float fragmentRandomness = fragmentSeed;\n    // Merge both source of randomness in a single uniform random variable using\n    // the formula (x+y < 1 ? x+y : x+y-1). The simpler formula (x+y)/2 doesn't\n    // result in a uniform distribution\n    vec2 mergedRandom = rayRandomness + vec2(fragmentRandomness);\n    mergedRandom -= vec2(greaterThanEqual(mergedRandom, vec2(1.0)));\n\n    // Insipred by:\n    // https://karthikkaranth.me/blog/generating-random-points-in-a-sphere/#better-choice-of-spherical-coordinates\n    float u = mergedRandom[0];\n    float v = mergedRandom[1];\n    float theta = u * 2.0 * PI;\n    float phi = acos(2.0 * v - 1.0);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    return vec3(sinPhi * cosTheta, sinPhi * sinTheta, cosPhi);\n  }\n\n  float computeLAO(vec3 posVC, vec4 normalVC, float originalOpacity) {\n    // apply LAO only at selected locations, otherwise return full brightness\n    if (normalVC.w <= 0.0 || originalOpacity <= 0.05) {\n      return 1.0;\n    }\n\n    #ifdef EnabledGradientOpacity\n      float gradientOpacityFactor = computeGradientOpacityFactor(normalVC.w, 0);\n    #endif\n\n    float visibilitySum = 0.0;\n    float weightSum = 0.0;\n    for (int i = 0; i < volume.kernelSize; i++) {\n      // Only sample on an hemisphere around the normalVC.xyz axis, so\n      // normalDotRay should be negative\n      vec3 rayDirectionVC = sampleDirectionUniform(i);\n      float normalDotRay = dot(normalVC.xyz, rayDirectionVC);\n      if (normalDotRay > 0.0) {\n        // Flip rayDirectionVC when it is in the wrong hemisphere\n        rayDirectionVC = -rayDirectionVC;\n        normalDotRay = -normalDotRay;\n      }\n\n      vec3 currPosIS = posVCtoIS(posVC);\n      float visibility = 1.0;\n      vec3 randomDirStepIS = vecVCToIS(rayDirectionVC * sampleDistance);\n      for (int j = 0; j < volume.kernelRadius; j++) {\n        currPosIS += randomDirStepIS;\n        // If out of the volume, we are done\n        if (any(lessThan(currPosIS, vec3(0.0))) ||\n            any(greaterThan(currPosIS, vec3(1.0)))) {\n          break;\n        }\n        float opacity = getOpacityFromTexture(getTextureValue(currPosIS).r, 0, 0.5);\n        #ifdef EnabledGradientOpacity\n          opacity *= gradientOpacityFactor;\n        #endif\n        visibility *= 1.0 - opacity;\n        // If visibility is less than EPSILON, consider it to be 0\n        if (visibility < EPSILON) {\n          visibility = 0.0;\n          break;\n        }\n      }\n      float rayWeight = -normalDotRay;\n      visibilitySum += visibility * rayWeight;\n      weightSum += rayWeight;\n    }\n\n    // If no sample, LAO factor is one\n    if (weightSum == 0.0) {\n      return 1.0;\n    }\n\n    // LAO factor is the average visibility:\n    // - visibility low => ambient low\n    // - visibility high => ambient high\n    float lao = visibilitySum / weightSum;\n\n    // Reduce variance by clamping\n    return clamp(lao, 0.3, 1.0);\n  }\n#endif\n\n//=======================================================================\n// Volume shadows\n#if vtkNumberOfLights > 0\n\n  // Non-memoised version\n  float computeVolumeShadowWithoutCache(vec3 posVC, vec3 lightDirNormVC) {\n    // modify sample distance with a random number between 1.5 and 3.0\n    float rayStepLength =\n        volumeShadowSampleDistance * mix(1.5, 3.0, fragmentSeed);\n\n    // in case the first sample near surface has a very tiled light ray, we need\n    // to offset start position\n    vec3 initialPosVC = posVC + rayStepLength * lightDirNormVC;\n\n    #ifdef vtkClippingPlanesOn\n      float clippingPlanesMaxDistance = infinity;\n      for (int i = 0; i < clip_numPlanes; ++i) {\n        // Find distance of intersection with the plane\n        // Points are clipped when:\n        // dot(planeOrigin - (rayOrigin + distance * rayDirection), planeNormal) > 0\n        // This is equivalent to:\n        // dot(planeOrigin - rayOrigin, planeNormal) - distance * dot(rayDirection,\n        // planeNormal) > 0.0\n        // We precompute the dot products, so we clip ray points when:\n        // dotOrigin - distance * dotDirection > 0.0\n        float dotOrigin =\n            dot(vClipPlaneOrigins[i] - initialPosVC, vClipPlaneNormals[i]);\n        if (dotOrigin > 0.0) {\n          // The initialPosVC is clipped by this plane\n          return 1.0;\n        }\n        float dotDirection = dot(lightDirNormVC, vClipPlaneNormals[i]);\n        if (dotDirection < 0.0) {\n          // We only hit the plane if dotDirection is negative, as (distance is\n          // positive)\n          float intersectionDistance =\n              dotOrigin / dotDirection; // negative divided by negative => positive\n          clippingPlanesMaxDistance =\n              min(clippingPlanesMaxDistance, intersectionDistance);\n        }\n      }\n    #endif\n\n    vec2 intersectionDistances =\n        rayIntersectVolumeDistances(initialPosVC, lightDirNormVC);\n\n    if (intersectionDistances[1] <= intersectionDistances[0] ||\n        intersectionDistances[1] <= 0.0) {\n      // Volume not hit or behind the ray\n      return 1.0;\n    }\n\n    // When globalIlluminationReach is 0, no sample at all\n    // When globalIlluminationReach is 1, the ray will go through the whole\n    // volume\n    float maxTravelDistance = mix(0.0, volume.diagonalLength,\n                                  volume.globalIlluminationReach);\n    float startDistance = max(intersectionDistances[0], 0.0);\n    float endDistance = min(intersectionDistances[1], startDistance + maxTravelDistance);\n    #ifdef vtkClippingPlanesOn\n      endDistance = min(endDistance, clippingPlanesMaxDistance);\n    #endif\n    if (endDistance - startDistance < 0.0) {\n      return 1.0;\n    }\n\n    // These two variables are used to compute posIS, without having to call\n    // VCtoIS at each step\n    vec3 initialPosIS = posVCtoIS(initialPosVC);\n    // The light dir is scaled and rotated, but not translated, as it is a\n    // vector (w = 0)\n    vec3 scaledLightDirIS = vecVCToIS(lightDirNormVC);\n\n    float shadow = 1.0;\n    for (float currentDistance = startDistance; currentDistance <= endDistance;\n          currentDistance += rayStepLength) {\n      vec3 posIS = initialPosIS + currentDistance * scaledLightDirIS;\n      vec4 scalar = getTextureValue(posIS);\n      float opacity = getOpacityFromTexture(scalar.r, 0, 0.5);\n      #if defined(EnabledGradientOpacity) && !defined(EnabledIndependentComponents)\n        vec3 scalarInterp[2];\n        vec4 normal = computeNormalForDensity(posIS, scalarInterp, 3);\n        float opacityFactor = computeGradientOpacityFactor(normal.w, 0);\n        opacity *= opacityFactor;\n      #endif\n      shadow *= 1.0 - opacity;\n\n      // Early termination if shadow coeff is near 0.0\n      if (shadow < EPSILON) {\n        return 0.0;\n      }\n    }\n    return shadow;\n  }\n\n  // Some cache for volume shadows\n  struct {\n    vec3 posVC;\n    float shadow;\n  } cachedShadows[vtkNumberOfLights];\n\n  // Memoised version\n  float computeVolumeShadow(vec3 posVC, vec3 lightDirNormVC, int lightIdx) {\n    if (posVC == cachedShadows[lightIdx].posVC) {\n      return cachedShadows[lightIdx].shadow;\n    }\n    float shadow = computeVolumeShadowWithoutCache(posVC, lightDirNormVC);\n    cachedShadows[lightIdx].posVC = posVC;\n    cachedShadows[lightIdx].shadow = shadow;\n    return shadow;\n  }\n\n#endif\n\n//=======================================================================\n// surface light contribution\n#if vtkNumberOfLights > 0\n  vec3 applyLighting(vec3 tColor, vec4 normalVC) {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    for (int lightIdx = 0; lightIdx < vtkNumberOfLights; lightIdx++) {\n      float df = dot(normalVC.xyz, lights[lightIdx].directionVC);\n      if (df > 0.0) {\n        diffuse += df * lights[lightIdx].color;\n        float sf = dot(normalVC.xyz, -lights[lightIdx].halfAngleVC);\n        if (sf > 0.0) {\n          specular += pow(sf, volume.specularPower) * lights[lightIdx].color;\n        }\n      }\n    }\n    return tColor * (diffuse * volume.diffuse + volume.ambient) +\n          specular * volume.specular;\n  }\n\n  vec3 applySurfaceShadowLighting(vec3 tColor, float alpha, vec3 posVC,\n                                  vec4 normalVC) {\n    // everything in VC\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    for (int ligthIdx = 0; ligthIdx < vtkNumberOfLights; ligthIdx++) {\n      vec3 vertLightDirection;\n      float attenuation;\n      if (lights[ligthIdx].isPositional == 1) {\n        vertLightDirection = posVC - lights[ligthIdx].positionVC;\n        float lightDistance = length(vertLightDirection);\n        // Normalize with precomputed length\n        vertLightDirection = vertLightDirection / lightDistance;\n        // Base attenuation\n        vec3 attenuationPolynom = lights[ligthIdx].attenuation;\n        attenuation =\n            1.0 / (attenuationPolynom[0] +\n                  lightDistance * (attenuationPolynom[1] +\n                                    lightDistance * attenuationPolynom[2]));\n        // Cone attenuation\n        float coneDot = dot(vertLightDirection, lights[ligthIdx].directionVC);\n        // Per OpenGL standard cone angle is 90 or less for a spot light\n        if (lights[ligthIdx].coneAngle <= 90.0) {\n          if (coneDot >= cos(radians(lights[ligthIdx].coneAngle))) {\n            // Inside the cone\n            attenuation *= pow(coneDot, lights[ligthIdx].exponent);\n          } else {\n            // Outside the cone\n            attenuation = 0.0;\n          }\n        }\n      } else {\n        vertLightDirection = lights[ligthIdx].directionVC;\n        attenuation = 1.0;\n      }\n\n      float ndotL = dot(normalVC.xyz, vertLightDirection);\n      if (ndotL < 0.0 && twoSidedLighting == 1) {\n        ndotL = -ndotL;\n      }\n      if (ndotL > 0.0) {\n        // Diffuse\n        diffuse += ndotL * attenuation * lights[ligthIdx].color;\n        // Specular\n        float vdotR =\n            dot(-rayDirVC, normalize(vertLightDirection - 2.0 * ndotL * normalVC.xyz));\n        if (vdotR > 0.0) {\n          specular += pow(vdotR, volume.specularPower) * attenuation *\n                      lights[ligthIdx].color;\n        }\n      }\n    }\n    #if vtkMaxLaoKernelSize > 0\n      float laoFactor = computeLAO(posVC, normalVC, alpha);\n    #else\n      const float laoFactor = 1.0;\n    #endif\n    return tColor * (diffuse * volume.diffuse +\n                    volume.ambient * laoFactor) +\n          specular * volume.specular;\n  }\n\n  vec3 applyVolumeShadowLighting(vec3 tColor, vec3 posVC) {\n    // Here we have no effect of cones and no attenuation\n    vec3 diffuse = vec3(0.0);\n    for (int lightIdx = 0; lightIdx < vtkNumberOfLights; lightIdx++) {\n      vec3 lightDirVC = lights[lightIdx].isPositional == 1\n                            ? normalize(lights[lightIdx].positionVC - posVC)\n                            : -lights[lightIdx].directionVC;\n      float shadowCoeff = computeVolumeShadow(posVC, lightDirVC, lightIdx);\n      float phaseAttenuation = phaseFunction(dot(rayDirVC, lightDirVC));\n      diffuse += phaseAttenuation * shadowCoeff * lights[lightIdx].color;\n    }\n    return tColor * (diffuse * volume.diffuse + volume.ambient);\n  }\n#endif\n\n// LAO of surface shadows and volume shadows only work with dependent components\nvec3 applyAllLightning(vec3 tColor, float alpha, vec3 posVC,\n                       vec4 surfaceNormalVC) {\n  #if vtkNumberOfLights > 0\n    // 0 <= volCoeff < EPSILON => only surface shadows\n    // EPSILON <= volCoeff < 1 - EPSILON => mix of surface and volume shadows\n    // 1 - EPSILON <= volCoeff => only volume shadows\n    float volCoeff = volume.volumetricScatteringBlending *\n                    (1.0 - alpha / 2.0) *\n                    (1.0 - atan(surfaceNormalVC.w) * INV4PI);\n\n    // Compute surface lighting if needed\n    vec3 surfaceShadedColor = tColor;\n    #ifdef EnableSurfaceLighting\n      if (volCoeff < 1.0 - EPSILON) {\n        surfaceShadedColor =\n            applySurfaceShadowLighting(tColor, alpha, posVC, surfaceNormalVC);\n      }\n    #endif\n\n    // Compute volume lighting if needed\n    vec3 volumeShadedColor = tColor;\n    #ifdef EnableVolumeLighting\n      if (volCoeff >= EPSILON) {\n        volumeShadedColor = applyVolumeShadowLighting(tColor, posVC);\n      }\n    #endif\n\n    // Return the right mix\n    if (volCoeff < EPSILON) {\n      // Surface shadows\n      return surfaceShadedColor;\n    }\n    if (volCoeff >= 1.0 - EPSILON) {\n      // Volume shadows\n      return volumeShadedColor;\n    }\n    // Mix of surface and volume shadows\n    return mix(surfaceShadedColor, volumeShadedColor, volCoeff);\n  #endif\n  return tColor;\n}\n\nvec4 getColorForLabelOutline() {\n  vec3 centerPosIS =\n      fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\n  vec4 centerValue = getTextureValue(centerPosIS);\n  bool pixelOnBorder = false;\n  vec4 tColor = vec4(getColorFromTexture(centerValue.r, 0, 0.5),\n                     getOpacityFromTexture(centerValue.r, 0, 0.5));\n\n  int segmentIndex = int(centerValue.r * 255.0);\n\n  // Use texture sampling for outlineThickness\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n  float textureValue =\n      texture2D(labelOutlineThicknessTexture, vec2(textureCoordinate, 0.5)).r;\n  int actualThickness = int(textureValue * 255.0);\n\n  // If it is the background (segment index 0), we should quickly bail out.\n  // Previously, this was determined by tColor.a, which was incorrect as it\n  // prevented the outline from appearing when the fill is 0.\n  if (segmentIndex == 0) {\n    return vec4(0, 0, 0, 0);\n  }\n\n  // Only perform outline check on fragments rendering voxels that aren't\n  // invisible. Saves a bunch of needless checks on the background.\n  // TODO define epsilon when building shader?\n  for (int i = -actualThickness; i <= actualThickness; i++) {\n    for (int j = -actualThickness; j <= actualThickness; j++) {\n      if (i == 0 || j == 0) {\n        continue;\n      }\n\n      vec4 neighborPixelCoord =\n          vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j),\n               gl_FragCoord.z, gl_FragCoord.w);\n\n      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n      vec4 value = getTextureValue(neighborPosIS);\n\n      // If any of my neighbours are not the same value as I\n      // am, this means I am on the border of the segment.\n      // We can break the loops\n      if (any(notEqual(value, centerValue))) {\n        pixelOnBorder = true;\n        break;\n      }\n    }\n\n    if (pixelOnBorder == true) {\n      break;\n    }\n  }\n\n  // If I am on the border, I am displayed at full opacity\n  if (pixelOnBorder == true) {\n    tColor.a = volume.outlineOpacity;\n  }\n\n  return tColor;\n}\n\nvec4 getColorForAdditivePreset(vec4 tValue, vec3 posVC, vec3 posIS) {\n  // compute normals\n  mat4 normalMat = computeMat4Normal(posIS, tValue);\n  vec4 normalLights[2];\n  normalLights[0] = normalMat[0];\n  normalLights[1] = normalMat[1];\n  #if vtkNumberOfLights > 0\n    if (volume.computeNormalFromOpacity == 1) {\n      for (int component = 0; component < 2; ++component) {\n        vec3 scalarInterp[2];\n        float height = volume.transferFunctionsSampleHeight[component];\n        computeNormalForDensity(posIS, scalarInterp, component);\n        normalLights[component] =\n            computeDensityNormal(scalarInterp, height, 1.0, component);\n      }\n    }\n  #endif\n\n  // compute opacities\n  float opacities[2];\n  opacities[0] = getOpacityFromTexture(\n      tValue[0], 0, volume.transferFunctionsSampleHeight[0]);\n  opacities[1] = getOpacityFromTexture(\n      tValue[1], 1, volume.transferFunctionsSampleHeight[1]);\n  #ifdef EnabledGradientOpacity\n    for (int component = 0; component < 2; ++component) {\n      opacities[component] *=\n          computeGradientOpacityFactor(normalMat[component].a, component);\n    }\n  #endif\n  float opacitySum = opacities[0] + opacities[1];\n  if (opacitySum <= 0.0) {\n    return vec4(0.0);\n  }\n\n  // mix the colors and opacities\n  vec3 colors[2];\n  for (int component = 0; component < 2; ++component) {\n    float sampleHeight = volume.transferFunctionsSampleHeight[component];\n    vec3 color = getColorFromTexture(tValue[component], component, sampleHeight);\n    color = applyAllLightning(color, opacities[component], posVC,\n                              normalLights[component]);\n    colors[component] = color;\n  }\n  vec3 mixedColor =\n      (opacities[0] * colors[0] + opacities[1] * colors[1]) / opacitySum;\n  return vec4(mixedColor, min(1.0, opacitySum));\n}\n\nvec4 getColorForColorizePreset(vec4 tValue, vec3 posVC, vec3 posIS) {\n  // compute normals\n  mat4 normalMat = computeMat4Normal(posIS, tValue);\n  vec4 normalLight = normalMat[0];\n  #if vtkNumberOfLights > 0\n    if (volume.computeNormalFromOpacity == 1) {\n      vec3 scalarInterp[2];\n      float height = volume.transferFunctionsSampleHeight[0];\n      computeNormalForDensity(posIS, scalarInterp, 0);\n      normalLight = computeDensityNormal(scalarInterp, height, 1.0, 0);\n    }\n  #endif\n\n  // compute opacities\n  float opacity = getOpacityFromTexture(\n      tValue[0], 0, volume.transferFunctionsSampleHeight[0]);\n  #ifdef EnabledGradientOpacity\n    opacity *= computeGradientOpacityFactor(normalMat[0].a, 0);\n  #endif\n\n  // colorizing component\n  vec3 colorizingColor = getColorFromTexture(\n      tValue[0], 1, volume.transferFunctionsSampleHeight[1]);\n  float colorizingOpacity = getOpacityFromTexture(\n      tValue[1], 1, volume.transferFunctionsSampleHeight[1]);\n\n  // mix the colors and opacities\n  vec3 color =\n      getColorFromTexture(tValue[0], 0,\n                          volume.transferFunctionsSampleHeight[0]) *\n      mix(vec3(1.0), colorizingColor, colorizingOpacity);\n  color = applyAllLightning(color, opacity, posVC, normalLight);\n  return vec4(color, opacity);\n}\n\nvec4 getColorForDefaultIndependentPreset(vec4 tValue, vec3 posIS) {\n\n  // compute the normal vectors as needed\n  #if defined(EnabledGradientOpacity) || vtkNumberOfLights > 0\n    mat4 normalMat = computeMat4Normal(posIS, tValue);\n  #endif\n\n  // process color and opacity for each component\n  // initial value of alpha is determined by wether the first component is\n  // proportional or not\n  #if defined(vtkComponent0Proportional)\n    // when it is proportional, it starts at 1 (neutral for multiplications)\n    float alpha = 1.0;\n  #else\n    // when it is not proportional, it starts at 0 (neutral for additions)\n    float alpha = 0.0;\n  #endif\n\n  vec3 mixedColor = vec3(0.0);\n  #if vtkNumberOfComponents > 0\n    {\n      const int component = 0;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent0Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 1\n    {\n      const int component = 1;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent1Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 2\n    {\n      const int component = 2;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent2Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 3\n    {\n      const int component = 3;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent3Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n\n  return vec4(mixedColor, alpha);\n}\n\nvec4 getColorForDependentComponents(vec4 tValue, vec3 posVC, vec3 posIS) {\n  #if defined(EnabledGradientOpacity) || vtkNumberOfLights > 0\n    // use component 3 of the opacity texture as getTextureValue() sets alpha to\n    // the opacity value\n    vec3 scalarInterp[2];\n    vec4 normal0 = computeNormalForDensity(posIS, scalarInterp, 3);\n    float gradientOpacity = computeGradientOpacityFactor(normal0.a, 0);\n  #endif\n\n  // get color and opacity\n  #if vtkNumberOfComponents == 1\n    vec3 tColor = getColorFromTexture(tValue.r, 0, 0.5);\n    float alpha = getOpacityFromTexture(tValue.r, 0, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 2\n    vec3 tColor = vec3(tValue.r * volume.colorTextureScale[0] +\n                  volume.colorTextureShift[0]);\n    float alpha = getOpacityFromTexture(tValue.a, 1, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 3\n      vec3 tColor = tValue.rgb * volume.colorTextureScale.rgb +\n              volume.colorTextureShift.rgb;\n      float alpha = getOpacityFromTexture(tValue.a, 0, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 4\n      vec3 tColor = tValue.rgb * volume.colorTextureScale.rgb +\n              volume.colorTextureShift.rgb;\n      float alpha = getOpacityFromTexture(tValue.a, 3, 0.5);\n  #endif\n\n  // Apply gradient opacity\n  #if defined(EnabledGradientOpacity)\n    alpha *= gradientOpacity;\n  #endif\n\n  #if vtkNumberOfComponents == 1\n    if (alpha < EPSILON) {\n      return vec4(0.0);\n    }\n  #endif\n\n  // lighting\n  #if vtkNumberOfLights > 0\n    vec4 normalLight;\n    if (volume.computeNormalFromOpacity == 1) {\n      if (normal0[3] != 0.0) {\n        normalLight =\n            computeDensityNormal(scalarInterp, 0.5, gradientOpacity, 0);\n        if (normalLight[3] == 0.0) {\n          normalLight = normal0;\n        }\n      }\n    } else {\n      normalLight = normal0;\n    }\n    tColor = applyAllLightning(tColor, alpha, posVC, normalLight);\n  #endif\n\n  return vec4(tColor, alpha);\n}\n\nvec4 getColorForValue(vec4 tValue, vec3 posVC, vec3 posIS) {\n  #ifdef EnableColorForValueFunctionId0\n    return getColorForDependentComponents(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId1\n    return getColorForAdditivePreset(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId2\n    return getColorForColorizePreset(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId3\n    /*\n      * Mix the color information from all the independent components to get a\n      * single rgba output. See other shader functions like\n      * `getColorForAdditivePreset` to learn how to create a custom color mix.\n      * The custom color mix should return a value, but if it doesn't, it will\n      * fallback on the default shading\n      */\n    //VTK::CustomColorMix\n  #endif\n\n  #if defined(EnableColorForValueFunctionId4) || defined(EnableColorForValueFunctionId3)\n    return getColorForDefaultIndependentPreset(tValue, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId5\n    return getColorForLabelOutline();\n  #endif\n}\n\nbool valueWithinScalarRange(vec4 val) {\n  #if vtkNumberOfComponents > 1 && !defined(EnabledIndependentComponents)\n    return false;\n  #endif\n  vec4 rangeMin = volume.ipScalarRangeMin;\n  vec4 rangeMax = volume.ipScalarRangeMax;\n  for (int component = 0; component < vtkNumberOfComponents; ++component) {\n    if (val[component] < rangeMin[component] ||\n        rangeMax[component] < val[component]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n#if vtkBlendMode == LABELMAP_EDGE_PROJECTION_BLEND\n  bool checkOnEdgeForNeighbor(int xFragmentOffset, int yFragmentOffset,\n                              int segmentIndex, vec3 stepIS) {\n    vec3 volumeDimensions = vec3(volume.dimensions);\n    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(xFragmentOffset),\n                                  gl_FragCoord.y + float(yFragmentOffset),\n                                  gl_FragCoord.z, gl_FragCoord.w);\n    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n\n    vec3 neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < vtkMaximumNumberOfSamples / 2; ++k) {\n      ivec3 texCoord = ivec3(neighborPosIS * volumeDimensions);\n      vec4 texValue = rawFetchTexture(texCoord);\n      if (int(texValue.g) == segmentIndex) {\n        // not on edge\n        return false;\n      }\n      neighborPosIS += stepIS;\n    }\n\n    neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < vtkMaximumNumberOfSamples / 2; ++k) {\n      ivec3 texCoord = ivec3(neighborPosIS * volumeDimensions);\n      vec4 texValue = rawFetchTexture(texCoord);\n      if (int(texValue.g) == segmentIndex) {\n        // not on edge\n        return false;\n      }\n      neighborPosIS -= stepIS;\n    }\n\n    // onedge\n    float sampleHeight = volume.transferFunctionsSampleHeight[1];\n    vec3 tColorSegment =\n        getColorFromTexture(float(segmentIndex), 1, sampleHeight);\n    float pwfValueSegment =\n        getOpacityFromTexture(float(segmentIndex), 1, sampleHeight);\n    gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);\n    return true;\n  }\n#endif\n\nvec4 getColorAtPos(vec3 posVC) {\n  vec3 posIS = posVCtoIS(posVC);\n  vec4 texValue = getTextureValue(posIS);\n  return getColorForValue(texValue, posVC, posIS);\n}\n\n//=======================================================================\n// Apply the specified blend mode operation along the ray's path.\n//\nvoid applyBlend(vec3 rayOriginVC, vec3 rayDirVC, float minDistance,\n                float maxDistance) {\n  // start slightly inside and apply some jitter\n  vec3 stepVC = rayDirVC * sampleDistance;\n  float raySteps = (maxDistance - minDistance) / sampleDistance;\n\n  // Avoid 0.0 jitter\n  float jitter = 0.01 + 0.99 * fragmentSeed;\n\n  #if vtkBlendMode == COMPOSITE_BLEND\n    // now map through opacity and color\n    vec3 firstPosVC = rayOriginVC + minDistance * rayDirVC;\n    vec4 firstColor = getColorAtPos(firstPosVC);\n\n    // handle very thin volumes\n    if (raySteps <= 1.0) {\n      firstColor.a = 1.0 - pow(1.0 - firstColor.a, raySteps);\n      gl_FragData[0] = firstColor;\n      return;\n    }\n\n    // first color only counts for `jitter` factor of the step\n    firstColor.a = 1.0 - pow(1.0 - firstColor.a, jitter);\n    vec4 color = vec4(firstColor.rgb * firstColor.a, firstColor.a);\n    vec3 posVC = firstPosVC + jitter * stepVC;\n    float stepsTraveled = jitter;\n\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n      vec4 tColor = getColorAtPos(posVC);\n\n      color = color + vec4(tColor.rgb * tColor.a, tColor.a) * (1.0 - color.a);\n      stepsTraveled++;\n      posVC += stepVC;\n      if (color.a > 0.99) {\n        color.a = 1.0;\n        break;\n      }\n    }\n\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0) {\n      vec3 endPosVC = rayOriginVC + maxDistance * rayDirVC;\n      vec4 tColor = getColorAtPos(endPosVC);\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\n\n      float mix = (1.0 - color.a);\n      color = color + vec4(tColor.rgb * tColor.a, tColor.a) * mix;\n    }\n\n    gl_FragData[0] = vec4(color.rgb / color.a, color.a);\n  #endif\n\n  #if vtkBlendMode == MAXIMUM_INTENSITY_BLEND ||                                 \\\n      vtkBlendMode == MINIMUM_INTENSITY_BLEND\n    // Find maximum/minimum intensity along the ray.\n\n    // Define the operation we will use (min or max)\n    #if vtkBlendMode == MAXIMUM_INTENSITY_BLEND\n      #define OP max\n    #else\n      #define OP min\n    #endif\n\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    // Find a value to initialize the selected variables\n    vec4 selectedValue;\n    vec3 selectedPosVC;\n    vec3 selectedPosIS;\n    {\n      vec3 posIS = posVCtoIS(posVC);\n      selectedValue = getTextureValue(posIS);\n      selectedPosVC = posVC;\n      selectedPosIS = posIS;\n    }\n\n    // If the clipping range is shorter than the sample distance\n    // we can skip the sampling loop along the ray.\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(selectedValue, selectedPosVC, selectedPosIS);\n      return;\n    }\n\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      // Get selected values\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 previousSelectedValue = selectedValue;\n      vec4 currentValue = getTextureValue(posIS);\n      selectedValue = OP(selectedValue, currentValue);\n      if (previousSelectedValue != selectedValue) {\n        selectedPosVC = posVC;\n        selectedPosIS = posIS;\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posVC += stepVC;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posVC = rayOriginVC + maxDistance * rayDirVC;\n    {\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 previousSelectedValue = selectedValue;\n      vec4 currentValue = getTextureValue(posIS);\n      selectedValue = OP(selectedValue, currentValue);\n      if (previousSelectedValue != selectedValue) {\n        selectedPosVC = posVC;\n        selectedPosIS = posIS;\n      }\n    }\n\n    gl_FragData[0] = getColorForValue(selectedValue, selectedPosVC, selectedPosIS);\n  #endif\n\n  #if vtkBlendMode == ADDITIVE_INTENSITY_BLEND ||                                \\\n      vtkBlendMode == AVERAGE_INTENSITY_BLEND\n    vec4 sum = vec4(0.);\n    #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n      float totalWeight = 0.0;\n    #endif\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    vec3 posIS = posVCtoIS(posVC);\n    vec4 value = getTextureValue(posIS);\n\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(value * raySteps, posVC, posIS);\n      return;\n    }\n\n    if (valueWithinScalarRange(value)) {\n      sum += value * jitter;\n      #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n        totalWeight += jitter;\n      #endif\n    }\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      posIS = posVCtoIS(posVC);\n      value = getTextureValue(posIS);\n      // One can control the scalar range by setting the AverageIPScalarRange to\n      // disregard scalar values, not in the range of interest, from the average\n      // computation. Notes:\n      // - We are comparing all values in the texture to see if any of them\n      //   are outside of the scalar range. In the future we might want to allow\n      //   scalar ranges for each component.\n      if (valueWithinScalarRange(value)) {\n        sum += value;\n        #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n          totalWeight++;\n        #endif\n      }\n\n      stepsTraveled++;\n      posVC += stepVC;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posVC = rayOriginVC + maxDistance * rayDirVC;\n    posIS = posVCtoIS(posVC);\n    value = getTextureValue(posIS);\n    if (valueWithinScalarRange(value)) {\n      sum += value;\n      #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n        totalWeight += raySteps - stepsTraveled;\n      #endif\n    }\n\n    #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n      sum /= vec4(totalWeight, totalWeight, totalWeight, 1.0);\n    #endif\n\n    gl_FragData[0] = getColorForValue(sum, posVC, posIS);\n  #endif\n\n  #if vtkBlendMode == RADON_TRANSFORM_BLEND\n    float normalizedRayIntensity = 1.0;\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    // handle very thin volumes\n    if (raySteps <= 1.0) {\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 tValue = getTextureValue(posIS);\n      normalizedRayIntensity -= raySteps * sampleDistance *\n                                getOpacityFromTexture(tValue.r, 0, 0.5);\n      gl_FragData[0] =\n          vec4(getColorFromTexture(normalizedRayIntensity, 0, 0.5), 1.0);\n      return;\n    }\n\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 value = getTextureValue(posIS);\n      // Convert scalar value to normalizedRayIntensity coefficient and\n      // accumulate normalizedRayIntensity\n      normalizedRayIntensity -=\n          sampleDistance * getOpacityFromTexture(value.r, 0, 0.5);\n\n      posVC += stepVC;\n      stepsTraveled++;\n    }\n\n    // map normalizedRayIntensity to color\n    gl_FragData[0] =\n        vec4(getColorFromTexture(normalizedRayIntensity, 0, 0.5), 1.0);\n  #endif\n\n  #if vtkBlendMode == LABELMAP_EDGE_PROJECTION_BLEND\n    // Only works with a single volume\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n    vec3 posIS = posVCtoIS(posVC);\n    vec4 tValue = getTextureValue(posIS);\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(tValue, posVC, posIS);\n      return;\n    }\n\n    vec3 stepIS = vecVCToIS(stepVC);\n    vec4 value = tValue;\n    posIS += jitter * stepIS;\n    stepsTraveled += jitter;\n    vec3 maxPosIS = posIS; // Store the position of the max value\n    int segmentIndex = int(value.g);\n    bool originalPosHasSeenNonZero = false;\n\n    if (segmentIndex != 0) {\n      // Tried using the segment index in an boolean array but reading\n      // from the array by dynamic indexing was horrondously slow\n      // so use bit masking instead and assign 1 to the bit corresponding to the\n      // segment index and later check if the bit is set via bit operations\n      setLabelOutlineBit(segmentIndex);\n    }\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n      segmentIndex = int(tValue.g);\n\n      if (segmentIndex != 0) {\n        originalPosHasSeenNonZero = true;\n        setLabelOutlineBit(segmentIndex);\n      }\n\n      if (tValue.r > value.r) {\n        value = tValue;   // Update the max value\n        maxPosIS = posIS; // Update the position where max occurred\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = posVCtoIS(rayOriginVC + maxDistance * rayDirVC);\n    tValue = getTextureValue(posIS);\n\n    if (tValue.r > value.r) {\n      value = tValue;   // Update the max value\n      maxPosIS = posIS; // Update the position where max occurred\n    }\n\n    // If we have not seen any non-zero segments, we can return early\n    // and grab color from the actual center value first component (image)\n    if (!originalPosHasSeenNonZero) {\n      vec3 maxPosVC = posIStoVC(maxPosIS);\n      gl_FragData[0] = getColorForValue(value, maxPosVC, maxPosIS);\n      return;\n    }\n\n    vec3 neighborRayStepsIS = stepIS;\n    float neighborRaySteps = raySteps;\n    bool shouldLookInAllNeighbors = false;\n\n    vec3 volumeSpacings = volume.spacing;\n    float minVoxelSpacing =\n        min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));\n    vec4 base =\n        vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z,\n                          gl_FragCoord.w);\n    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z,\n                          gl_FragCoord.w);\n\n    vec3 baseWorld = fragCoordToWorld(base);\n    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);\n    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);\n\n    float XPlusDiff = length(baseXPlusWorld - baseWorld);\n    float YPlusDiff = length(baseYPlusWorld - baseWorld);\n\n    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);\n\n    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {\n      // bail out quickly if the segment index has not\n      // been seen by the center segment\n      if (!isLabelOutlineBitSet(s)) {\n        continue;\n      }\n\n      // Use texture sampling for outlineThickness so that we can have\n      // per segment thickness\n      float textureCoordinate = float(s - 1) / 1024.0;\n      float textureValue =\n          texture2D(labelOutlineThicknessTexture, vec2(textureCoordinate, 0.5)).r;\n\n      int actualThickness = int(textureValue * 255.0);\n\n      // check the extreme points in the neighborhood since there is a better\n      // chance of finding the edge there, so that we can bail out\n      // faster if we find the edge\n      bool onEdge = checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(actualThickness, actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(actualThickness, -actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s,\n                                          stepIS);\n\n      if (onEdge) {\n        return;\n      }\n\n      // since the next step is computationally expensive, we need to perform\n      // some optimizations to avoid it if possible. One of the optimizations\n      // is to check the whether the minimum of the voxel spacing is greater than\n      // the 2 * the thickness of the outline segment. If that is the case\n      // then we can safely skip the next step since we can be sure that the\n      // the previous 4 checks on the extreme points would caught the entirety\n      // of the all the fragments inside. i.e., this happens when we zoom out,\n      if (minVoxelSpacing >\n          (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {\n        continue;\n      }\n\n      // Loop through the rest, skipping the processed extremes and the center\n      for (int i = -actualThickness; i <= actualThickness; i++) {\n        for (int j = -actualThickness; j <= actualThickness; j++) {\n          if (i == 0 && j == 0)\n            continue; // Skip the center\n          if (abs(i) == actualThickness && abs(j) == actualThickness)\n            continue; // Skip corners\n          if (checkOnEdgeForNeighbor(i, j, s, stepIS)) {\n            return;\n          }\n        }\n      }\n    }\n\n    float sampleHeight = volume.transferFunctionsSampleHeight[0];\n    vec3 tColor0 = getColorFromTexture(value.r, 0, sampleHeight);\n    float pwfValue0 = getOpacityFromTexture(value.r, 0, sampleHeight);\n    gl_FragData[0] = vec4(tColor0, pwfValue0);\n  #endif\n}\n\n//=======================================================================\n// given a\n// - ray direction (rayDir)\n// - starting point (vertexVCVSOutput)\n// - bounding planes of the volume\n// - optionally depth buffer values\n// - far clipping plane\n// compute the start/end distances of the ray we need to cast\nvec2 computeRayDistances(vec3 rayOriginVC, vec3 rayDirVC) {\n  vec2 dists = rayIntersectVolumeDistances(rayOriginVC, rayDirVC);\n\n  //VTK::ClipPlane::Impl\n\n  // do not go behind front clipping plane\n  dists.x = max(0.0, dists.x);\n\n  // do not go PAST far clipping plane\n  float farDist = -camThick / rayDirVC.z;\n  dists.y = min(farDist, dists.y);\n\n  // Do not go past the zbuffer value if set\n  // This is used for intermixing opaque geometry\n  //VTK::ZBuffer::Impl\n\n  return dists;\n}\n\nfloat getFragmentSeed() {\n  // This first noise has a diagonal pattern\n  float firstNoise =\n      fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n  // This second noise is made out of blocks of CPU generated noise\n  float secondNoise = texture2D(jtexture, gl_FragCoord.xy / 32.0).r;\n  // Combine the two sources of noise in a way that the distribution is uniform\n  // in [0,1[\n  float noiseSum = firstNoise + secondNoise;\n  return noiseSum < 1.0 ? noiseSum : noiseSum - 1.0;\n}\n\nvoid main() {\n  fragmentSeed = getFragmentSeed();\n\n  if (cameraParallel == 1) {\n    // Camera is parallel, so the rayDir is just the direction of the camera.\n    rayDirVC = vec3(0.0, 0.0, -1.0);\n  } else {\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\n    rayDirVC = normalize(vertexVCVSOutput);\n  }\n\n  vec3 rayOriginVC = vertexVCVSOutput;\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayOriginVC, rayDirVC);\n  if (rayStartEndDistancesVC[1] <= rayStartEndDistancesVC[0] ||\n      rayStartEndDistancesVC[1] <= 0.0) {\n    // Volume not hit or behind the ray\n    discard;\n  }\n\n  // Perform the blending operation along the ray\n  applyBlend(rayOriginVC, rayDirVC, rayStartEndDistancesVC[0], rayStartEndDistancesVC[1]);\n}\n",e.Geometry=""},e.replaceShaderValues=(e,n,r)=>{let o=e.Fragment;o=wu.substitute(o,"//VTK::EnabledColorFunctions",`#define EnableColorForValueFunctionId${t.previousState.colorForValueFunctionId}`).result;const a=[];t.previousState.surfaceLightingEnabled&&a.push("Surface"),t.previousState.volumeLightingEnabled&&a.push("Volume"),o=wu.substitute(o,"//VTK::EnabledLightings",a.map((e=>`#define Enable${e}Lighting`))).result,t.previousState.multiTexturePerVolumeEnabled&&(o=wu.substitute(o,"//VTK::EnabledMultiTexturePerVolume","#define EnabledMultiTexturePerVolume").result),t.previousState.useIndependentComponents&&(o=wu.substitute(o,"//VTK::EnabledIndependentComponents","#define EnabledIndependentComponents").result),t.previousState.gradientOpacityEnabled&&(o=wu.substitute(o,"//VTK::EnabledGradientOpacity","#define EnabledGradientOpacity").result),o=wu.substitute(o,"//VTK::vtkProportionalComponents",t.previousState.proportionalComponents.map((e=>`#define vtkComponent${e}Proportional`)).join("\n")).result,o=wu.substitute(o,"//VTK::vtkForceNearestComponents",t.previousState.forceNearestComponents.map((e=>`#define vtkComponent${e}ForceNearest`)).join("\n")).result,t.previousState.hasZBufferTexture&&(o=wu.substitute(o,"//VTK::ZBuffer::Dec",["uniform sampler2D zBufferTexture;","uniform float vpZWidth;","uniform float vpZHeight;"]).result,o=wu.substitute(o,"//VTK::ZBuffer::Impl",["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));","float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;","zdepth = zdepth * 2.0 - 1.0;","if (cameraParallel == 0) {","zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}","else {","zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\n","zdepth = -zdepth/rayDirVC.z;","dists.y = min(zdepth,dists.y);"]).result),o=wu.substitute(o,"//VTK::BlendMode",`${t.previousState.blendMode}`).result,o=wu.substitute(o,"//VTK::NumberOfLights",`${t.previousState.numberOfLights}`).result,o=wu.substitute(o,"//VTK::MaxLaoKernelSize",`${t.previousState.maxLaoKernelSize}`).result,o=wu.substitute(o,"//VTK::NumberOfComponents",`${t.previousState.numberOfComponents}`).result,o=wu.substitute(o,"//VTK::MaximumNumberOfSamples",`${t.previousState.maximumNumberOfSamples}`).result,e.Fragment=o;const i=t.previousState.numberOfClippingPlanes;i>0&&(o=wu.substitute(o,"//VTK::ClipPlane::Dec",["uniform vec3 vClipPlaneNormals[6];","uniform float vClipPlaneDistances[6];","uniform vec3 vClipPlaneOrigins[6];","uniform int clip_numPlanes;","//VTK::ClipPlane::Dec","#define vtkClippingPlanesOn"],!1).result,o=wu.substitute(o,"//VTK::ClipPlane::Impl",[`for(int i = 0; i < ${i}; i++) {`,"  float rayDirRatio = dot(rayDirVC, vClipPlaneNormals[i]);","  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];","  if (rayDirRatio == 0.0)","  {","    if (equationResult < 0.0) dists.x = dists.y;","    continue;","  }","  float result = -1.0 * equationResult / rayDirRatio;","  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);","  else dists.x = max(dists.x, result);","}","//VTK::ClipPlane::Impl"],!1).result),e.Fragment=o},e.getNeedToRebuildShaders=(r,o,a)=>{const i=!!t.zBufferTexture,s=t.currentValidInputs.length,l=t.numberOfLights,c=t.numberOfComponents,u=t.useIndependentComponents,d=a.getProperties(),p=t.currentValidInputs[0],f=d[p.inputIndex],g=s>1,m=p.imageData.getBounds(),h=Fi.getDiagonalLength(m),v=Math.ceil(h/e.getCurrentSampleDistance(o));v>t.renderable.getMaximumSamplesPerRay()&&Pf(`The number of steps required ${v} is larger than the specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\nPlease either change the volumeMapper sampleDistance or its maximum number of samples.`);const T=u?c:1;let y=!1;for(let e=0;e<T;++e)if(f.getUseGradientOpacity(e)){y=!0;break}let b=0;const x=f.getLAOKernelSize();x>b&&f.getLocalAmbientOcclusion()&&f.getAmbient()>0&&(b=x);const C=t.renderable.getClippingPlanes().length,S=t.renderable.getViewSpecificProperties().OpenGL?.ShaderReplacements,A=t.currentRenderPass?.getShaderReplacement(),I=t.renderable.getBlendMode(),w=(()=>{if(I!==wf.LABELMAP_EDGE_PROJECTION_BLEND&&n(f))return 5;if(u)switch(f.getColorMixPreset()){case Af.ADDITIVE:return 1;case Af.COLORIZE:return 2;case Af.CUSTOM:return 3;default:return 4}return 0})(),O=f.getVolumetricScatteringBlending()<1,P=f.getVolumetricScatteringBlending()>0;let R=!1;for(let e=0;e<c;++e)if(f.getForceNearestInterpolation(e)){R=!0;break}const M=[],E=[];for(let e=0;e<c;e++)f.getOpacityMode(e)===Sf.PROPORTIONAL&&M.push(e),f.getForceNearestInterpolation(e)&&E.push(e);const V={numberOfComponents:c,useIndependentComponents:u,proportionalComponents:M,forceNearestComponents:E,blendMode:I,numberOfLights:l,numberOfValidInputs:s,maximumNumberOfSamples:v,hasZBufferTexture:i,maxLaoKernelSize:b,numberOfClippingPlanes:C,mapperShaderReplacements:S,renderPassShaderReplacements:A,colorForValueFunctionId:w,surfaceLightingEnabled:O,volumeLightingEnabled:P,forceNearestInterpolationEnabled:R,multiTexturePerVolumeEnabled:g,gradientOpacityEnabled:y};return!(0!==r.getProgram()?.getHandle()&&t.previousState&&ke()(t.previousState,V)||(t.previousState=V,0))},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexDC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexDC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Rf("Error setting vertexDC in shader VAO.")),n.getAttributeUpdateTime().modified());const i=e.getCurrentSampleDistance(r);a.setUniformf("sampleDistance",i);const s=i*t.renderable.getVolumeShadowSamplingDistFactor();a.setUniformf("volumeShadowSampleDistance",s),t.scalarTextures.forEach(((e,t)=>{a.setUniformi(`volumeTexture[${t}]`,e.getTextureUnit())}));const l=o.getProperties()[t.currentValidInputs[0].inputIndex].getIpScalarRange(),c=new Float32Array(4),u=new Float32Array(4),d=(e,t,n)=>{t?.dataComputedScale?.length&&(c[e]=l[0]*t.dataComputedScale[n]+t.dataComputedOffset[n],u[e]=l[1]*t.dataComputedScale[n]+t.dataComputedOffset[n],c[e]=(c[e]-t.offset[n])/t.scale[n],u[e]=(u[e]-t.offset[n])/t.scale[n])};if(t.previousState.multiTexturePerVolumeEnabled)t.scalarTextures.forEach(((e,t)=>{const n=e.getVolumeInfo();d(t,n,0)}));else{const e=t.scalarTextures[0].getVolumeInfo();for(let t=0;t<4;++t)d(t,e,t)}const p="volume";if(a.setUniform4f(`${p}.ipScalarRangeMin`,c[0],c[1],c[2],c[3]),a.setUniform4f(`${p}.ipScalarRangeMax`,u[0],u[1],u[2],u[3]),null!==t.zBufferTexture){a.setUniformi("zBufferTexture",t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf("vpZWidth",e[0]),a.setUniformf("vpZHeight",e[1])}},e.setCameraShaderParameters=(r,o,a)=>{const{idxToView:i,vecISToVCMatrix:s,modelToView:l,projectionToView:c,projectionToWorld:u}=Mf,d=t.openGLCamera.getKeyMatrices(o),p=t.openGLVolume.getKeyMatrices();y(l,d.wcvc,p.mcwc);const f=r.getProgram(),g=t.openGLCamera.getRenderable(),m=g.getParallelProjection(),v=g.getClippingRange();f.setUniformf("camThick",v[1]-v[0]),f.setUniformf("camNear",v[0]),f.setUniformf("camFar",v[1]),f.setUniformi("cameraParallel",m);const T=t.currentValidInputs[0],b=T.imageData.getBounds(),x=Fi.getCorners(b,[]).map((e=>(wn(e,e,l),m||xn(e,e,-v[0]/(e[2]*mn(e))),wn(e,e,d.vcpc),e))),C=Fi.addPoints([...Fi.INIT_BOUNDS],x);f.setUniformf("dcxmin",C[0]),f.setUniformf("dcxmax",C[1]),f.setUniformf("dcymin",C[2]),f.setUniformf("dcymax",C[3]);const S=e.getRenderTargetSize();f.setUniformf("vpWidth",S[0]),f.setUniformf("vpHeight",S[1]);const A=e.getRenderTargetOffset();f.setUniformf("vpOffsetX",A[0]/S[0]),f.setUniformf("vpOffsetY",A[1]/S[1]),h(c,d.vcpc),f.setUniformMatrix("PCVCMatrix",c),f.setUniformi("twoSidedLighting",o.getTwoSidedLighting());const I=new Array(2*t.previousState.maxLaoKernelSize);for(let e=0;e<t.previousState.maxLaoKernelSize;e++)I[2*e]=Math.random(),I[2*e+1]=Math.random();if(f.setUniform2fv("kernelSample",I),t.numberOfLights>0){let e=0;o.getLights().forEach((t=>{if(t.getSwitch()>0){const n=`lights[${e}]`,r=xn([],t.getColor(),t.getIntensity());f.setUniform3fv(`${n}.color`,r);const o=t.getTransformedPosition();wn(o,o,l),f.setUniform3fv(`${n}.positionVC`,o);const a=[...t.getDirection()];On(a,a,d.normalMatrix),Sn(a,a),f.setUniform3fv(`${n}.directionVC`,a);const i=[-.5*a[0],-.5*a[1],-.5*(a[2]-1)];f.setUniform3fv(`${n}.halfAngleVC`,i);const s=t.getAttenuationValues();f.setUniform3fv(`${n}.attenuation`,s);const c=t.getExponent();f.setUniformf(`${n}.exponent`,c);const u=t.getConeAngle();f.setUniformf(`${n}.coneAngle`,u);const p=t.getPositional();f.setUniformi(`${n}.isPositional`,p),e++}}))}const w="volume",O=a.getProperties()[T.inputIndex],P=T.imageData,R=P.getSpatialExtent(),M=P.getSpacing(),E=P.getDimensions(),V=P.getIndexToWorld(),D=P.getWorldToIndex(),L=P.getDirectionByReference();y(i,l,V),f.setUniform3fv(`${w}.spacing`,M);const B=Cn([],M);f.setUniform3fv(`${w}.inverseSpacing`,B),f.setUniform3iv(`${w}.dimensions`,E),f.setUniform3fv(`${w}.inverseDimensions`,Cn([],E)),f.setUniformMatrix(`${w}.worldToIndex`,D),s.fill(0);const N=bn(new Float64Array(3),E,M);s[0]=N[0],s[4]=N[1],s[8]=N[2],ve(s,L,s),ve(s,p.normalMatrix,s),ve(s,d.normalMatrix,s),f.setUniformMatrix3x3(`${w}.vecISToVCMatrix`,s),f.setUniformMatrix3x3(`${w}.vecVCToISMatrix`,ge(new Float32Array(9),s));const F=hn(R[0],R[2],R[4]),_=wn(new Float64Array(3),F,i);f.setUniform3fv(`${w}.originVC`,_);const k=mn(N);if(f.setUniformf(`${w}.diagonalLength`,k),n(O)){const e=g.getDistance();g.setClippingRange(e,e+.1),h(u,t.openGLCamera.getKeyMatrices(o).wcpc),g.setClippingRange(v[0],v[1]),t.openGLCamera.getKeyMatrices(o),f.setUniformMatrix(`${w}.PCWCMatrix`,u)}if(O.getVolumetricScatteringBlending()>0&&(f.setUniformf(`${w}.globalIlluminationReach`,O.getGlobalIlluminationReach()),f.setUniformf(`${w}.volumetricScatteringBlending`,O.getVolumetricScatteringBlending()),f.setUniformf(`${w}.anisotropy`,O.getAnisotropy()),f.setUniformf(`${w}.anisotropySquared`,O.getAnisotropy()**2)),O.getLocalAmbientOcclusion()&&O.getAmbient()>0){const e=O.getLAOKernelSize();f.setUniformi(`${w}.kernelSize`,e);const t=O.getLAOKernelRadius();f.setUniformi(`${w}.kernelRadius`,t)}else f.setUniformi(`${w}.kernelSize`,0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();o.setUniformi("jtexture",t.jitterTexture.getTextureUnit());const a=r.getProperties();o.setUniformi("labelOutlineThicknessTexture",t.labelOutlineThicknessTexture.getTextureUnit()),o.setUniformi("opacityTexture",t.opacityTexture.getTextureUnit()),o.setUniformi("colorTexture",t.colorTexture.getTextureUnit());const i="volume",s=a[t.currentValidInputs[0].inputIndex],l=t.previousState.numberOfComponents,c=t.previousState.useIndependentComponents;if(c){const e=new Float32Array(4);for(let t=0;t<l;t++)e[t]=s.getComponentWeight(t);o.setUniform4fv(`${i}.independentComponentMix`,e);const t=new Float32Array(4),n=1/l;for(let e=0;e<l;++e)t[e]=(e+.5)*n;o.setUniform4fv(`${i}.transferFunctionsSampleHeight`,t)}const u=t.colorForValueFunctionId;o.setUniformi(`${i}.colorForValueFunctionId`,u);const d=s.getComputeNormalFromOpacity();o.setUniformi(`${i}.computeNormalFromOpacity`,d);const p=new Float32Array(4),f=new Float32Array(4),g=new Float32Array(4),m=new Float32Array(4);for(let e=0;e<l;e++){const n=t.previousState.multiTexturePerVolumeEnabled,r=n?e:0,o=n?0:e,a=t.scalarTextures[r].getVolumeInfo(),i=c?e:0,l=a.scale[o],u=s.getRGBTransferFunction(i).getRange();p[e]=l/(u[1]-u[0]),f[e]=(a.offset[o]-u[0])/(u[1]-u[0]);const d=s.getScalarOpacity(i).getRange();g[e]=l/(d[1]-d[0]),m[e]=(a.offset[o]-d[0])/(d[1]-d[0])}if(o.setUniform4fv(`${i}.colorTextureScale`,p),o.setUniform4fv(`${i}.colorTextureShift`,f),o.setUniform4fv(`${i}.opacityTextureScale`,g),o.setUniform4fv(`${i}.opacityTextureShift`,m),t.previousState.gradientOpacityEnabled){const e=new Array(4),n=new Array(4),r=new Array(4),a=new Array(4);if(c)for(let o=0;o<l;++o){const i=t.previousState.multiTexturePerVolumeEnabled,l=i?o:0,c=i?0:o,u=t.scalarTextures[l].getVolumeInfo().scale[c];if(s.getUseGradientOpacity(o)){const t=[s.getGradientOpacityMinimumOpacity(o),s.getGradientOpacityMaximumOpacity(o)],i=[s.getGradientOpacityMinimumValue(o),s.getGradientOpacityMaximumValue(o)];r[o]=t[0],a[o]=t[1],e[o]=u*(t[1]-t[0])/(i[1]-i[0]),n[o]=-i[0]*(t[1]-t[0])/(i[1]-i[0])+t[0]}else r[o]=1,a[o]=1,e[o]=0,n[o]=1}else{const o=l-1,i=t.previousState.multiTexturePerVolumeEnabled,c=i?o:0,u=i?0:o,d=t.scalarTextures[c].getVolumeInfo().scale[u],p=[s.getGradientOpacityMinimumOpacity(0),s.getGradientOpacityMaximumOpacity(0)],f=[s.getGradientOpacityMinimumValue(0),s.getGradientOpacityMaximumValue(0)];r[0]=p[0],a[0]=p[1],e[0]=d*(p[1]-p[0])/(f[1]-f[0]),n[0]=-f[0]*(p[1]-p[0])/(f[1]-f[0])+p[0]}o.setUniform4f(`${i}.gradientOpacityScale`,e),o.setUniform4f(`${i}.gradientOpacityShift`,n),o.setUniform4f(`${i}.gradientOpacityMin`,r),o.setUniform4f(`${i}.gradientOpacityMax`,a)}const h=s.getLabelOutlineOpacity();if(o.setUniformf(`${i}.outlineOpacity`,h),t.numberOfLights>0){o.setUniformf(`${i}.ambient`,s.getAmbient()),o.setUniformf(`${i}.diffuse`,s.getDiffuse()),o.setUniformf(`${i}.specular`,s.getSpecular());const e=s.getSpecularPower();o.setUniformf(`${i}.specularPower`,0===e?1:e)}},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();On(t,t,r.normalMatrix),wn(n,n,r.wcvc);const l=-1*An(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv("vClipPlaneNormals",o),c.setUniformfv("vClipPlaneDistances",a),c.setUniform3fv("vClipPlaneOrigins",i),c.setUniformi("clip_numPlanes",l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),(()=>{t._openGLRenderWindow&&a(t._openGLRenderWindow)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n&&n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r);const a=r.getProperties();t.currentValidInputs.forEach((e=>{let{inputIndex:n}=e;const r=a[n].getInterpolationType(),o=t.scalarTextures[n];r===Cf.NEAREST?(o.setMinificationFilter(Bu.NEAREST),o.setMagnificationFilter(Bu.NEAREST)):(o.setMinificationFilter(Bu.LINEAR),o.setMagnificationFilter(Bu.LINEAR))})),null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context,a=[...t.scalarTextures,t.colorTexture,t.opacityTexture,t.labelOutlineThicknessTexture,t.jitterTexture];a.forEach((e=>e.activate())),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),a.forEach((e=>e.deactivate()))},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","uniform vec2 tfactor;","varying vec2 tcoord;","void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"),["//VTK::System::Dec","//VTK::Output::Dec","uniform sampler2D texture1;","varying vec2 tcoord;","void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"),"");const e=t.copyShader;t.copyVAO=Ru.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Rf("Error setting vertexDC in copy shader VAO.")}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi("texture",n.getTextureUnit()),t.copyShader.setUniform2f("tfactor",t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update();const o=t.renderable.getNumberOfInputPorts();t.currentValidInputs=[];for(let e=0;e<o;++e){const n=t.renderable.getInputData(e);n&&!n.isDeleted()&&t.currentValidInputs.push({imageData:n,inputIndex:e})}const a=r.getProperties(),i=t.currentValidInputs[0],s=i.imageData.getPointData().getScalars(),l=a[i.inputIndex];let c=0;if(l.getShade()&&t.renderable.getBlendMode()===wf.COMPOSITE_BLEND&&n.getLights().forEach((e=>{e.getSwitch()>0&&c++})),c!==t.numberOfLights&&(t.numberOfLights=c,e.modified()),e.invokeEvent({type:"EndEvent"}),0===t.currentValidInputs.length)return;const u=t.currentValidInputs.length,d=u>1;t.numberOfComponents=d?u:s.getNumberOfComponents(),t.useIndependentComponents=function(e,t){const n=e.getIndependentComponents(),r=e.getColorMixPreset();return n&&t>=2||!!r}(l,t.numberOfComponents),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty(t.currentValidInputs[0].inputIndex)?.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.currentValidInputs.some((e=>{let{imageData:n}=e;return t.VBOBuildTime.getMTime()<n.getMTime()}))||t.scalarTextures.length!==t.currentValidInputs.length||!t.scalarTextures.every((e=>!!e?.getHandle()))||!t.colorTexture?.getHandle()||!t.opacityTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle()||!t.jitterTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{if(!t.jitterTexture.getHandle()){const e=new Float32Array(1024);for(let t=0;t<1024;++t)e[t]=Math.random();t.jitterTexture.setMinificationFilter(Bu.NEAREST),t.jitterTexture.setMagnificationFilter(Bu.NEAREST),t.jitterTexture.create2DFromRaw({width:32,height:32,numComps:1,dataType:is.FLOAT,data:e})}const a=r.getProperties(),i=t.currentValidInputs[0],s=a[i.inputIndex],l=t.numberOfComponents,c=t.useIndependentComponents,u=c?l:1,d=[];for(let e=0;e<u;++e)d.push(s.getScalarOpacity(e));const p=Zp(d,c,u),f=s.getScalarOpacity(),g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g.hash===p)t.opacityTexture=g.oglObject;else{const r=Ju.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow);let o=t.renderable.getOpacityTextureWidth();o<=0&&(o=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const a=2*o*u,i=new Float32Array(a),l=new Float32Array(o);for(let t=0;t<u;++t){const r=s.getScalarOpacity(t),a=e.getCurrentSampleDistance(n)/s.getScalarOpacityUnitDistance(t),c=r.getRange();r.getTable(c[0],c[1],o,l,1);for(let e=0;e<o;++e)i[t*o*2+e]=1-(1-l[e])**a,i[t*o*2+e+o]=i[t*o*2+e]}if(r.resetFormatAndType(),r.setMinificationFilter(Bu.LINEAR),r.setMagnificationFilter(Bu.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))r.create2DFromRaw({width:o,height:2*u,numComps:1,dataType:is.FLOAT,data:i});else{const e=new Uint8ClampedArray(a);for(let t=0;t<a;++t)e[t]=255*i[t];r.create2DFromRaw({width:o,height:2*u,numComps:1,dataType:is.UNSIGNED_CHAR,data:e})}f&&t._openGLRenderWindow.setGraphicsResourceForObject(f,r,p),t.opacityTexture=r}o(t._openGLRenderWindow,t._opacityTextureCore,f),t._opacityTextureCore=f;const m=[];for(let e=0;e<u;++e)m.push(s.getRGBTransferFunction(e));const h=Zp(m,c,u),v=s.getRGBTransferFunction(),T=t._openGLRenderWindow.getGraphicsResourceForObject(v);if(T?.oglObject?.getHandle()&&T?.hash===h)t.colorTexture=T.oglObject;else{const e=Ju.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(2*n*u*3),o=new Float32Array(3*n);for(let e=0;e<u;++e){const t=s.getRGBTransferFunction(e),a=t.getRange();t.getTable(a[0],a[1],n,o,1);for(let t=0;t<3*n;++t)r[e*n*6+t]=255*o[t],r[e*n*6+t+3*n]=255*o[t]}e.resetFormatAndType(),e.setMinificationFilter(Bu.LINEAR),e.setMagnificationFilter(Bu.LINEAR),e.create2DFromRaw({width:n,height:2*u,numComps:3,dataType:is.UNSIGNED_CHAR,data:r}),t._openGLRenderWindow.setGraphicsResourceForObject(v,e,h),t.colorTexture=e}o(t._openGLRenderWindow,t._colorTextureCore,v),t._colorTextureCore=v,t.currentValidInputs.forEach(((e,n)=>{let{imageData:r,inputIndex:i}=e;const s=a[i],l=r.getPointData().getScalars(),c=t._openGLRenderWindow.getGraphicsResourceForObject(l),u=Qp(0,l),d=!c?.oglObject?.getHandle()||c?.hash!==u,p=s.getUpdatedExtents(),f=!!p.length;if(d&&!f){const e=Ju.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);const o=r.getDimensions();e.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),e.resetFormatAndType(),e.create3DFilterableFromDataArray({width:o[0],height:o[1],depth:o[2],dataArray:l,preferSizeOverAccuracy:s.getPreferSizeOverAccuracy()}),t._openGLRenderWindow.setGraphicsResourceForObject(l,e,u),t.scalarTextures[n]=e}else t.scalarTextures[n]=c.oglObject;if(f){s.setUpdatedExtents([]);const e=r.getDimensions();t.scalarTextures[n].create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:l,updatedExtents:p})}o(t._openGLRenderWindow,t._scalarTexturesCore[n],l),t._scalarTexturesCore[n]=l}));const y=s.getLabelOutlineThickness(),b=t._openGLRenderWindow.getGraphicsResourceForObject(y),x=y.join("-");if(b?.oglObject?.getHandle()&&b?.hash===x)t.labelOutlineThicknessTexture=b.oglObject;else{const e=Ju.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=1,o=new Uint8Array(n*r);for(let e=0;e<n;++e){const t=void 0!==y[e]?y[e]:y[0];o[e]=t}e.resetFormatAndType(),e.setMinificationFilter(Bu.NEAREST),e.setMagnificationFilter(Bu.NEAREST),e.create2DFromRaw({width:n,height:r,numComps:1,dataType:is.UNSIGNED_CHAR,data:o}),y&&t._openGLRenderWindow.setGraphicsResourceForObject(y,e,x),t.labelOutlineThicknessTexture=e}if(o(t._openGLRenderWindow,t._labelOutlineThicknessTextureCore,y),t._labelOutlineThicknessTextureCore=y,!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Ts.newInstance({numberOfComponents:3,values:e});r.setName("points");const o=Ts.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,"polys",qi.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLVolumeMapper");en("vtkVolumeMapper",Vf);const{vtkDebugMacro:Df}=jt,Lf={};const Bf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lf,n),Xt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper"),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():Df("No framebuffer to save/restore");const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}(e,t)}),"vtkOpenGLPixelSpaceCallbackMapper");en("vtkPixelSpaceCallbackMapper",Bf);var Nf="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtktextureObjectVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\nattribute vec2 tcoordDC;\nvarying vec2 tcoordVC;\n\nvoid main()\n{\n  tcoordVC = tcoordDC;\n  gl_Position = vertexDC;\n}\n";const{Representation:Ff}=ts;function _f(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=Ju.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw({width:o,height:a,numComps:4,dataType:"Float32Array",data:null}),s.activate(),s.sendParameters(),s.deactivate(),s}function kf(e,t){return _f(e,t,Ju.Filter.NEAREST,Ju.Wrap.CLAMP_TO_EDGE)}const Gf={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function Uf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gf,n),Ht.obj(e,t),Ht.get(e,t,["readIndex"]),Ht.setGet(e,t,["doEEPass","doVTPass","_openGLRenderWindow","vectorTexture","maskVectorTexture","noiseTexture","framebuffer","size"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkLICPingPongBufferManager"),t._openGLRenderWindow?(t.quad=function(e){const t=Du.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ts.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ts.newInstance({numberOfComponents:1,values:o}),s=Ts.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",Ff.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=kf(t._openGLRenderWindow,t.size),t.seedTexture0=kf(t._openGLRenderWindow,t.size),t.licTexture1=kf(t._openGLRenderWindow,t.size),t.seedTexture1=kf(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?_f(t._openGLRenderWindow,t.size,Ju.Filter.NEAREST,Ju.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?(n=t._openGLRenderWindow,r=t.size,_f(n,r,Ju.Filter.LINEAR,Ju.Wrap.CLAMP_TO_EDGE)):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=Ru.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error("Wrong LIC pass number")}},e.deactivateNoiseTexture=function(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error("Wrong LIC pass number")}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error("Pass renderwindow to ping pong manager");var n,r}(e,t)}var zf={newInstance:Ht.newInstance(Uf,"vtkLICPingPongBufferManager"),extend:Uf};const Wf=0,Hf=1,jf=2,Kf=3,$f=1,qf={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function Xf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qf,n),Ht.obj(e,t),Ht.setGet(e,t,["context","_openGLRenderWindow","nuberOfSteps","stepSize","normalizeVectors","maskThreshold","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","componentIds","isComposite"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){function n(e,t){e.setUniformi("texLIC",t.getLICTextureUnit()),e.setUniformi("texSeedPts",t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push("vtkLineIntegralConvolution2D"),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Nf,e,""),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=Zd.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t="xyzw";return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n/**\nThis shader initializes the convolution for the LIC computation.\n*/\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texMaskVectors;\nuniform sampler2D texNoise;\nuniform sampler2D texLIC;\n\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the *whole* domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value. this\n// depends on the pass number.\nvec2 getNoiseTC(vec2 vectc)\n{\n  // in pass 1 : convert from vector tc to noise tc\n  // in pass 2 : use vector tc\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(vectc);\n    }\n  else\n    {\n    return vectc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the\n// need to convert to noise texture coordinates.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\nvoid main(void)\n{\n  vec2 vectc = tcoordVC.st;\n\n  // lic => (convolution, mask, 0, step count)\n  if (uStepNo == 0)\n    {\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\n    float maskFlag;\n    if (maskCriteria <= uMaskThreshold)\n      {\n      maskFlag = 1.0;\n      }\n    else\n      {\n      maskFlag = 0.0;\n      }\n    float noise = getNoise(vectc);\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\n    }\n  else\n    {\n    LICOutput = texture2D(texLIC, vectc);\n    }\n\n  // initial seed\n  SeedOutput = vec4(vectc, 0.0, 1.0);\n}\n");const n=wu.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// move vector field to normalized image space\n// pre-processing for vtkLineIntegralConvolution2D\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Fragment shader used by the gaussian blur filter render pass.\n\nuniform sampler2D texVectors; // input texture\nuniform vec2      uTexSize;   // size of texture\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  //VTK::LICComponentSelection::Impl\n  V = V/uTexSize;\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\n}\n","//VTK::LICComponentSelection::Impl",`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=wu.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D  texVectors;\nuniform sampler2D  texNoise;\nuniform sampler2D  texLIC;\nuniform sampler2D  texSeedPts;\n\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\nuniform float uStepSize;        // step size in parametric space\n\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n//VTK::LICVectorLookup::Impl\n\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\n// are very poorly supported in webgl\nvec2 clampToBorder(vec2 uv){\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n  {\n    return vec2(0.0, 0.0);\n  }\n  return getVector(uv);\n}\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the whole domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value.\n// in pass 1 repeatedly tile the noise texture across\n// the computational domain.\nvec2 getNoiseTC(vec2 tc)\n{\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(tc);\n    }\n  else\n    {\n    return tc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the need\n// to convert to either noise or lic texture coordinates in\n// pass 1 and 2 respectively.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\n// fourth-order Runge-Kutta streamline integration\n// no bounds checks are made, therefore it's essential\n// to have the entire texture initialized to 0\n// and set clamp to border and have border color 0\n// an integer is set if the step was taken, keeping\n// an accurate step count is necessary to prevent\n// boundary artifacts. Don't count the step if\n// all vector lookups are identically 0. This is\n// a proxy for \"stepped outside valid domain\"\nvec2 rk4(vec2 pt0, float dt, out bool count)\n{\n  count=true;\n  float dtHalf = dt * 0.5;\n  vec2 pt1;\n\n  vec2 v0 = clampToBorder(pt0);\n  pt1 = pt0 + v0 * dtHalf;\n\n  vec2 v1 = clampToBorder(pt1);\n  pt1 = pt0 + v1 * dtHalf;\n\n  vec2 v2 = clampToBorder(pt1);\n  pt1 = pt0 + v2 * dt;\n\n  vec2 v3 = clampToBorder(pt1);\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\n\n  if (vSum == vec2(0.0, 0.0))\n    {\n      count = false;\n    }\n\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\n\n return pt1;\n}\n\nvoid main(void)\n{\n  vec2 lictc = tcoordVC.st;\n  vec4 lic = texture2D(texLIC, lictc);\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\n\n  bool count;\n  vec2 pt1 = rk4(pt0, uStepSize, count);\n\n  if (count)\n    {\n    // accumulate lic step\n    // (lic, mask, 0, step count)\n    float noise = getNoise(pt1);\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\n    SeedOutput = vec4(pt1, 0.0, 1.0);\n    }\n  else\n    {\n    // keep existing values\n    LICOutput = lic;\n    SeedOutput = vec4(pt0, 0.0, 1.0);\n    }\n}\n","//VTK::LICVectorLookup::Impl",function(){return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?"\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      return texture2D( texVectors, vectc ).xy;\n\n      }\n\n    ":"\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      vec2 V = texture2D( texVectors, vectc ).xy;\n\n      // normalize if |V| not 0\n\n      float lenV = length( V );\n\n      if ( lenV > 1.0e-8 )\n\n        {\n\n        return V/lenV;\n\n        }\n\n      else\n\n        {\n\n        return vec2( 0.0, 0.0 );\n\n        }\n\n      }\n\n    "}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(" //VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n/**\nThis shader finalizes the convolution for the LIC computation\napplying the normalization. eg. if box kernel is used the this\nis the number of steps taken.\n*/\n\nuniform sampler2D texLIC;\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\n  conv.r = conv.r/conv.a;\n  // lic => (convolution, mask, 0, 1)\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.CEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// gray scale contrast enhance stage implemented via histogram stretching\n// if the min and max are tweaked it can generate out-of-range values\n// these will be clamped in 0 to 1\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n\nuniform sampler2D texLIC;  // most recent lic pass\nuniform float uMin;        // min gray scale color value\nuniform float uMaxMinDiff; // max-min\n\nin vec2 tcoordVC;\n\nvoid main( void )\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g!=0.0)\n    {\n    LICOutput = lic;\n    }\n  else\n    {\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\n    LICOutput = vec4(CElic, lic.gb, 1.0);\n    }\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.EEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\n// noise for pass2.\n\n// the output of this shader\nlayout(location = 0) out vec4 EEOutput;\n\nuniform sampler2D texLIC; // most recent lic pass\nuniform float     uDx;    // fragment size\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n// kernel for simple laplace edge enhancement.\n// p=Laplace(p)+p\nfloat K[9] = float[9](\n  -1.0, -1.0, -1.0,\n  -1.0,  9.0, -1.0,\n  -1.0, -1.0, -1.0\n  );\n\n// determine if the fragment was masked\nbool Masked(float val) { return val != 0.0; }\n\nvoid main(void)\n{\n  // tex coord neighbor offsets\n  vec2 fragDx[9] = vec2[9](\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\n    );\n\n  vec2 lictc = tcoordVC.st;\n\n  // compute the convolution but don't use convovled values if\n  // any masked fragments on the stencil. Fragments outside\n  // the valid domain are masked during initialization, and\n  // texture wrap parameters are clamp to border with border\n  // color that contains masked flag\n  float conv = 0.0;\n  bool dontUse = false;\n  for (int i=0; i<9; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    vec4 lic = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic.g);\n    conv = conv + K[i] * lic.r;\n    }\n\n  if (dontUse)\n    {\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\n    }\n  else\n    {\n    conv = clamp(conv, 0.0, 1.0);\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\n    }\n\n}\n"),t.AAHProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// horizontal pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDx;    // fragment size\n\nin vec2 tcoordVC;\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.AAVProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// vertical pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\n\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDy[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n")},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;const g=f?.getSize();f&&g&&o[0]===g&&o[1]===g||(f=Zd.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=zf.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const m=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],h=1/o[0],v=1/o[1],T=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;T.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f("uTexSize",...o),e.setUniformi("texVectors",t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:y}=t;T.readyShaderProgram(y),y.setUniformi("uStepNo",0),y.setUniformi("uPassNo",0),y.setUniformf("uMaskThreshold",t.maskThreshold),y.setUniform2f("uNoiseBoundsPt1",...m),y.setUniformi("texMaskVectors",t.bufs.getMaskVectorTextureUnit()),y.setUniformi("texLIC",t.bufs.getLICTextureUnit()),y.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,y);const{LICIShaderProgram:b}=t;T.readyShaderProgram(b),b.setUniformi("uPassNo",0),b.setUniformf("uStepSize",-d),b.setUniform2f("uNoiseBoundsPt1",...m),b.setUniformi("texVectors",t.bufs.getImageVectorTextureUnit()),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);T.readyShaderProgram(y),y.setUniformi("uStepNo",1),n(y,t.bufs),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:x}=t;if(T.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),r(t.bufs,o,x),t.enhancedLIC){t.enhanceContrast!==Hf&&t.enhanceContrast!==Kf||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;T.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDx",h),a.setUniformf("uDy",v),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),T.readyShaderProgram(y),y.setUniformi("uStepNo",0),y.setUniformi("uPassNo",1),n(y,t.bufs),y.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformi("uPassNo",1),b.setUniformf("uStepSize",-d),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);T.readyShaderProgram(y),y.setUniformi("uStepNo",1),n(y,t.bufs),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),T.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),x.setUniformi("texSeedPts",t.bufs.getSeedTextureUnit()),r(t.bufs,o,x)}if(t.antiAlias){const e=t.AAHProgram;T.readyShaderProgram(e),e.setUniformi("texLIC",t.bufs.getLICTextureUnit()),e.setUniformf("uDx",h);const a=t.AAVProgram;T.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDy",v);for(let i=0;i<t.antiAlias;++i)T.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),T.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==Hf&&t.enhanceContrast!==Kf||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error("Invalid color range: ",i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi("texLIC",t.bufs.getLICTextureUnit()),c.setUniformf("uMin",i),c.setUniformf("uMaxMinDiff",l),r(t.bufs,o,c)}}(e,t)}var Yf={newInstance:Ht.newInstance(Xf,"vtkLineIntegralConvolution2D"),extend:Xf};const Zf={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:Wf,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:$f,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function Qf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zf,n),Ht.obj(e,t),Ht.setGet(e,t,["enableLIC","numberOfSteps","stepSize","normalizeVectors","transformVectors","maskOnSurface","maskThreshold","maskColor","maskIntensity","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor","antiAlias","colorMode","LICIntensity","mapModeBias","noiseTextureSize","noiseTextureType","noiseGrainSize","minNoiseValue","maxNoiseValue","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","noiseGeneratorSeed","viewPortScale","rebuildNoiseTexture"]),function(e,t){t.classHierarchy.push("vtkSurfaceLICInterface")}(0,t)}var Jf={newInstance:Ht.newInstance(Qf,"vtkSurfaceLICInterface"),extend:Qf};const{Representation:eg}=ts;const tg={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function ng(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tg,n),Jf.extend(e,t,n),Ht.obj(e,t),Ht.setGet(e,t,["context","_openGLRenderWindow","reallocateTextures","licInterface","size"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICInterface"),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=Ru.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),io()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get("noiseTextureType","noiseGrainSize","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","minNoiseValue","maxNoiseValue");n=r===$f?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=Ju.newInstance({wrapS:Ju.Wrap.REPEAT,wrapT:Ju.Wrap.REPEAT,minificationFilter:Ju.Filter.NEAREST,magnificationFilter:Ju.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw({width:e,height:e,numComps:4,dataType:"Float32Array",data:d}),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Nf,e,""),e.allocateTextures=()=>{const n=Ju.Filter.NEAREST,r=Ju.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=Ju.newInstance({wrapS:Ju.Wrap.CLAMP_TO_EDGE,wrapT:Ju.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw({width:t.size[0],height:t.size[1],numComps:4,dataType:"Float32Array",data:null}),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=Ju.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw({width:t.size[0],height:t.size[1],dataType:"Float32Array",data:null}),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=Zd.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader combines surface geometry, LIC, and  scalar colors.\n\n// the output of this shader\nlayout(location = 0) out vec4 RGBOutput;\nlayout(location = 1) out vec4 HSLOutput;\n\nuniform sampler2D texVectors;       // vectors, depth\nuniform sampler2D texGeomColors;    // scalar colors + lighting\nuniform sampler2D texLIC;           // image lic\nuniform int       uScalarColorMode; // select between blend, and map shader\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\nuniform float     uMaskIntensity;   // blending factor for mask color\nuniform vec3      uMaskColor;       // color for the masked out fragments\n\nin vec2 tcoordVC;\n\n/**\nConvert from RGB color space into HSL colorspace.\n*/\nvec3 RGBToHSL(vec3 RGB)\n{\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\n\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\n  float RGBMaxMinDiff = RGBMax - RGBMin;\n\n  HSL.z = (RGBMax + RGBMin) / 2.0;\n\n  if (RGBMaxMinDiff == 0.0)\n    {\n    // Gray scale\n    HSL.x = 0.0;\n    HSL.y = 0.0;\n    }\n  else\n    {\n    // Color\n    if (HSL.z < 0.5)\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\n    else\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\n\n    float dR\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dG\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dB\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n\n    if (RGB.r == RGBMax)\n      HSL.x = dB - dG;\n    else\n    if (RGB.g == RGBMax)\n      HSL.x = (1.0 / 3.0) + dR - dB;\n    else\n    if (RGB.b == RGBMax)\n      HSL.x = (2.0 / 3.0) + dG - dR;\n\n    if (HSL.x < 0.0)\n      HSL.x += 1.0;\n\n    if (HSL.x > 1.0)\n      HSL.x -= 1.0;\n    }\n\n  return HSL;\n}\n\n/**\nHelper for HSL to RGB conversion.\n*/\nfloat Util(float v1, float v2, float vH)\n{\n  if (vH < 0.0)\n    vH += 1.0;\n\n  if (vH > 1.0)\n     vH -= 1.0;\n\n  if ((6.0 * vH) < 1.0)\n    return (v1 + (v2 - v1) * 6.0 * vH);\n\n  if ((2.0 * vH) < 1.0)\n    return (v2);\n\n  if ((3.0 * vH) < 2.0)\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\n\n  return v1;\n}\n\n/**\nConvert from HSL space into RGB space.\n*/\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  if (HSL.y == 0.0)\n    {\n    // Gray\n    RGB.r = HSL.z;\n    RGB.g = HSL.z;\n    RGB.b = HSL.z;\n    }\n  else\n    {\n    // Chromatic\n    float v2;\n    if (HSL.z < 0.5)\n      v2 = HSL.z * (1.0 + HSL.y);\n    else\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\n\n    float v1 = 2.0 * HSL.z - v2;\n\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\n    RGB.g = Util(v1, v2, HSL.x);\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\n    }\n\n  return RGB.rgb;\n}\n\nvoid main()\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n\n  // depth is used to determine which fragment belong to us\n  // and we can change\n  float depth = texture2D(texVectors, tcoordVC.st).a;\n\n  vec3 fragColorRGB;\n  float valid;\n  if (depth > 1.0e-3)\n    {\n    // we own it\n    // shade LIC'ed geometry, or apply mask\n    if (lic.g!=0.0)\n      {\n      // it's masked\n      // apply fragment mask\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\n      valid = 0.0;\n      }\n    else\n      {\n      if (uScalarColorMode==0)\n        {\n        // blend with scalars\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\n        }\n      else\n        {\n        // multiply with scalars\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\n        }\n      if (lic.b != 0.0)\n        {\n        // didn't have the required guard pixels\n        // don't consider it in min max estimation\n        // for histpgram stretching\n        valid = 0.0;\n        }\n      else\n        {\n        // ok to use in min/max estimates for histogram\n        // stretching\n        valid = 1.0;\n        }\n      }\n    }\n  else\n    {\n    // we don't own it\n    // pass through scalars\n    fragColorRGB = geomColor.rgb;\n    valid = 0.0;\n    }\n\n  // if no further stages this texture is\n  // copied to the screen\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\n\n  // if further stages, move to hsl space for contrast\n  // enhancement. encoding validity saves moving a texture to the cpu\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\n  HSLOutput = vec4(fragColorHSL, valid);\n}\n"),t.licCopyPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader copies fragments and depths to the output buffer\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texDepth;     // z values from vertex shader\nuniform sampler2D texRGBColors; // final rgb LIC colors\n\nin vec2 tcoordVC;\n\nvoid main()\n{\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\n\n  // since we render a screen aligned quad\n  // we're going to be writing fragments\n  // not touched by the original geometry\n  // it's critical not to modify those\n  // fragments.\n  if (gl_FragDepth == 1.0)\n    {\n    discard;\n    }\n}\n"),t.enhanceContrastPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// color contrast enhance stage implemented via histogram stretching\n// on lightness channel. if the min and max are tweaked it can generate\n// out-of-range values these will be clamped in 0 to 1\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texGeomColors; // scalars + lighting\nuniform sampler2D texLIC;        // image lic, mask\nuniform sampler2D texHSLColors;  // hsla colors\n\nuniform float     uLMin;         // min lightness over all fragments\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\n\nin vec2 tcoordVC;\n\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  float v;\n  float h = HSL.x;\n  float sl = HSL.y;\n  float l = HSL.z;\n\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\n  if (v <= 0.0) {\n    RGB = vec3(0.0,0.0,0.0);\n  } else {\n    float m;\n    int sextant;\n    float fract, vsf, mid1, mid2;\n\n    m = l + l - v;\n    h *= 6.0;\n    sextant = int(h);\n    fract = h - float(sextant);\n\n    vsf = (v - m) * fract;\n    mid1 = m + vsf;\n    mid2 = v - vsf;\n    switch (sextant) {\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\n    }\n  }\n  return RGB;\n}\n\nvoid main()\n{\n  // lookup hsl color , mask\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\n\n  // don't modify masked fragments (masked => lic.g==1)\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g==0.0)\n    {\n    // normalize lightness channel\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\n    }\n\n  // back into rgb space\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\n\n  // add alpha\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n  fragColor.a = geomColor.a;\n\n  gl_FragData[0] = fragColor;\n}\n"),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=Du.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ts.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ts.newInstance({numberOfComponents:1,values:o}),s=Ts.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",eg.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=Yf.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi("texDepth",t.depthTexture.getTextureUnit()),r.setUniformi("texRGBColors",t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi("texVectors",t.vectorImage.getTextureUnit()),o.setUniformi("texGeomColors",t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get("colorMode","LICIntensity","mapModeBias","maskIntensity","maskColor","enhanceContrast","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor");if(o.setUniformi("texLIC",t.LICImage.getTextureUnit()),o.setUniformi("uScalarColorMode",a),o.setUniformf("uLICIntensity",i),o.setUniformf("uMapBias",s),o.setUniformf("uMaskIntensity",l),o.setUniform3f("uMaskColor",...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===jf||u===Kf){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi("texGeomColors",t.geometryImage.getTextureUnit()),s.setUniformi("texHSLColors",t.HSLColorImage.getTextureUnit()),s.setUniformi("texLIC",t.LICImage.getTextureUnit()),s.setUniformf("uLMin",o),s.setUniformf("uLMaxMinDiff",i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get("stepSize","numberOfSteps","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","normalizeVectors","maskThreshold","transformVectors"),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error("Failed to compute image LIC"),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}(e,t)}var rg={newInstance:Ht.newInstance(ng,"vtkSurfaceLICInterface"),extend:ng};const{vtkErrorMacro:og}=jt,ag={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const ig=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ag,n),Td.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICMapper");const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=wu.substitute(s,"//VTK::Output::Dec",["//VTK::Output::Dec","layout(location = 2) out vec4 vectorTexture;","layout(location = 3) out vec4 maskVectorTexture;"]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=wu.substitute(i,"//VTK::TCoord::Dec",[`attribute vec3 ${n};`,"out vec3 licOutput;","//VTK::TCoord::Dec"]).result,i=wu.substitute(i,"//VTK::TCoord::Impl",[`licOutput = ${n};`,"//VTK::TCoord::Impl"]).result,s=wu.substitute(s,"//VTK::TCoord::Dec",["uniform int uMaskOnSurface;","uniform mat3 normalMatrix;","in vec3 licOutput;","//VTK::TCoord::Dec"]).result,s=wu.substitute(s,"//VTK::TCoord::Impl",["// projected vectors","  vec3 tcoordLIC = normalMatrix * licOutput;","  vec3 normN = normalize(normalVCVSOutput);","  float k = dot(tcoordLIC, normN);","  vec3 projected = (tcoordLIC - k*normN);","  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","// vectors for fragment masking","  if (uMaskOnSurface == 0)","    {","    maskVectorTexture = vec4(licOutput, 1.0);","    }","  else","    {","    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","    }","//VTK::TCoord::Impl"],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi("uMaskOnSurface",t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(og("SurfaceLICMapper Requires WebGL 2"),a=!1),t.context.getExtension("EXT_color_buffer_float")&&t.context.getExtension("OES_texture_float_linear")||(og("SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions."),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(og("No input"),a=!1);let i=t.renderable.getLicInterface();i||(i=Jf.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=rg.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(og("No vector input array"),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}(e,t),St(e,t,["openGLLicInterface"])}),"vtkOpenGLSurfaceLICMapper");en("vtkSurfaceLICMapper",ig);const{vtkErrorMacro:sg}=jt,lg={};const cg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lg,n),Td.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLSphereMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\nuniform float scaleFactor;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=td,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=wu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=wu.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=wu.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;\n"]).result,i=wu.substitute(i,"//VTK::Normal::Dec",["uniform float invertedDepth;\n","uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=wu.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float b = 2.0*dot(EyePos,EyeDir);\n","  float c = dot(EyePos,EyePos) - 1.0;\n","  float d = b*b - 4.0*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t = (-b - invertedDepth*sqrt(d))*0.5;\n","    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n","    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=wu.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=wu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"offsetMC",12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||sg("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isUniformUsed("invertedDepth")&&e.getProgram().setUniformf("invertedDepth",t.invert?-1:1),e.getProgram().isUniformUsed("scaleFactor")){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf("scaleFactor",t.renderable.getScaleFactor()):e.getProgram().setUniformf("scaleFactor",1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc);const s=new Float64Array(16);if(o.isUniformUsed("MCVCMatrix"))if(r.getIsIdentity())d(s,i.wcvc),e.getCABO().getCoordShiftAndScaleEnabled()&&y(s,s,e.getCABO().getInverseShiftAndScaleMatrix()),o.setUniformMatrix("MCVCMatrix",s);else{const n=t.openGLActor.getKeyMatrices();y(s,i.wcvc,n.mcwc),e.getCABO().getCoordShiftAndScaleEnabled()&&y(s,s,e.getCABO().getInverseShiftAndScaleMatrix()),o.setUniformMatrix("MCVCMatrix",s)}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(fu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(yo(30));let h=0,v=0;const{useShiftAndScale:T,coordShift:y,coordScale:b}=gu(s);T&&a.setCoordShiftAndScale(y,b);let x=0,C=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e;const r=(c[h++]-y[0])*b[0],o=(c[h++]-y[1])*b[1],a=(c[h++]-y[2])*b[2];g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=-2*n*m,g[x++]=-n,d&&(v=e*p,f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3]),g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=2*n*m,g[x++]=-n,d&&(f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3]),g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=0,g[x++]=2*n,d&&(f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3])}a.setElementCount(x/5),a.upload(g,lu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,lu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLSphereMapper");en("vtkSphereMapper",cg);const{vtkErrorMacro:ug}=jt,dg={};const pg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dg,n),Td.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLStickMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=td,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=wu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=wu.substitute(i,"//VTK::PositionVC::Dec","varying vec4 vertexVCVSOutput;").result,i=wu.substitute(i,"//VTK::PositionVC::Impl","  vec4 vertexVC = vertexVCVSOutput;\n").result,i=wu.substitute(i,"//VTK::Normal::Dec",["uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 orientVCVSOutput;\n","varying float lengthVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=wu.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  vec3 base1;\n","  if (abs(orientVCVSOutput.z) < 0.99) {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n","  else {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n","  vec3 base2 = cross(orientVCVSOutput,base1);\n","  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n","  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n","  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n","  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n","  float d = b*b - 4.0*a*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t =  (-b - sqrt(d))/(2.0*a);\n","    float tz = EyePos.z + t*EyeDir.z;\n","    vec3 iPoint = EyePos + t*EyeDir;\n","    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n","      float t2 = (-b + sqrt(d))/(2.0*a);\n","      float tz2 = EyePos.z + t2*EyeDir.z;\n","      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n","      else {\n","        normalVCVSOutput = orientVCVSOutput;\n","        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n","        iPoint = EyePos + t3*EyeDir;\n","        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","        }\n","      }\n","    else {\n","      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n","      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","      }\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=wu.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=wu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed("orientMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"orientMC",12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||ug("Error setting 'orientMC' in shader VAO.")),e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),"offsetMC",0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||ug("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isAttributeUsed("radiusMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"radiusMC",24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||ug("Error setting 'radiusMC' in shader VAO."))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),r.getIsIdentity())o.isUniformUsed("MCVCMatrix")&&o.setUniformMatrix("MCVCMatrix",i.wcvc),o.isUniformUsed("normalMatrix")&&o.setUniformMatrix3x3("normalMatrix",i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed("MCVCMatrix")){const t=new Float64Array(16);y(t,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",t)}if(o.isUniformUsed("normalMatrix")){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3("normalMatrix",t)}}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(fu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():ug(["Error setting orientationArray.\n","You have to specify the stick orientation"]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let T=0,y=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)T=3*e,f[b++]=c[T++],f[b++]=c[T++],f[b++]=c[T++],T=3*e,f[b++]=h[T++]*n,f[b++]=h[T++]*n,f[b++]=h[T++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,y=e*p,d&&(g[x++]=d[y],g[x++]=d[y+1],g[x++]=d[y+2],g[x++]=d[y+3])}a.setElementCount(b/7),a.upload(f,lu.ARRAY_BUFFER),a.getColorBO().upload(g,lu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLStickMapper");en("vtkStickMapper",pg);const fg=[];fg["-".charCodeAt(0)]=62,fg["_".charCodeAt(0)]=63;const gg="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(let e=0;e<64;e++)fg[gg.charCodeAt(e)]=e;function mg(e){return void 0!==fg[e.charCodeAt(0)]}function hg(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!mg(e[l]);)l++;for(c=fg[e.charCodeAt(l++)]<<18;!mg(e[l]);)l++;for(c|=fg[e.charCodeAt(l++)]<<12;!mg(e[l]);)l++;for(c|=fg[e.charCodeAt(l++)]<<6;!mg(e[l]);)l++;c|=fg[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!mg(e[l]);)l++;for(c=fg[e.charCodeAt(l++)]<<10;!mg(e[l]);)l++;for(c|=fg[e.charCodeAt(l++)]<<4;!mg(e[l]);)l++;c|=fg[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!mg(e[l]);)l++;for(c=fg[e.charCodeAt(l++)]<<2;!mg(e[l]);)l++;c|=fg[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error("BASE64: remain 1 should not happen")}return u}function vg(e,t,n){const r=(e<<16)+(t<<8)+n;return gg[r>>18]+gg[r>>12&63]+gg[r>>6&63]+gg[63&r]}function Tg(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=vg(t[n],t[n+1],t[n+2])}if(n>0){const e=vg(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join("")}var yg={toArrayBuffer:function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)mg(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):"="===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=hg(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o},fromArrayBuffer:Tg};const bg={};function xg(e,t){bg[e]=t}var Cg={get:function(){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return bg[arguments.length>0&&void 0!==arguments[0]?arguments[0]:"http"](e)},has:function(e){return!!bg[e]},registerType:xg},Sg=Uint8Array,Ag=Uint16Array,Ig=Uint32Array,wg=new Sg([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Og=new Sg([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Pg=new Sg([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Rg=function(e,t){for(var n=new Ag(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new Ig(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},Mg=Rg(wg,2),Eg=Mg[0],Vg=Mg[1];Eg[28]=258,Vg[258]=28;for(var Dg=Rg(Og,0),Lg=Dg[0],Bg=(Dg[1],new Ag(32768)),Ng=0;Ng<32768;++Ng){var Fg=(43690&Ng)>>>1|(21845&Ng)<<1;Fg=(61680&(Fg=(52428&Fg)>>>2|(13107&Fg)<<2))>>>4|(3855&Fg)<<4,Bg[Ng]=((65280&Fg)>>>8|(255&Fg)<<8)>>>1}var _g=function(e,t,n){for(var r=e.length,o=0,a=new Ag(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new Ag(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new Ag(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[Bg[d]>>>l]=c}else for(i=new Ag(r),o=0;o<r;++o)e[o]&&(i[o]=Bg[s[e[o]-1]++]>>>15-e[o]);return i},kg=new Sg(288);for(Ng=0;Ng<144;++Ng)kg[Ng]=8;for(Ng=144;Ng<256;++Ng)kg[Ng]=9;for(Ng=256;Ng<280;++Ng)kg[Ng]=7;for(Ng=280;Ng<288;++Ng)kg[Ng]=8;var Gg=new Sg(32);for(Ng=0;Ng<32;++Ng)Gg[Ng]=5;var Ug=_g(kg,9,1),zg=_g(Gg,5,1),Wg=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},Hg=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},jg=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},Kg=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?Ag:4==e.BYTES_PER_ELEMENT?Ig:Sg)(n-t);return r.set(e.subarray(t,n)),r},$g=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],qg=function(e,t,n){var r=new Error(t||$g[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,qg),!n)throw r;return r},Xg=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new Sg(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new Sg(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new Sg(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=Hg(e,c,1);var h=Hg(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(P=4+((i+7)/8|0))-4)]|e[P-3]<<8,T=P+v;if(T>r){a&&qg(0);break}o&&s(u+v),t.set(e.subarray(P,T),u),n.b=u+=v,n.p=c=8*T,n.f=l;continue}if(1==h)d=Ug,p=zg,f=9,g=5;else if(2==h){var y=Hg(e,c,31)+257,b=Hg(e,c+10,15)+4,x=y+Hg(e,c+5,31)+1;c+=14;for(var C=new Sg(x),S=new Sg(19),A=0;A<b;++A)S[Pg[A]]=Hg(e,c+3*A,7);c+=3*b;var I=Wg(S),w=(1<<I)-1,O=_g(S,I,1);for(A=0;A<x;){var P,R=O[Hg(e,c,w)];if(c+=15&R,(P=R>>>4)<16)C[A++]=P;else{var M=0,E=0;for(16==P?(E=3+Hg(e,c,3),c+=2,M=C[A-1]):17==P?(E=3+Hg(e,c,7),c+=3):18==P&&(E=11+Hg(e,c,127),c+=7);E--;)C[A++]=M}}var V=C.subarray(0,y),D=C.subarray(y);f=Wg(V),g=Wg(D),d=_g(V,f,1),p=_g(D,g,1)}else qg(1);if(c>m){a&&qg(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var F=(M=d[jg(e,c)&L])>>>4;if((c+=15&M)>m){a&&qg(0);break}if(M||qg(2),F<256)t[u++]=F;else{if(256==F){N=c,d=null;break}var _=F-254;if(F>264){var k=wg[A=F-257];_=Hg(e,c,(1<<k)-1)+Eg[A],c+=k}var G=p[jg(e,c)&B],U=G>>>4;if(G||qg(3),c+=15&G,D=Lg[U],U>3&&(k=Og[U],D+=jg(e,c)&(1<<k)-1,c+=k),c>m){a&&qg(0);break}o&&s(u+131072);for(var z=u+_;u<z;u+=4)t[u]=t[u-D],t[u+1]=t[u+1-D],t[u+2]=t[u+2-D],t[u+3]=t[u+3-D];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:Kg(t,0,u)},Yg=new Sg(0),Zg=function(e,t){return e[t]|e[t+1]<<8},Qg=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},Jg=function(e,t){return Qg(e,t)+4294967296*Qg(e,t+4)};function em(e,t){return Xg(e,t)}function tm(e,t){return Xg(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||qg(6,"invalid gzip data");var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new Sg((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function nm(e,t){return Xg(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&qg(6,"invalid zlib data"),32&n[1]&&qg(6,"invalid zlib data: preset dictionaries not supported"),e.subarray(2,-4)),t);var n}function rm(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?tm(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?em(e,t):nm(e,t)}var om="undefined"!=typeof TextEncoder&&new TextEncoder,am="undefined"!=typeof TextDecoder&&new TextDecoder;try{am.decode(Yg,{stream:!0})}catch(e){}function im(e,t){if(t){for(var n="",r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(am)return am.decode(e);var o=function(e){for(var t="",n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,Kg(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&qg(8),a}var sm=function(e,t){return t+30+Zg(e,t+26)+Zg(e,t+28)},lm=function(e,t,n){var r=Zg(e,t+28),o=im(e.subarray(t+46,t+46+r),!(2048&Zg(e,t+8))),a=t+46+r,i=Qg(e,t+20),s=n&&4294967295==i?cm(e,a):[i,Qg(e,t+24),Qg(e,t+42)],l=s[0],c=s[1],u=s[2];return[Zg(e,t+10),l,c,o,a+Zg(e,t+30)+Zg(e,t+32),u]},cm=function(e,t){for(;1!=Zg(e,t);t+=4+Zg(e,t+2));return[Jg(e,t+12),Jg(e,t+4),Jg(e,t+20)]};function um(e,t){for(var n={},r=e.length-22;101010256!=Qg(e,r);--r)(!r||e.length-r>65558)&&qg(13);var o=Zg(e,r+8);if(!o)return{};var a=Qg(e,r+16),i=4294967295==a;i&&(r=Qg(e,r-12),101075792!=Qg(e,r)&&qg(13),o=Qg(e,r+32),a=Qg(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=lm(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=sm(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=em(e.subarray(h,h+d),new Sg(p)):qg(14,"unknown compression type "+u):n[f]=Kg(e,h,h+d))}return n}function dm(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?"LittleEndian":2712847316===n[0]?"BigEndian":null}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout;var pm=dm(),fm=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:gm,vtkDebugMacro:mm}=Ht;let hm=0;function vm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener("progress",n.progressCallback),r}const Tm={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/");const s=vm("GET",i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++hm&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=im(rm(new Uint8Array(n.buffer))):n.buffer=rm(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(pm!==n.ref.encode&&pm&&(mm(`Swap bytes of ${n.name}`),fm(n.buffer,as[n.dataType])),n.values=Ht.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&gm(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--hm&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||"string"!==n.dataType?"arraybuffer":"text",s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=vm("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++hm&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--hm&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(im(rm(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&"gz"!==n.compression&&(gm("Supported algorithms are: [gz]"),gm(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=vm("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++hm&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--hm&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(im(rm(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&"gz"!==t.compression&&(gm("Supported algorithms are: [gz]"),gm(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=vm("GET",e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(rm(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType="arraybuffer",o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};xg("http",(e=>Tm));const{vtkDebugMacro:ym}=Ht,bm={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function xm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bm,n),Ht.obj(e,t),Ht.get(e,t,["distance"]),Ht.setGet(e,t,["parallelProjection","useHorizontalViewAngle","viewAngle","parallelScale","useOffAxisProjection","freezeFocalPoint","physicalScale"]),Ht.getArray(e,t,["directionOfProjection","viewPlaneNormal","position","focalPoint"]),Ht.setGetArray(e,t,["clippingRange","windowCenter"],2),Ht.setGetArray(e,t,["viewUp","screenBottomLeft","screenBottomRight","screenTopRight","physicalTranslation","physicalViewUp","physicalViewNorth"],3),function(e,t){t.classHierarchy.push("vtkCamera");const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function T(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,ym("Distance is set to minimum."));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,ym("Distance is set to minimum.");const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,T()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,yo(n),s),Ba(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,yo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),wn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,yo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),wn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,yo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),wn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,yo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),wn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Eo(t.position,a,t.position),Eo(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Ba(o,[...t.position,1],n),Ba(a,[...t.focalPoint,1],n),Ba(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,ym("Thickness is set to minimum.")),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,ym("Thickness is set to minimum.")),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),O(i,[t.distance,t.distance,t.distance]),y(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=ka(e[0],e[1],e[2],e[3]),n=Na(),r=ka(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],_a(r,t,r),_a(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Fo(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),vn(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),wn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),wn(l,r,a),yn(l,l,s),Sn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),wn(c,o,a),yn(c,c,s),Sn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),y(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return vn(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error("Off-Axis projection is not supported at this time");{const n=Math.tan(yo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return y(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,T()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Fo(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,yo(n),t.physicalViewUp),C(s,s,yo(r),i),C(s,s,yo(o),t.physicalViewNorth),C(s,s,yo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);wn(l,l,s),wn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=yo(t),i=Na();Fa(i,[n,r,o],e),k(a,i)}const i=new Float64Array(3);wn(i,[0,0,-1],a);const s=new Float64Array(3);wn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}(e,t)}var Cm={newInstance:Ht.newInstance(xm,"vtkCamera"),extend:xm};const Sm={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:"SceneLight",shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Am(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sm,n),Ht.obj(e,t),Ht.setGet(e,t,["intensity","switch","positional","exponent","coneAngle","coneFalloff","transformMatrix","lightType","shadowAttenuation","attenuationValues"]),Ht.setGetArray(e,t,["color","position","focalPoint","attenuationValues"],3),function(e,t){t.classHierarchy.push("vtkLight");const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?wn(n,t.position,t.transformMatrix):vn(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?wn(n,t.focalPoint,t.transformMatrix):vn(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(Mn(t.direction,t.focalPoint,t.position),ko(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);Mn(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=yo(t),o=yo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType("HeadLight")},e.setLightTypeToCameraLight=()=>{e.setLightType("CameraLight")},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType("SceneLight")},e.lightTypeIsHeadLight=()=>"HeadLight"===t.lightType,e.lightTypeIsSceneLight=()=>"SceneLight"===t.lightType,e.lightTypeIsCameraLight=()=>"CameraLight"===t.lightType}(e,t)}var Im={newInstance:Ht.newInstance(Am,"vtkLight"),extend:Am,LIGHT_TYPES:["HeadLight","CameraLight","SceneLight"]};const{vtkErrorMacro:wm}=Ht;const Om={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function Pm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Om,n),Ht.obj(e,t),Ht.event(e,t,"event"),Ht.setGetArray(e,t,["viewport"],4),Ht.setGetArray(e,t,["background","background2"],3),function(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push("vtkViewport"),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{let r=[];const o=e.getActors2D();o.sort(((e,t)=>e.getLayerNumber()-t.getLayerNumber()));const a=t.props.filter((e=>!o.includes(e)));for(let e=0;e<a.length;e++)n(a[e],r);return r=r.concat(o),r},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>wm("call displayToView on your view instead"),e.viewToDisplay=()=>wm("callviewtodisplay on your view instead"),e.getSize=()=>wm("call getSize on your View instead"),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=()=>wm("vtkViewport::PickPropFrom - NOT IMPLEMENTED")}(e,t)}var Rm={newInstance:Ht.newInstance(Pm,"vtkViewport"),extend:Pm};const{vtkDebugMacro:Mm,vtkErrorMacro:Em,vtkWarningMacro:Vm}=jt;function Dm(e){return()=>Em(`vtkRenderer::${e} - NOT IMPLEMENTED`)}const Lm={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Ra(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function Bm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,Lm,n),Rm.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),yt(e,t,["_renderWindow","allocatedRenderTime","timeFactor","lastRenderTimeInSeconds","numberOfPropsRendered","lastRenderingUsedDepthPeeling","selector"]),St(e,t,["twoSidedLighting","lightFollowCamera","automaticLightCreation","erase","draw","nearClippingPlaneTolerance","clippingRangeExpansion","backingStore","interactive","layer","preserveColorBuffer","preserveDepthBuffer","useDepthPeeling","occlusionRatio","maximumNumberOfPeels","delegate","backgroundTexture","texturedBackground","environmentTexture","environmentTextureDiffuseStrength","environmentTextureSpecularStrength","useEnvironmentTextureAsBackground","useShadows","pass"]),At(e,t,["actors","volumes","lights"]),wt(e,t,["background"],4,1),Ot(0,t,["renderWindow"]),function(e,t){t.classHierarchy.push("vtkRenderer");const n={type:"ComputeVisiblePropBoundsEvent",renderer:e},r={type:"ResetCameraClippingRangeEvent",renderer:e},o={type:"ResetCameraEvent",renderer:e};e.updateCamera=()=>(t.activeCamera||(Mm("No cameras are on, creating one."),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):Em("light has unknown light type",e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=Dm("allocateTime"),e.updateGeometry=Dm("updateGeometry"),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{Mm(e.getClassName(),e,"setting Layer to ",n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:"ActiveCameraEvent",camera:n}),!0),e.makeCamera=()=>{const t=Cm.newInstance();return e.invokeEvent({type:"CreateCameraEvent",camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=Im.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return Em("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return wn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return Em("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return wn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return Em("WorldToView: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return wn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return Em("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return wn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=Fi.INIT_BOUNDS[0],t.allBounds[1]=Fi.INIT_BOUNDS[1],t.allBounds[2]=Fi.INIT_BOUNDS[2],t.allBounds[3]=Fi.INIT_BOUNDS[3],t.allBounds[4]=Fi.INIT_BOUNDS[4],t.allBounds[5]=Fi.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&ba(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(ya(t.allBounds),Mm("Can't compute bounds, no 3D props are visible")),t.allBounds},e.resetCamera=function(){const n=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:null)||e.computeVisiblePropBounds(),r=[0,0,0];if(!ba(n))return Mm("Cannot reset camera!"),!1;let a=null;if(!e.getActiveCamera())return Em("Trying to reset non-existent camera"),!1;a=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),r[0]=(n[0]+n[1])/2,r[1]=(n[2]+n[3])/2,r[2]=(n[4]+n[5])/2;let i=n[1]-n[0],s=n[3]-n[2],l=n[5]-n[4];i*=i,s*=s,l*=l;let c=i+s+l;c=0===c?1:c,c=.5*Math.sqrt(c);const u=yo(t.activeCamera.getViewAngle()),d=c,p=c/Math.sin(.5*u),f=t.activeCamera.getViewUp();return Math.abs(No(f,a))>.999&&(Vm("Resetting view-up since view plane normal is parallel"),t.activeCamera.setViewUp(-f[2],f[0],f[1])),t.activeCamera.setFocalPoint(r[0],r[1],r[2]),t.activeCamera.setPosition(r[0]+p*a[0],r[1]+p*a[1],r[2]+p*a[2]),e.resetCameraClippingRange(n),t.activeCamera.setParallelScale(d),t.activeCamera.setPhysicalScale(c),t.activeCamera.setPhysicalTranslation(-r[0],-r[1],-r[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){const n=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:null)||e.computeVisiblePropBounds();if(!ba(n))return Mm("Cannot reset camera clipping range!"),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return Em("Trying to reset clipping range of non-existent camera"),!1;const o=t.activeCamera.computeClippingRange(n);let a=0;if(t.activeCamera.getParallelProjection())a=.2*t.activeCamera.getParallelScale();else{const e=yo(t.activeCamera.getViewAngle());a=.2*Math.tan(e/2)*o[1]}return o[1]-o[0]<a&&(a=a-o[1]+o[0],o[1]+=a/2,o[0]-=a/2),o[0]<0&&(o[0]=0),o[0]=.99*o[0]-(o[1]-o[0])*t.clippingRangeExpansion,o[1]=1.01*o[1]+(o[1]-o[0])*t.clippingRangeExpansion,o[0]=o[0]>=o[1]?.01*o[1]:o[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),o[0]<t.nearClippingPlaneTolerance*o[1]&&(o[0]=t.nearClippingPlaneTolerance*o[1]),t.activeCamera.setClippingRange(o[0],o[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}(e,t)}var Nm={newInstance:Et(Bm,"vtkRenderer"),extend:Bm};const Fm=Object.create(null);function _m(e,t){Fm[e]=t}function km(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Fm[e]&&Fm[e](t)}const Gm={defaultViewAPI:"WebGL",renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1,childRenderWindows:[]};function Um(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gm,n),Ht.obj(e,t),Ht.setGet(e,t,["interactor","numberOfLayers","_views","defaultViewAPI"]),Ht.get(e,t,["neverRendered"]),Ht.getArray(e,t,["renderers","childRenderWindows"]),Ht.moveToProtected(e,t,["views"]),Ht.event(e,t,"completion"),function(e,t){t.classHierarchy.push("vtkRenderWindow"),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return km(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{t.getGraphicsMemoryInfo&&(e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6)})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){t.getAllocatedGPUMemoryInBytes&&(e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6);const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join("\n"),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Ht.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))},e.addRenderWindow=n=>!t.childRenderWindows.includes(n)&&(t.childRenderWindows.push(n),e.modified(),!0),e.removeRenderWindow=n=>{const r=t.childRenderWindows.findIndex((e=>e===n));return!(r<0||(t.childRenderWindows.splice(r,1),e.modified(),0))}}(e,t)}var zm={newInstance:Ht.newInstance(Um,"vtkRenderWindow"),extend:Um,registerViewConstructor:_m,listViewAPIs:function(){return Object.keys(Fm)},newAPISpecificView:km};const Wm={Unknown:0,LeftController:1,RightController:2},Hm={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var jm={Device:Wm,Input:Hm,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4},MouseButton:{LeftButton:1,MiddleButton:2,RightButton:3}};const{Device:Km,Input:$m}=jm,{vtkWarningMacro:qm,vtkErrorMacro:Xm,normalizeWheel:Ym,vtkOnceErrorMacro:Zm}=Ht,Qm={ctrlKey:!1,altKey:!1,shiftKey:!1},Jm={"xr-standard":[$m.Trigger,$m.Grip,$m.TrackPad,$m.Thumbstick,$m.A,$m.B]},eh=["StartAnimation","Animation","EndAnimation","PointerEnter","PointerLeave","MouseEnter","MouseLeave","StartMouseMove","MouseMove","EndMouseMove","LeftButtonPress","LeftButtonRelease","MiddleButtonPress","MiddleButtonRelease","RightButtonPress","RightButtonRelease","KeyPress","KeyDown","KeyUp","StartMouseWheel","MouseWheel","EndMouseWheel","StartPinch","Pinch","EndPinch","StartPan","Pan","EndPan","StartRotate","Rotate","EndRotate","Button3D","Move3D","StartPointerLock","EndPointerLock","StartInteraction","Interaction","EndInteraction","AnimationFrameRateUpdate"];function th(e){e.cancelable&&e.preventDefault()}function nh(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}const rh={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:"Start",animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function oh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rh,n),Ht.obj(e,t),t._animationExtendedEnd=0,Ht.event(e,t,"RenderEvent"),eh.forEach((n=>Ht.event(e,t,n))),Ht.get(e,t,["initialized","interactorStyle","lastFrameTime","recentAnimationFrameRate","_view"]),Ht.setGet(e,t,["container","lightFollowCamera","enabled","enableRender","recognizeGestures","desiredUpdateRate","stillUpdateRate","picker","preventDefaultOnPointerDown","preventDefaultOnPointerUp","mouseScrollDebounceByPass"]),Ht.moveToProtected(e,t,["view"]),function(e,t){t.classHierarchy.push("vtkRenderWindowInteractor");const n={...e},r=new Set,o=new Map;let a=1;function i(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{Xm("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor")},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>qm("empty event loop"),e.getCurrentRenderer=()=>(t.currentRenderer||i(0,0),t.currentRenderer);const s=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),r=n.getBoundingClientRect(),a=n.width/r.width,s=n.height/r.height,l={x:a*(e.clientX-r.left),y:s*(r.height-e.clientY+r.top),z:0,movementX:a*e.movementX,movementY:s*e.movementY};return(o.size<=1||!t.currentRenderer)&&i(l.x,l.y),l};function l(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function c(e){const t=l(e);return{key:e.key,keyCode:e.charCode,...t}}function u(e){return e.pointerType||""}const d=()=>{if(null===t.container)return;const{container:n}=t;n.addEventListener("contextmenu",th),n.addEventListener("wheel",e.handleWheel),n.addEventListener("DOMMouseScroll",e.handleWheel),n.addEventListener("pointerenter",e.handlePointerEnter),n.addEventListener("pointerleave",e.handlePointerLeave),n.addEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.addEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.addEventListener("pointerup",e.handlePointerUp),n.addEventListener("pointercancel",e.handlePointerCancel),n.addEventListener("keypress",e.handleKeyPress),n.addEventListener("keydown",e.handleKeyDown),document.addEventListener("keyup",e.handleKeyUp),document.addEventListener("pointerlockchange",e.handlePointerLockChange),n.tabIndex=0,n.style.touchAction="none",n.style.userSelect="none",n.style.webkitTapHighlightColor="rgba(0,0,0,0)"};e.bindEvents=e=>{null!==e&&n.setContainer(e)&&d()};const p=()=>{clearTimeout(t.moveTimeoutID),clearTimeout(t.wheelTimeoutID),t.moveTimeoutID=0,t.wheelTimeoutID=0,a=1;const{container:n}=t;n&&(n.removeEventListener("contextmenu",th),n.removeEventListener("wheel",e.handleWheel),n.removeEventListener("DOMMouseScroll",e.handleWheel),n.removeEventListener("pointerenter",e.handlePointerEnter),n.removeEventListener("pointerleave",e.handlePointerLeave),n.removeEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.removeEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.removeEventListener("pointerup",e.handlePointerUp),n.removeEventListener("pointercancel",e.handlePointerCancel)),n.removeEventListener("keypress",e.handleKeyPress),n.removeEventListener("keydown",e.handleKeyDown),document.removeEventListener("keyup",e.handleKeyUp),document.removeEventListener("pointerlockchange",e.handlePointerLockChange),o.clear()};function f(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.unbindEvents=()=>{p(),n.setContainer(null)},e.handleKeyPress=t=>{const n=c(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=c(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=c(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerEnterEvent(n),"mouse"===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerLeaveEvent(n),"mouse"===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&th(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),o.has(n.pointerId)&&qm("[RenderWindowInteractor] duplicate pointerId detected"),o.set(n.pointerId,{pointerId:n.pointerId,position:s(n)}),n.pointerType){case"pen":case"touch":e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(o.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&th(n),o.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case"pen":case"touch":e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(o.has(t.pointerId))switch(o.delete(t.pointerId),t.pointerType){case"pen":case"touch":e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(o.has(t.pointerId)&&(o.get(t.pointerId).position=s(t)),t.pointerType){case"pen":case"touch":e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:Xm(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=n=>{void 0!==n?r.has(n)?qm("requester is already registered for animating"):(r.add(n),t.animationRequest||1!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):Xm("undefined requester, can not start animating")},e.extendAnimation=n=>{const o=Date.now()+n;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(n){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(r.has(n))r.delete(n),t.animationRequest&&0===r.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=n&&n.getClassName?n.getClassName():n;qm(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==r.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=null==n.gripSpace?null:r.getPose(n.targetRaySpace,o),s=n.gamepad,l=n.handedness;if(s){s.index in t.lastGamepadValues||(t.lastGamepadValues[s.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<s.buttons.length;++r)r in t.lastGamepadValues[s.index][l].buttons||(t.lastGamepadValues[s.index][l].buttons[r]=!1),t.lastGamepadValues[s.index][l].buttons[r]!==s.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,pressed:s.buttons[r].pressed,device:"left"===n.handedness?Km.LeftController:Km.RightController,input:Jm[s.mapping]&&Jm[s.mapping][r]?Jm[s.mapping][r]:$m.Trigger}),t.lastGamepadValues[s.index][l].buttons[r]=s.buttons[r].pressed),t.lastGamepadValues[s.index][l].buttons[r]&&null!=a&&e.move3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,device:"left"===n.handedness?Km.LeftController:Km.RightController})}}))},e.handleMouseMove=n=>{const r={...l(n),position:s(n),deviceType:u(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const n=Date.now();t._animationFrameCount++,n-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(n-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=n,t._animationFrameCount=1),e.animationEvent(),f(),r.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{th(n);const r={...Ym(n),...l(n),position:s(n),deviceType:u(n)};0===t.wheelTimeoutID&&(a=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=a,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:Xm(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=nh(o);if(2===r.length){const t={...l(Qm),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture("TouchStart",t)}else if(1===r.length){const t={...l(Qm),position:s(n),deviceType:u(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=nh(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Qm),position:r[0].position,deviceType:u(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const r=[...o.values()];if(t.recognizeGestures)if(0===r.length){const t={...l(Qm),position:s(n),deviceType:u(n)};e.leftButtonReleaseEvent(t)}else if(1===r.length){const t=nh(o);e.recognizeGesture("TouchEnd",t);const a={...l(Qm),position:r[0].position,deviceType:u(n)};e.leftButtonPressEvent(a)}else{const t=nh(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Qm),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||f()},eh.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void Zm("\n          Can not forward events without a current renderer on the interactor.\n        ");const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),"TouchStart"===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture="Start");if("TouchEnd"===n)return"Pinch"===t.currentGesture&&(e.render(),e.endPinchEvent()),"Rotate"===t.currentGesture&&(e.render(),e.endRotateEvent()),"Pan"===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture="Start",void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=bo(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=bo(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,"TouchMove"===n)if("Start"===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture="Pinch";const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture="Rotate";const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture="Pan";const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if("Rotate"===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if("Pinch"===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if("Pan"===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e},e.setContainer=e=>{p();const t=n.setContainer(e??null);return t&&d(),t},e.delete=()=>{for(;r.size;)e.cancelAnimation(r.values().next().value);void 0!==document.hidden&&document.removeEventListener("visibilitychange",e.handleVisibilityChange),t.container&&e.setContainer(null),n.delete()},void 0!==document.hidden&&document.addEventListener("visibilitychange",e.handleVisibilityChange,!1)}(e,t)}var ah={newInstance:Ht.newInstance(oh,"vtkRenderWindowInteractor"),extend:oh,handledEvents:eh,...jm};const{vtkErrorMacro:ih,VOID:sh}=Ht,lh={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function ch(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lh,n),Ht.obj(e,t),Ht.event(e,t,"InteractionEvent"),Ht.event(e,t,"StartInteractionEvent"),Ht.event(e,t,"EndInteractionEvent"),Ht.get(e,t,["_interactor","enabled"]),Ht.setGet(e,t,["priority","processEvents"]),Ht.moveToProtected(e,t,["interactor"]),function(e,t){t.classHierarchy.push("vtkInteractorObserver");const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){ah.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):sh),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():ih("\n          The interactor must be set before subscribing to events\n        ")),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}(e,t)}var uh={newInstance:Ht.newInstance(ch,"vtkInteractorObserver"),extend:ch,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},dh={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:ph}=dh,fh={Rotate:ph.IS_ROTATE,Pan:ph.IS_PAN,Spin:ph.IS_SPIN,Dolly:ph.IS_DOLLY,CameraPose:ph.IS_CAMERA_POSE,WindowLevel:ph.IS_WINDOW_LEVEL,Slice:ph.IS_SLICE},gh={state:ph.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function mh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gh,n),uh.extend(e,t,n),Ht.setGet(e,t,["focusedRenderer"]),function(e,t){t.classHierarchy.push("vtkInteractorStyle"),Object.keys(fh).forEach((n=>{Ht.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===ph.IS_NONE&&(t.state=fh[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:"StartInteractionEvent"}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},Ht.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===fh[n]&&(t.state=ph.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:"EndInteractionEvent"}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),t.getRenderer=e=>t.focusedRenderer||e.pokedRenderer,e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case"r":case"R":t.getRenderer(e).resetCamera(),n.render();break;case"w":case"W":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case"s":case"S":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case"v":case"V":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}(e,t)}var hh={newInstance:Ht.newInstance(mh,"vtkInteractorStyle"),extend:mh,...dh};const{States:vh}=dh,Th={motionFactor:10,zoomFactor:10};function yh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Th,n),hh.extend(e,t,n),Ht.setGet(e,t,["motionFactor","zoomFactor"]),function(e,t){t.classHierarchy.push("vtkInteractorStyleTrackballCamera"),e.handleMouseMove=n=>{const r=n.position,o=t.getRenderer(n);switch(t.state){case vh.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case vh.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case vh.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case vh.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:"InteractionEvent"})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==Wm.RightController||n.input!==Hm.Trigger&&n.input!==Hm.TrackPad?!n||n.pressed||n.device!==Wm.RightController||n.input!==Hm.Trigger&&n.input!==Hm.TrackPad||t.state!==vh.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===vh.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const n=t.getRenderer(e).getActiveCamera(),r=n.getPhysicalTranslation(),o=.025*n.getPhysicalScale(),a=n.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);n.setPhysicalTranslation(r[0]+a[0]*o,r[1]+a[1]*o,r[2]+a[2]*o)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case vh.IS_DOLLY:e.endDolly();break;case vh.IS_PAN:e.endPan();break;case vh.IS_SPIN:e.endSpin();break;case vh.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(t.getRenderer(n),n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=t.getRenderer(n).getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(t.getRenderer(n),o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(t.getRenderer(n),o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(t.getRenderer(n),o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&t.getRenderer(n).updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=t.getRenderer(e).getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=bo(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=bo(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(t.getRenderer(n),r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}(e,t)}var bh={newInstance:Ht.newInstance(yh,"vtkInteractorStyleTrackballCamera"),extend:yh};function xh(e){return e}function Ch(e){return null===e||"null"===e?null:"true"===e||"false"!==e&&(void 0!==e&&"undefined"!==e?"["===e[0]&&"]"===e[e.length-1]?e.substring(1,e.length-1).split(",").map((e=>Ch(e.trim()))):""===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var Sh=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?Ch:xh;return new URLSearchParams(t).forEach(((e,t)=>{t&&(n[t]=!e||r(e))})),n};const Ah={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function Ih(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ah,n),Ht.obj(e,t),Ht.get(e,t,["currentOperation"]),Ht.setGet(e,t,["delegates","_currentParent","preDelegateOperations","postDelegateOperations"]),Ht.moveToProtected(e,t,["currentParent"]),function(e,t){t.classHierarchy.push("vtkRenderPass"),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${Ht.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}(e,t)}var wh={newInstance:Ht.newInstance(Ih,"vtkRenderPass"),extend:Ih};const{Representation:Oh}=ts,{vtkErrorMacro:Ph}=Ht;function Rh(e){const t=wu.substitute(e.Fragment,"//VTK::RenderPassFragmentShader::Impl","\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\n      gl_FragData[1].r = weight;\n    ",!1);e.Fragment=t.result}const Mh={framebuffer:null,copyShader:null,tris:null};function Eh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mh,n),wh.extend(e,t,n),t.VBOBuildTime={},Ht.obj(t.VBOBuildTime,{mtime:0}),t.tris=Du.newInstance(),Ht.get(e,t,["framebuffer"]),function(e,t){t.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass"),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Ts.newInstance({numberOfComponents:3,values:e});o.setName("points");const a=Ts.newInstance({numberOfComponents:2,values:n});a.setName("tcoords");const i=Ts.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,"polys",Oh.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=Zd.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=Ju.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw({width:n[0],height:n[1],numComps:4,dataType:"Float32Array",data:null}),t.translucentRTexture=Ju.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw({width:n[0],height:n[1],numComps:1,dataType:"Float32Array",data:null}),t.translucentZTexture=Ju.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw({width:n[0],height:n[1],dataType:"Float32Array",data:null}),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","attribute vec2 tcoordTC;","varying vec2 tcoord;","void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"),"//VTK::System::Dec\n\nin vec2 tcoord;\n\nuniform sampler2D translucentRTexture;\nuniform sampler2D translucentRGBATexture;\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\n  float t2Color = texture(translucentRTexture, tcoord).r;\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\n}\n","")},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||Ph("Error setting vertexDC in copy shader VAO."),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"tcoordTC",t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||Ph("Error setting vertexDC in copy shader VAO.")},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension("EXT_color_buffer_half_float")&&!i.getExtension("EXT_color_buffer_float"))return e.setCurrentOperation("translucentPass"),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation("opaqueZBufferPass"),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation("translucentPass"),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=Ru.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi("translucentRGBATexture",t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi("translucentRTexture",t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate();const s=r.getTiledSizeAndOrigin();i.scissor(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize),i.viewport(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize)},e.getShaderReplacement=()=>t._supported?Rh:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}(e,t)}var Vh={newInstance:Ht.newInstance(Eh,"vtkOpenGLOrderIndependentTranslucentPass"),extend:Eh};const Dh={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function Lh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Dh,n),wh.extend(e,t,n),Ht.get(e,t,["framebuffer","opaqueActorCount","translucentActorCount","volumeCount"]),function(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getRenderable().getRenderersByReference();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getViewNodeFor(i);if(i.getDraw()&&i.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation("queryPass"),s.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=Zd.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation("zBufferPass"),s.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation("cameraPass"),s.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation("opaquePass"),s.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Vh.newInstance()),t.translucentPass.traverse(n,s,e)),t.volumeCount>0&&(e.setCurrentOperation("volumePass"),s.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation("overlayPass"),s.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}(e,t)}var Bh={newInstance:Ht.newInstance(Lh,"vtkForwardPass"),extend:Lh},Nh=n(292),Fh=n.n(Nh);const _h=["lastShaderProgramBound","context","_openGLRenderWindow"],kh={lastShaderProgramBound:null,shaderPrograms:null,context:null};function Gh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kh,n),t.shaderPrograms={},Ht.obj(e,t),Ht.setGet(e,t,_h),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkShaderCache"),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=wu.substitute(o,"VSOut","GSOut").result);const a=t._openGLRenderWindow.getWebgl2();let i="\n",s="#version 100\n";a?s="#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n":(t.context.getExtension("OES_standard_derivatives"),t.context.getExtension("EXT_frag_depth")&&(i="#extension GL_EXT_frag_depth : enable\n"),t.context.getExtension("EXT_shader_texture_lod")&&(i+="#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT")),o=wu.substitute(o,"//VTK::System::Dec",[`${s}\n`,a?"":"#extension GL_OES_standard_derivatives : enable\n",i,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;let l=wu.substitute(e,"//VTK::System::Dec",[`${s}\n`,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;if(a){l=wu.substitute(l,"varying","out").result,o=wu.substitute(o,"varying","in").result;let e="",t=0;for(;o.includes(`gl_FragData[${t}]`);)o=wu.substitute(o,`gl_FragData\\[${t}\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\n`,t++;o=wu.substitute(o,"//VTK::Output::Dec",e).result}return{VSSource:l,FSSource:o,GSSource:wu.substitute(r,"//VTK::System::Dec",s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=Fh().hash(o);if(!(a in t.shaderPrograms)){const o=wu.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}(e,t)}var Uh={newInstance:Ht.newInstance(Gh,"vtkShaderCache"),extend:Gh};const{vtkErrorMacro:zh}=Ht,Wh={context:null,numberOfTextureUnits:0,textureUnits:0};function Hh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wh,n),Ht.obj(e,t),t.textureUnits=[],Ht.get(e,t,["numberOfTextureUnits"]),Ht.setGet(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLTextureUnitManager"),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&zh("some texture units  were not properly released");t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}(e,t)}var jh={newInstance:Ht.newInstance(Hh,"vtkOpenGLTextureUnitManager"),extend:Hh};const Kh={size:void 0,selector:void 0};function $h(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kh,n),t.size||(t.size=[300,300]),Ht.getArray(e,t,["size"],2),Ht.get(e,t,["selector"]),Xt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkRenderWindowViewNode"),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{Ht.vtkErrorMacro("not implemented")},e.getPixelData=(e,t,n,r)=>{Ht.vtkErrorMacro("not implemented")},e.createSelector=()=>{Ht.vtkErrorMacro("not implemented")}}(e,t)}var qh={newInstance:Ht.newInstance($h,"vtkRenderWindowViewNode"),extend:$h};const{vtkDebugMacro:Xh,vtkErrorMacro:Yh}=Ht,Zh={position:"absolute",top:0,left:0,width:"100%",height:"100%"},Qh=["activateTexture","deactivateTexture","disableCullFace","enableCullFace","get3DContext","getActiveFramebuffer","getContext","getDefaultTextureByteSize","getDefaultTextureInternalFormat","getDefaultToWebgl2","getGLInformations","getGraphicsMemoryInfo","getGraphicsResourceForObject","getHardwareMaximumLineWidth","getPixelData","getShaderCache","getTextureUnitForTexture","getTextureUnitManager","getWebgl2","makeCurrent","releaseGraphicsResources","registerGraphicsResourceUser","unregisterGraphicsResourceUser","restoreContext","setActiveFramebuffer","setContext","setDefaultToWebgl2","setGraphicsResourceForObject"];function Jh(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let ev=0;const tv=[];function nv(e){e.preventDefault()}function rv(e,t){let n;t.classHierarchy.push("vtkOpenGLRenderWindow"),e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener("webglcontextlost",nv,!1),t.canvas.addEventListener("webglcontextrestored",e.restoreContext,!1);const r=[0,0];let o;e.onModified((function(){t.renderable&&(t.size[0]===r[0]&&t.size[1]===r[1]||(r[0]=t.size[0],r[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.addMissingNodes(t.renderable.getChildRenderWindowsByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow?.(e)}))}},e.initialize=()=>{if(!t.initialized){if(t.rootOpenGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.rootOpenGLRenderWindow)t.context2D=e.get2DContext();else{t.context=e.get3DContext(),e.resizeFromChildRenderWindows(),t.context&&(ev++,tv.forEach((e=>e(ev)))),t.textureUnitManager=jh.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND)}t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Yh("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>{const e=t.activeFramebuffer?.getSize();return e||t.size},e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:"high-performance"},r=null;const o="undefined"!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(r=t.canvas.getContext("webgl2",e),r&&(t.webgl2=!0,Xh("using webgl2"))),r||(Xh("using webgl1"),r=t.canvas.getContext("webgl",e)||t.canvas.getContext("experimental-webgl",e)),new Proxy(r,(n||(n=function(){const e=new Map,t={apply(t,n,r){return e.has(r[0])?e.get(r[0]):t.apply(n,r)}},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply(t,n,r){return e.set(a,r[0]),t.apply(n,r)}}));var a},{get(e,t,r){if("__getUnderlyingContext"===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}()),n))},e.get2DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.canvas.getContext("2d",e)},e.restoreContext=()=>{const t=wh.newInstance();t.setCurrentOperation("Release"),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?Yh("Hardware does not support the number of textures defined."):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case is.CHAR:case is.SIGNED_CHAR:case is.UNSIGNED_CHAR:return 1;case n:case r:case is.UNSIGNED_SHORT:case is.SHORT:case is.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case is.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&is.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&is.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return o?t.context.R16F:t.context.R32F;case 2:return o?t.context.RG16F:t.context.RG32F;case 3:return o?t.context.RGB16F:t.context.RGB32F;default:return o?t.context.RGBA16F:t.context.RGBA32F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Zh,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t.rootOpenGLRenderWindow?.resizeFromChildRenderWindows(),t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=o)return o;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return o=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension("OES_texture_float"),o=n.getExtension("OES_texture_half_float"),a=n.getExtension("WEBGL_debug_renderer_info"),i=n.getExtension("WEBGL_draw_buffers"),s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),l=[["Max Vertex Attributes","MAX_VERTEX_ATTRIBS",n.getParameter(n.MAX_VERTEX_ATTRIBS)],["Max Varying Vectors","MAX_VARYING_VECTORS",n.getParameter(n.MAX_VARYING_VECTORS)],["Max Vertex Uniform Vectors","MAX_VERTEX_UNIFORM_VECTORS",n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],["Max Fragment Uniform Vectors","MAX_FRAGMENT_UNIFORM_VECTORS",n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],["Max Fragment Texture Image Units","MAX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],["Max Vertex Texture Image Units","MAX_VERTEX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],["Max Combined Texture Image Units","MAX_COMBINED_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],["Max 2D Texture Size","MAX_TEXTURE_SIZE",n.getParameter(n.MAX_TEXTURE_SIZE)],["Max Cube Texture Size","MAX_CUBE_MAP_TEXTURE_SIZE",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],["Max Texture Anisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT",s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],["Point Size Range","ALIASED_POINT_SIZE_RANGE",n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(" - ")],["Line Width Range","ALIASED_LINE_WIDTH_RANGE",n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(" - ")],["Max Viewport Dimensions","MAX_VIEWPORT_DIMS",n.getParameter(n.MAX_VIEWPORT_DIMS).join(" - ")],["Max Renderbuffer Size","MAX_RENDERBUFFER_SIZE",n.getParameter(n.MAX_RENDERBUFFER_SIZE)],["Framebuffer Red Bits","RED_BITS",n.getParameter(n.RED_BITS)],["Framebuffer Green Bits","GREEN_BITS",n.getParameter(n.GREEN_BITS)],["Framebuffer Blue Bits","BLUE_BITS",n.getParameter(n.BLUE_BITS)],["Framebuffer Alpha Bits","ALPHA_BITS",n.getParameter(n.ALPHA_BITS)],["Framebuffer Depth Bits","DEPTH_BITS",n.getParameter(n.DEPTH_BITS)],["Framebuffer Stencil Bits","STENCIL_BITS",n.getParameter(n.STENCIL_BITS)],["Framebuffer Subpixel Bits","SUBPIXEL_BITS",n.getParameter(n.SUBPIXEL_BITS)],["MSAA Samples","SAMPLES",n.getParameter(n.SAMPLES)],["MSAA Sample Buffers","SAMPLE_BUFFERS",n.getParameter(n.SAMPLE_BUFFERS)],["Supported Formats for UByte Render Targets     ","UNSIGNED_BYTE RENDER TARGET FORMATS",[r&&Jh(n,n.RGBA,n.UNSIGNED_BYTE)?"RGBA":"",r&&Jh(n,n.RGB,n.UNSIGNED_BYTE)?"RGB":"",r&&Jh(n,n.LUMINANCE,n.UNSIGNED_BYTE)?"LUMINANCE":"",r&&Jh(n,n.ALPHA,n.UNSIGNED_BYTE)?"ALPHA":"",r&&Jh(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Half Float Render Targets","HALF FLOAT RENDER TARGET FORMATS",[o&&Jh(n,n.RGBA,o.HALF_FLOAT_OES)?"RGBA":"",o&&Jh(n,n.RGB,o.HALF_FLOAT_OES)?"RGB":"",o&&Jh(n,n.LUMINANCE,o.HALF_FLOAT_OES)?"LUMINANCE":"",o&&Jh(n,n.ALPHA,o.HALF_FLOAT_OES)?"ALPHA":"",o&&Jh(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Full Float Render Targets","FLOAT RENDER TARGET FORMATS",[r&&Jh(n,n.RGBA,n.FLOAT)?"RGBA":"",r&&Jh(n,n.RGB,n.FLOAT)?"RGB":"",r&&Jh(n,n.LUMINANCE,n.FLOAT)?"LUMINANCE":"",r&&Jh(n,n.ALPHA,n.FLOAT)?"ALPHA":"",r&&Jh(n,n.LUMINANCE_ALPHA,n.FLOAT)?"LUMINANCE_ALPHA":""].join(" ")],["Max Multiple Render Targets Buffers","MAX_DRAW_BUFFERS_WEBGL",i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],["High Float Precision in Vertex Shader","HIGH_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Vertex Shader","MEDIUM_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Vertex Shader","LOW_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Float Precision in Fragment Shader","HIGH_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Fragment Shader","MEDIUM_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Fragment Shader","LOW_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Int Precision in Vertex Shader","HIGH_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Vertex Shader","MEDIUM_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Vertex Shader","LOW_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["High Int Precision in Fragment Shader","HIGH_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Fragment Shader","MEDIUM_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Fragment Shader","LOW_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["Supported Extensions","EXTENSIONS",n.getSupportedExtensions().join("<br/>\t\t\t\t\t    ")],["WebGL Renderer","RENDERER",n.getParameter(n.RENDERER)],["WebGL Vendor","VENDOR",n.getParameter(n.VENDOR)],["WebGL Version","VERSION",n.getParameter(n.VERSION)],["Shading Language Version","SHADING_LANGUAGE_VERSION",n.getParameter(n.SHADING_LANGUAGE_VERSION)],["Unmasked Renderer","UNMASKED_RENDERER",a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],["Unmasked Vendor","UNMASKED_VENDOR",a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],["WebGL Version","WEBGL_VERSION",t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);e.copyParentContent(),t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect();t.renderable.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const i=r.toDataURL(n);r.remove(),e.invokeImageReady(i)}();const n=t.renderable.getChildRenderWindowsByReference();for(let t=0;t<n.length;++t)e.getViewNodeFor(n[t])?.traverseAllPasses()},e.copyParentContent=()=>{const e=t.rootOpenGLRenderWindow;if(!e||!t.context2D||t.children.some((e=>!!e.getSelector?.())))return;const n=e.getCanvas(),r=t.canvas;t.context2D.drawImage(n,0,n.height-r.height,r.width,r.height,0,0,r.width,r.height)},e.resizeFromChildRenderWindows=()=>{const n=t.renderable.getChildRenderWindowsByReference();if(n.length>0){const t=[0,0];for(let r=0;r<n.length;++r){const o=e.getViewNodeFor(n[r])?.getSize();o&&(t[0]=o[0]>t[0]?o[0]:t[0],t[1]=o[1]>t[1]?o[1]:t[1])}e.setSize(...t)}},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=gp.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=Ht.chain((()=>{t.context&&(ev--,tv.forEach((e=>e(ev)))),e.setContainer(),e.setViewStream()}),(function(){t.canvas.removeEventListener("webglcontextlost",nv),t.canvas.removeEventListener("webglcontextrestored",e.restoreContext)}),e.delete),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const a=e.setSize;e.setSize=(t,n)=>{const r=a(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.registerGraphicsResourceUser=(n,r)=>{t._graphicsResources.has(n)||e.setGraphicsResourceForObject(n,null,null);const o=t._graphicsResources.get(n);o?.users.add(r)},e.unregisterGraphicsResourceUser=(n,r)=>{const o=t._graphicsResources.get(n);o&&(o.users.delete(r),o.users.size||(o.oglObject?.releaseGraphicsResources(e),t._graphicsResources.delete(n)))},e.getGraphicsResourceForObject=e=>t._graphicsResources.get(e),e.setGraphicsResourceForObject=(n,r,o)=>{if(!n)return;const a=t._graphicsResources.get(n);a?.oglObject?.releaseGraphicsResources(e),t._graphicsResources.set(n,{coreObject:n,oglObject:r,hash:o,users:a?.users??new Set})},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach((t=>{let{oglObject:n}=t;e+=n.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach((t=>{let{oglObject:n}=t;n.releaseGraphicsResources(e)})),t._graphicsResources.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{const n=e.getViewNodeFor(t);n?.releaseGraphicsResources()}))};const i={...e};Qh.forEach((n=>{e[n]=function(){return t.rootOpenGLRenderWindow?t.rootOpenGLRenderWindow[n](...arguments):i[n](...arguments)}}))}const ov={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,context2D:null,canvas:null,cursorVisibility:!0,cursor:"pointer",textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1};const av=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ov,n),qh.extend(e,t,n),t.canvas||(t.canvas=document.createElement("canvas"),t.canvas.style.width="100%"),t.selector||(t.selector=gp.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",t._textureResourceIds=new Map,t._graphicsResources=new Map,t._glInformation=null,t.myFactory=rn.newInstance(),t.shaderCache=Uh.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=Bh.newInstance(),Ht.get(e,t,["shaderCache","textureUnitManager","webgl2","useBackgroundImage","activeFramebuffer","rootOpenGLRenderWindow"]),Ht.setGet(e,t,["initialized","context","context2D","canvas","renderPasses","notifyStartCaptureImage","defaultToWebgl2","cursor","useOffScreen"]),Ht.setGetArray(e,t,["size"],2),Ht.event(e,t,"imageReady"),Ht.event(e,t,"windowResizeEvent"),rv(e,t)}),"vtkOpenGLRenderWindow");_m("WebGL",av),en("vtkRenderWindow",av);const iv={device:null,handle:null};function sv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,iv,n),Ht.obj(e,t),Ht.get(e,t,["lastCameraMTime"]),Ht.setGet(e,t,["device","handle"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderModule"),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}(e,t)}var lv={newInstance:Ht.newInstance(sv,"vtkWebGPUShaderModule"),extend:sv};const cv={shaderModules:null,device:null,window:null};function uv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cv,n),t._shaderModules=new Map,Ht.obj(e,t),Ht.setGet(e,t,["device","window"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderCache"),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=lv.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}(e,t)}var dv={newInstance:Ht.newInstance(uv,"vtkWebGPUShaderCache"),extend:uv,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join("\n"):n;let a=!1;-1!==e.search(t)&&(a=!0);let i="";r&&(i="g");const s=new RegExp(t,i);return{replace:a,result:e.replace(s,o)}}};const pv={device:null,handle:null,label:null};function fv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pv,n),Ht.obj(e,t),t.bindables=[],t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),Ht.get(e,t,["bindGroupTime","handle","sizeInBytes","usage"]),Ht.setGet(e,t,["label","device","arrayInformation"]),function(e,t){t.classHierarchy.push("vtkWebGPUBindGroup"),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join("\n")}}(e,t)}var gv={newInstance:Ht.newInstance(fv),extend:fv};const mv={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function hv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mv,n),vt(e,t),t.layouts=[],t.shaderDescriptions=[],yt(e,t,["handle","pipelineDescription"]),St(e,t,["device","renderEncoder","topology","vertexState"]),function(e,t){t.classHierarchy.push("vtkWebGPUPipeline"),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);"vertex"===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint="main"),"fragment"===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint="main")}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}(e,t)}var vv={newInstance:Et(hv,"vtkWebGPUPipeline"),extend:hv};const Tv={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function yv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tv,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],Ht.obj(e,t),Ht.setGet(e,t,["type","hash","code"]),Ht.getArray(e,t,["outputTypes","outputNames","outputInterpolations"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderDescription"),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push("};"),o=n,r[r.length-1]+=",",r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=dv.substitute(t.code,"//VTK::IOStructs::Input",r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push("};"),o=o.concat(e),t.code=dv.substitute(t.code,"//VTK::IOStructs::Output",[`-> ${t.type}Output`]).result}t.code=dv.substitute(t.code,"//VTK::IOStructs::Dec",o).result}}(e,t)}var bv={newInstance:Ht.newInstance(yv,"vtkWebGPUShaderDescription"),extend:yv};const xv={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"float"},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"float"},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"sint"},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"uint"},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:"sint"},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:"float"},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"float"},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"float"},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"uint"},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"sint"},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:"uint"},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:"sint"},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"unfilterable-float"},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:"uint"},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:"sint"},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:"float"},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"rgba8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"float"},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"uint"},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"sint"},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"bgra8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:"float"},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:"uint"},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:"sint"},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:"unfilterable-float"},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:"uint"},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:"sint"},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:"float"},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:"uint"},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:"sint"},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:"unfilterable-float"},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"depth"},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:"depth"},"depth24plus-stencil8":{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:"mixed"},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"depth"}};var Cv=function(e){return!e||e.length<6?0:e in xv==1?xv[e]:(tt(`unknown format ${e}`),null)},Sv=function(e){if(!e||e.length<5)return 0;let t=1;"x"===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(tt(`unknown format ${e}`),0):t*(5-r/2)},Av=function(e){if(!e||e.length<5)return 0;let t;if("f"===e[0])t="Float";else if("s"===e[0])t="Int";else{if("u"!==e[0])return void tt(`unknown format ${e}`);t="Uint"}const n=e.split("x")[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+="Array",t;tt(`unknown format ${e}`)},Iv=function(e){let t;if("f"===e[0]||"n"===e[1])t="f32";else if("s"===e[0]&&"i"===e[1])t="i32";else{if("u"!==e[0]||"i"!==e[1])return void tt(`unknown format ${e}`);t="u32"}let n=1;return"x"===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},wv=function(e){if(!e)return 0;let t=1;return"vec"===e.substring(0,3)?t=Number(e[3]):"mat"===e.substring(0,3)&&(t=e[3]*e[5]),4*t},Ov=function(e){if(e)return e.includes("f32")?"Float32Array":e.includes("i32")?"Int32Array":e.includes("u32")?"Uint32Array":void tt(`unknown format ${e}`)};function Pv(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}const Rv={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function Mv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rv,n),vt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],St(e,t,["created","device","handle","indexBuffer"]),function(e,t){t.classHierarchy.push("vtkWebGPUVertexInput"),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"vertex",o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(Pv(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e="",n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=Iv(a.format);n>0&&(e+=",\n"),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}(e,t)}var Ev={newInstance:Et(Mv,"vtkWebGPUVertexInput"),extend:Mv};const Vv={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:"triangle-list",UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function Dv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vv,n),Xt.extend(e,t,n),t.textureViews=[],t.vertexInput=Ev.newInstance(),t.bindGroup=gv.newInstance({label:"mapperBG"}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||"\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n",t.vertexShaderTemplate=t.vertexShaderTemplate||"\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n",t.shaderReplacements=new Map,Ht.get(e,t,["pipeline","vertexInput"]),Ht.setGet(e,t,["additionalBindables","device","fragmentShaderTemplate","interpolate","numberOfInstances","numberOfVertices","pipelineHash","shaderReplacements","SSBO","textureViews","topology","UBO","vertexShaderTemplate","WebGPURenderer"]),function(e,t){t.classHierarchy.push("vtkWebGPUSimpleMapper"),e.generateShaderDescriptions=(n,r,o)=>{const a=bv.newInstance({type:"vertex",hash:n,code:t.vertexShaderTemplate}),i=bv.newInstance({type:"fragment",hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp("//VTK::[^:]*::","g"),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];"replaceShaderIOStructs"!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.replaceShaderCode(null,n),t.getShaderDescription("fragment").replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set("replaceShaderRenderEncoder",e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=dv.substitute(i,"//VTK::Renderer::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");i=s.getCode(),i=dv.substitute(i,"//VTK::Renderer::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderRenderer",e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=dv.substitute(i,"//VTK::Mapper::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");s.addBuiltinInput("bool","@builtin(front_facing) frontFacing"),i=s.getCode(),i=dv.substitute(i,"//VTK::Mapper::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderMapper",e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=dv.substitute(o,"//VTK::Position::Impl",["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription("vertex").addOutput("vec2<f32>","tcoordVS")},t.shaderReplacements.set("replaceShaderTCoord",e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=vv.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}(e,t)}var Lv={newInstance:Ht.newInstance(Dv,"vtkWebGPUSimpleMapper"),extend:Dv};const Bv={};function Nv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bv,n),Lv.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkWebGPUFullScreenQuad"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position"),r.addOutput("vec4<f32>","vertexVC");let o=r.getCode();o=dv.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);","output.vertexVC = vec4<f32>(vertexBC, 1);"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,["vertexBC"]),t.numberOfVertices=6}}(e,t)}var Fv={newInstance:Ht.newInstance(Nv,"vtkWebGPUFullScreenQuad"),extend:Nv};const _v=["setBindGroup","setIndexBuffer","setVertexBuffer","draw","drawIndexed"],kv={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function Gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),vt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:"load",storeOp:"store"}],depthStencilAttachment:{view:void 0,depthLoadOp:"clear",depthClearValue:0,depthStoreOp:"store"}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=dv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = computedColor;"]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater-equal",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}},t.colorTextureViews=[],yt(e,t,["boundPipeline","colorTextureViews"]),St(e,t,["depthTextureView","description","handle","label","pipelineHash","pipelineSettings","replaceShaderCodeFunction"]),function(e,t){t.classHierarchy.push("vtkWebGPURenderEncoder"),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!("depthStencil"in n))console.log("mismatched depth attachments"),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\n${o}\n versus pipeline\n${a}\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<_v.length;n++)e[_v[n]]=function(){return t.handle[_v[n]](...arguments)}}(e,t)}var Uv={newInstance:Et(Gv,"vtkWebGPURenderEncoder"),extend:Gv};const zv={device:null,handle:null,label:null,options:null};function Wv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zv,n),Ht.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),Ht.get(e,t,["bindGroupTime","handle","options"]),Ht.setGet(e,t,["bindGroupLayoutEntry","device","label"]),function(e,t){t.classHierarchy.push("vtkWebGPUSampler"),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:"clamp-to-edge",t.options.addressModeV=n.addressModeV?n.addressModeV:"clamp-to-edge",t.options.addressModeW=n.addressModeW?n.addressModeW:"clamp-to-edge",t.options.magFilter=n.magFilter?n.magFilter:"nearest",t.options.minFilter=n.minFilter?n.minFilter:"nearest",t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:"nearest",t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}(e,t)}var Hv={newInstance:Ht.newInstance(Wv),extend:Wv};const jv={texture:null,handle:null,sampler:null,label:null};function Kv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jv,n),Ht.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d"}},t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),Ht.get(e,t,["bindGroupTime","texture"]),Ht.setGet(e,t,["bindGroupLayoutEntry","label","sampler"]),function(e,t){t.classHierarchy.push("vtkWebGPUTextureView"),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=Cv(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=Cv(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r="f32";"sint"===t.bindGroupLayoutEntry.texture.sampleType?r="i32":"uint"===t.bindGroupLayoutEntry.texture.sampleType&&(r="u32");let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return"depth"===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=Hv.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}(e,t)}var $v={newInstance:Ht.newInstance(Kv),extend:Kv};const qv={device:null,handle:null,buffer:null,ready:!1,label:null};function Xv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qv,n),Ht.obj(e,t),Ht.get(e,t,["handle","ready","width","height","depth","format","usage"]),Ht.setGet(e,t,["device","label"]),function(e,t){t.classHierarchy.push("vtkWebGPUTexture"),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?"2d":"3d";t.format=n.format?n.format:"rgba8unorm",t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:"rgba8unorm",t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];const o=r=>{t.device.getHandle().queue.copyExternalImageToTexture({source:r,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0,mipLevel:0,origin:{x:0,y:0,z:0}},[r.width,r.height,t.depth]),3!==e.getDimensionality()&&t.mipLevel>0&&zc.generateMipmaps(t.device.getHandle(),t.handle,t.mipLevel+1),t.ready=!0};if(n.canvas)return void o(n.canvas);if(n.imageBitmap)return n.width=n.imageBitmap.width,n.height=n.imageBitmap.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.imageBitmap);if(n.jsImageData)return n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.jsImageData);if(n.image)return n.width=n.image.width,n.height=n.image.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.image);const a=Cv(t.format);let i=t.width*a.stride;n.nativeArray&&(r=n.nativeArray);const s=3===e.getDimensionality(),l=((e,t,n)=>{const r=2===a.elementSize&&"float"===a.sampleType,o=e.BYTES_PER_ELEMENT,i=e.length/(t*n)*o;if(!r&&i%256==0)return[e,i];const s=i/o,l=a.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=Ht.newTypedArray(r?"Uint16Array":e.constructor.name,u*t*n),p=t*n;if(r)for(let t=0;t<p;t++){const n=t*s,r=t*u;for(let t=0;t<s;t++)d[r+t]=ku.toHalf(e[n+t])}else if(u===s)d.set(e);else for(let t=0;t<p;t++)d.set(e.subarray(t*s,(t+1)*s),t*u);return[d,c]})(r,t.height,s?t.depth:1);i=l[1];const c=l[0];t.device.getHandle().queue.writeTexture({texture:t.handle,mipLevel:0,origin:{x:0,y:0,z:0}},c,{offset:0,bytesPerRow:i,rowsPerImage:t.height},{width:t.width,height:t.height,depthOrArrayLayers:s?t.depth:1}),!s&&t.mipLevel>0&&zc.generateMipmaps(t.device.getHandle(),t.handle,t.mipLevel+1),t.ready=!0},e.getScale=()=>{const e=Cv(t.format);return 2===e.elementSize&&"float"===e.sampleType?1:255},e.getNumberOfComponents=()=>Cv(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?"2d":"3d");const o=$v.newInstance({label:n});return o.create(e,r),o}}(e,t)}var Yv={newInstance:Ht.newInstance(Xv),extend:Xv};const Zv={renderEncoder:null,colorTexture:null,depthTexture:null};function Qv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zv,n),wh.extend(e,t,n),Ht.get(e,t,["colorTexture","depthTexture"]),function(e,t){t.classHierarchy.push("vtkWebGPUOpaquePass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=Yv.newInstance({label:"opaquePassColor"}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView("opaquePassColorTexture");t.renderEncoder.setColorTextureView(0,n),t.depthFormat="depth32float",t.depthTexture=Yv.newInstance({label:"opaquePassDepth"}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("opaquePassDepthTexture");t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation("opaquePass"),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=Uv.newInstance({label:"OpaquePass"}),t.renderEncoder.setPipelineHash("op")}}(e,t)}var Jv={newInstance:Ht.newInstance(Qv,"vtkWebGPUOpaquePass"),extend:Qv};const eT={colorTextureView:null,depthTextureView:null};function tT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eT,n),wh.extend(e,t,n),Ht.setGet(e,t,["colorTextureView","depthTextureView"]),function(e,t){t.classHierarchy.push("vtkWebGPUOrderIndependentTranslucentPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=Yv.newInstance({label:"translucentPassColor"}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView("oitpColorTexture");t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=Yv.newInstance({label:"translucentPassAccumulate"}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView("oitpAccumTexture");t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=Fv.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash("oitpfsq"),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\n  if (reveal == 1.0) { discard; }\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\n  var total: f32 = max(tcolor.a, 0.01);\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n")}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation("translucentPass"),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=Uv.newInstance({label:"translucentRender"});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:void 0,clearValue:[1,0,0,0],loadOp:"clear",storeOp:"store"}],e.depthStencilAttachment={view:void 0,depthLoadOp:"load",depthStoreOp:"store"},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addOutput("f32","outAccum"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=dv.substitute(n,"//VTK::RenderEncoder::Impl",["var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);","output.outColor = vec4<f32>(computedColor.rgb*w, w);","output.outAccum = computedColor.a;"]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash("oitpr"),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!1,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one"},alpha:{srcFactor:"one",dstFactor:"one"}}},{format:"r16float",blend:{color:{srcFactor:"zero",dstFactor:"one-minus-src"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=Uv.newInstance({label:"translucentFinal"}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=dv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash("oitpf"),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})}}(e,t)}var nT={newInstance:Ht.newInstance(tT,"vtkWebGPUOrderIndependentTranslucentPass"),extend:tT},rT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const oT=["getMappedRange","mapAsync","unmap"];const aT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function iT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,aT,n),Ht.obj(e,t),Ht.get(e,t,["handle","sizeInBytes","usage"]),Ht.setGet(e,t,["strideInBytes","device","arrayInformation","label","sourceTime"]),function(e,t){t.classHierarchy.push("vtkWebGPUBuffer"),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{const r=4*Math.ceil(e.byteLength/4);t.handle=t.device.getHandle().createBuffer({size:r,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=r,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<oT.length;n++)e[oT[n]]=function(){return t.handle[oT[n]](...arguments)}}(e,t)}var sT={newInstance:Ht.newInstance(iT),extend:iT,...rT};const{Representation:lT}=ts,{PrimitiveTypes:cT}=rT;class uT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function dT(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function pT(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=dT(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=dT(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=dT(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=dT(n,o,t),n.ibo[n.iboId++]=a}function fT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let gT;const mT=new Uint32Array(1),hT=new Uint32Array(2),vT=new Uint32Array(3),TT={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)mT[0]=t[n+a],gT(mT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)hT[0]=t[n+a],hT[1]=t[n+a+1],gT(hT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)hT[0]=t[n+a],hT[1]=t[n+(a+1)%e],gT(hT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)hT[0]=t[n+a],hT[1]=t[n+a+1],gT(hT,r,o);for(let a=0;a<e-2;a++)hT[0]=t[n+a],hT[1]=t[n+a+2],gT(hT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)vT[0]=t[n],vT[1]=t[n+a+1],vT[2]=t[n+a+2],gT(vT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)vT[0]=t[n+a],vT[1]=t[n+a+1+a%2],vT[2]=t[n+a+1+(a+1)%2],gT(vT,r,o)}};const yT={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function bT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,yT,n),sT.extend(e,t,n),Ht.setGet(e,t,["flatIdToPointId","flatIdToCellId","flatSize","indexCount"]),function(e,t){t.classHierarchy.push("vtkWebGPUIndexBuffer"),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case cT.Points:return"points";case cT.Lines:return"lines";case cT.Triangles:case cT.TriangleEdges:return"polys";case cT.TriangleStripEdges:case cT.TriangleStrips:return"strips";default:return""}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new uT};let d=null;d=o===lT.POINTS||r===cT.Points?TT.anythingToPoints:o===lT.WIREFRAME||r===cT.Lines?TT[`${l}ToWireframe`]:TT[`${l}ToSurface`],gT=fT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format="uint16"):(u.ibo=new Uint32Array(u.iboSize),e.format="uint32"),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),gT=pT,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}(e,t)}var xT={newInstance:Ht.newInstance(bT),extend:bT,...rT};const{BufferUsage:CT}=rT,{vtkErrorMacro:ST}=jt,{VtkDataTypes:AT}=Ts;function IT(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,"packExtra")&&o.packExtra;let u,d=0;const p=it(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function wT(e,t,n,r){const o=[];return Fo([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),ko(o),o}const OT={device:null,fullScreenQuadBuffer:null};function PT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,OT,n),vt(e,t),St(e,t,["device"]),function(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===CT.Index&&(n=xT.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=sT.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===CT.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===CT.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===CT.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===CT.PointArray){r=GPUBufferUsage.VERTEX;const t=Av(e.format),o=IT(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(Sv(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?"flat":"perspective"}])}if(e.usage===CT.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=Av(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=wT(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=IT(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(Sv(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:"flat"}])}return e.usage===CT.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(Sv(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push("vtkWebGPUBufferManager"),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case AT.UNSIGNED_CHAR:t="uint8";break;case AT.FLOAT:t="float32";break;case AT.UNSIGNED_INT:t="uint32";break;case AT.INT:t="sint32";break;case AT.DOUBLE:t="float32";break;case AT.UNSIGNED_SHORT:t="uint16";break;case AT.SHORT:t="sin16";break;default:t="float32"}switch(e.getNumberOfComponents()){case 2:t+="x2";break;case 3:t.includes("32")||ST(`unsupported x3 type for ${t}`),t+="x3";break;case 4:t+="x4"}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:CT.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=sT.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:"float32x3"}]),t.fullScreenQuadBuffer}}(e,t)}var RT={newInstance:Et(PT),extend:PT,...rT};const{BufferUsage:MT}=RT,{vtkErrorMacro:ET}=Ht,VT={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function DT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,VT,n),Ht.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"uniform"}},t.sendTime={},Ht.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,Ht.get(e,t,["binding","bindGroupTime"]),Ht.setGet(e,t,["bindGroupLayoutEntry","device","label","sizeInBytes"]),function(e,t){t.classHierarchy.push("vtkWebGPUUniformBuffer"),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?ET(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:wv(n),offset:-1,nativeType:Ov(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:MT.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=Ht.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void ET(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void ET(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join("\n")}}(e,t)}var LT={newInstance:Ht.newInstance(DT,"vtkWebGPUUniformBuffer"),extend:DT};const{BufferUsage:BT}=RT,{vtkErrorMacro:NT}=Ht,FT={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function _T(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,FT,n),Ht.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},Ht.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"read-only-storage"}},Ht.get(e,t,["bindGroupTime"]),Ht.setGet(e,t,["device","bindGroupLayoutEntry","label","numberOfInstances","sizeInBytes"]),function(e,t){t.classHierarchy.push("vtkWebGPUStorageBuffer"),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void NT(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=wv(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:Ov(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:BT.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=Ht.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void NT(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void NT(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void NT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void NT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void NT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\n};\nstruct ${t.label}Struct\n{\n  values: array<${t.label}StructEntry>,\n};\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\n`),r.join("\n")},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}(e,t)}var kT={newInstance:Ht.newInstance(_T,"vtkWebGPUStorageBuffer"),extend:_T};const GT=new Float64Array(16),UT=new Float64Array(16),zT={volumes:null,rowLength:1024,lastVolumeLength:0};function WT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zT,n),Fv.extend(e,t,n),t.fragmentShaderTemplate="\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n",t.UBO=LT.newInstance({label:"mapperUBO"}),t.UBO.addEntry("SampleDistance","f32"),t.SSBO=kT.newInstance({label:"volumeSSBO"}),t.componentSSBO=kT.newInstance({label:"componentSSBO"}),t.lutBuildTime={},Ht.obj(t.lutBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkWebGPUVolumePassFSQ"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=dv.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);"]).result,r.setCode(o),t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription("fragment");let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===wf.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push("    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);")):(s.push(`  sampleColor = traverseVals[${e}];`),s.push("  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);"));a=dv.substitute(a,"//VTK::Volume::CompositeCalls",i).result,a=dv.substitute(a,"//VTK::Volume::TraverseCalls",s).result,a=dv.substitute(a,"//VTK::Volume::TraverseDec",[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===wf.COMPOSITE_BLEND?l=!0:n===wf.MAXIMUM_INTENSITY_BLEND?a=dv.substitute(a,"//VTK::Volume::Loop",[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===wf.MINIMUM_INTENSITY_BLEND?a=dv.substitute(a,"//VTK::Volume::Loop",[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===wf.AVERAGE_INTENSITY_BLEND?a=dv.substitute(a,"//VTK::Volume::Loop",[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===wf.ADDITIVE_INTENSITY_BLEND&&(a=dv.substitute(a,"//VTK::Volume::Loop",[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result)}l&&(a=dv.substitute(a,"//VTK::Volume::Loop",["    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);"]).result),o.setCode(a)},t.shaderReplacements.set("replaceShaderVolume",e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8ClampedArray(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:"rgba8unorm"},r=n.getTextureManager().getTexture(e).createView("tfunTexture");t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:"r16float"},r=n.getTextureManager().getTexture(e).createView("ofunTexture");t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper().getInputData();g(GT),b(GT,GT,o);const d=n.getMatrix();m(UT,d),h(UT,UT),y(GT,UT,GT);const p=r.getWorldToIndex();y(GT,p,GT);const f=r.getDimensions();g(UT),x(UT,UT,[1/f[0],1/f[1],1/f[2]]),y(GT,UT,GT);for(let t=0;t<16;t++)a[16*e+t]=GT[t];h(GT,GT);for(let t=0;t<4;t++)i[16*e+4*t]=GT[4*t],i[16*e+4*t+1]=GT[4*t+1],i[16*e+4*t+2]=GT[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/f[0],s[4*e+1]=1/f[1],s[4*e+2]=1/f[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const v=r.getSpacing();c[4*e]=v[0],c[4*e+1]=v[1],c[4*e+2]=v[2],c[4*e+3]=1;const T=t.textureViews[e+4].getTexture().getScale(),C=n.getProperty().getIpScalarRange();u[4*e]=C[0]/T,u[4*e+1]=C[1]/T,u[4*e+2]=n.getProperty().getFilterMode()}t.SSBO.addEntry("SCTCMatrix","mat4x4<f32>"),t.SSBO.addEntry("planeNormals","mat4x4<f32>"),t.SSBO.addEntry("shade","vec4<f32>"),t.SSBO.addEntry("tstep","vec4<f32>"),t.SSBO.addEntry("spacing","vec4<f32>"),t.SSBO.addEntry("ipScalarRange","vec4<f32>"),t.SSBO.setAllInstancesFromArray("SCTCMatrix",a),t.SSBO.setAllInstancesFromArray("planeNormals",i),t.SSBO.setAllInstancesFromArray("shade",l),t.SSBO.setAllInstancesFromArray("tstep",s),t.SSBO.setAllInstancesFromArray("spacing",c),t.SSBO.setAllInstancesFromArray("ipScalarRange",u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),T=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=Cv(l),u={scale:[255],offset:[0]};2===c.elementSize&&"float"===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);T[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else T[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry("cScale","f32"),t.componentSSBO.addEntry("cShift","f32"),t.componentSSBO.addEntry("oScale","f32"),t.componentSSBO.addEntry("oShift","f32"),t.componentSSBO.addEntry("goShift","f32"),t.componentSSBO.addEntry("goScale","f32"),t.componentSSBO.addEntry("gomin","f32"),t.componentSSBO.addEntry("gomax","f32"),t.componentSSBO.setAllInstancesFromArray("cScale",d),t.componentSSBO.setAllInstancesFromArray("cShift",p),t.componentSSBO.setAllInstancesFromArray("oScale",f),t.componentSSBO.setAllInstancesFromArray("oShift",v),t.componentSSBO.setAllInstancesFromArray("goScale",A),t.componentSSBO.setAllInstancesFromArray("goShift",S),t.componentSSBO.setAllInstancesFromArray("gomin",T),t.componentSSBO.setAllInstancesFromArray("gomax",C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue("SampleDistance",r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=Hv.newInstance({label:"clampSampler"}),t.clampSampler.create(t.device,{minFilter:"linear",magFilter:"linear"}))},e.computePipelineHash=()=>{t.pipelineHash="volfsq";for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}(e,t)}var HT={newInstance:Ht.newInstance(WT,"vtkWebGPUVolumePassFSQ"),extend:WT};const{Representation:jT}=ts,{BufferUsage:KT,PrimitiveTypes:$T}=RT,qT=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],XT={colorTextureView:null,depthTextureView:null,volumes:null};function YT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,XT,n),wh.extend(e,t,n),t._mapper=Lv.newInstance(),t._mapper.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Select::Dec\n\n//VTK::VolumePass::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Select::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::VolumePass::Impl\n\n  // use the maximum (closest) of the current value and the zbuffer\n  // the blend func will then take the min to find the farthest stop value\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._mapper.getShaderReplacements().set("replaceShaderVolumePass",((e,t,n)=>{t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")})),t._boundsPoly=kc.newInstance(),t._lastMTimes=[],Ht.setGet(e,t,["colorTextureView","depthTextureView"]),function(e,t){t.classHierarchy.push("vtkWebGPUVolumePass"),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=HT.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=Fv.newInstance(),t._volumeCopyQuad.setPipelineHash("volpassfsq"),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._copyUBO=LT.newInstance({label:"mapperUBO"}),t._copyUBO.addEntry("tscale","vec2<f32>"),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Uo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray("tscale",[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray("tscale",[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=Ht.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:KT.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:$T.Triangles,representation:jT.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:KT.PointArray,format:"float32x4",hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,["vertexBC"]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+qT[e][0],l[n++]=r+qT[e][1],l[n++]=r+qT[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation("volumeDepthRangePass"),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=Uv.newInstance({label:"VolumePass DepthRange"}),t._depthRangeEncoder.setPipelineHash("volr"),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor1"),t.addOutput("vec4<f32>","outColor2");let n=t.getCode();n=dv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);","output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);"]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:null,clearValue:[1,1,1,1],loadOp:"clear",storeOp:"store"}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"max"},alpha:{srcFactor:"one",dstFactor:"one",operation:"max"}}},{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"min"},alpha:{srcFactor:"one",dstFactor:"one",operation:"min"}}}]}}),t._depthRangeTexture=Yv.newInstance({label:"volumePassMaxDepth"}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView("maxTexture");t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=Yv.newInstance({label:"volumePassDepthMin"}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView("minTexture");t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=Yv.newInstance({label:"volumePassColor"}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView("volumePassColorTexture"),t._colorTextureView.addSampler(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._clearEncoder=Uv.newInstance({label:"VolumePass Clear"}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),t._clearEncoder.setPipelineHash("volpf"),t._clearEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=Uv.newInstance({label:"volumePassCopy"}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._copyEncoder.setPipelineHash("volcopypf"),t._copyEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=Uv.newInstance({label:"volumePassMerge"}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=dv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash("volpf"),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}(e,t)}var ZT={newInstance:Ht.newInstance(YT,"vtkWebGPUVolumePass"),extend:YT};const QT={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function JT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,QT,n),wh.extend(e,t,n),Ht.setGet(e,t,["opaquePass","translucentPass","volumePass"]),function(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e),t.opaquePass||(t.opaquePass=Jv.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation("queryPass"),i.traverse(e),e.setCurrentOperation("cameraPass"),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=nT.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=ZT.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=Uv.newInstance({label:"forwardPassBlit"}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._finalBlitEncoder.setPipelineHash("fpf"),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}}),t._fsqSampler=Hv.newInstance({label:"finalPassSampler"}),t._fsqSampler.create(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._fullScreenQuad=Fv.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash("fpfsq"),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._finalBlitOutputTextureView=$v.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}(e,t)}var ey={newInstance:Ht.newInstance(JT,"vtkForwardPass"),extend:JT};const{VtkDataTypes:ty}=Ts,ny={handle:null,device:null};function ry(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ny,n),Ht.obj(e,t),Ht.setGet(e,t,["device"]),function(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format="r";break;case 2:e.format="rg";break;default:e.format="rgba"}switch(e.dataArray.getDataType()){case ty.UNSIGNED_CHAR:e.format+="8unorm";break;case ty.FLOAT:case ty.UNSIGNED_INT:case ty.INT:case ty.DOUBLE:case ty.UNSIGNED_SHORT:case ty.SHORT:default:e.format+="16float"}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.nativeArray=e.jsImageData.data,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.imageBitmap&&(e.width=e.imageBitmap.width,e.height=e.imageBitmap.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=Yv.newInstance({label:e.label});return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas||e.imageBitmap)&&n.writeImageData(e),n}t.classHierarchy.push("vtkWebGPUTextureManager"),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0;const o={time:e.getMTime(),label:r};return e.getInputData()?o.imageData=e.getInputData():e.getImage()?o.image=e.getImage():e.getJsImageData()?o.jsImageData=e.getJsImageData():e.getImageBitmap()?o.imageBitmap=e.getImageBitmap():e.getCanvas()&&(o.canvas=e.getCanvas()),n(o),o.mipLevel=e.getMipLevel(),o.hash=o.time+o.format+o.mipLevel,t.device.getTextureManager().getTexture(o)}}(e,t)}var oy={newInstance:Ht.newInstance(ry),extend:ry};class ay extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&"object"==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}const iy={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function sy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,iy,n),vt(e,t),St(e,t,["handle"]),yt(e,t,["bufferManager","shaderCache","textureManager"]),t.objectCache=new ay,t.shaderCache=dv.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=RT.newInstance(),t.bufferManager.setDevice(e),t.textureManager=oy.newInstance(),t.textureManager.setDevice(e),t.pipelines={},function(e,t){t.classHierarchy.push("vtkWebGPUDevice"),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro("layout not found"),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro("attempt to cache an object without a hash"),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}(e,t)}var ly={newInstance:Et(sy,"vtkWebGPUDevice"),extend:sy};const cy={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function uy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cy,n),wh.extend(e,t,n),Ht.get(e,t,["colorTexture","depthTexture"]),function(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelectionPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=Yv.newInstance({label:"hardwareSelectorColor"}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"rgba32uint",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView("hardwareSelectColorTexture");t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=Yv.newInstance({label:"hardwareSelectorDepth"}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("hardwareSelectDepthTexture");t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation("cameraPass"),r.traverse(e),e.setCurrentOperation("opaquePass"),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=Uv.newInstance({label:"HardwareSelectionPass"}),t.selectionRenderEncoder.setPipelineHash("sel"),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<u32>","outColor");let n=t.getCode();n=dv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);"]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba32uint",blend:void 0}]}})}}(e,t)}var dy={newInstance:Ht.newInstance(uy,"vtkWebGPUHardwareSelectionPass"),extend:uy};const{SelectionContent:py,SelectionField:fy}=ep,{FieldAssociations:gy}=_s,{vtkErrorMacro:my}=Ht;function hy(e){return`${e.propID} ${e.compositeID}`}function vy(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function Ty(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=vy(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=vy(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=Ty(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=Ty(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=Ty(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=Ty(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=Ty(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}const yy={};function by(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,yy,n),qd.extend(e,t,n),t._selectionPass=dy.newInstance(),Ht.setGet(e,t,["_WebGPURenderWindow"]),Ht.moveToProtected(e,t,["WebGPURenderWindow"]),function(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelector"),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return my("Renderer and view must be set before calling Select."),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=sT.newInstance({label:"hardwareSelectColorBuffer"});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=sT.newInstance({label:"hardwareSelectDepthBuffer"}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:"depth-only"},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=Ty(e,[n,t],0,u);if(r){const t=hy(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=ep.newInstance();switch(i.setContentType(py.INDICES),e){case gy.FIELD_ASSOCIATION_CELLS:i.setFieldType(fy.CELL);break;case gy.FIELD_ASSOCIATION_POINTS:i.setFieldType(fy.POINT);break;default:my("Unknown field association")}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}(e,t)}var xy={newInstance:Ht.newInstance(by,"vtkWebGPUHardwareSelector"),extend:by};const Cy=Object.create(null),Sy={};function Ay(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sy,n),t.overrides=Cy,Qt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkWebGPUViewNodeFactory")}(0,t)}var Iy={newInstance:Ht.newInstance(Ay,"vtkWebGPUViewNodeFactory"),extend:Ay};const{vtkErrorMacro:wy}=Ht,Oy={position:"absolute",top:0,left:0,width:"100%",height:"100%"};const Py={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:"pointer",containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const Ry=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Py,n),t.canvas=document.createElement("canvas"),t.canvas.style.width="100%",t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",qh.extend(e,t,n),t.myFactory=Iy.newInstance(),t.renderPasses[0]=ey.newInstance(),t.selector||(t.selector=xy.newInstance(),t.selector.setWebGPURenderWindow(e)),Ht.event(e,t,"imageReady"),Ht.event(e,t,"initialized"),Ht.get(e,t,["commandEncoder","device","presentationFormat","useBackgroundImage","xrSupported"]),Ht.setGet(e,t,["initialized","context","canvas","device","renderPasses","notifyStartCaptureImage","cursor","useOffScreen"]),Ht.setGetArray(e,t,["size"],2),Ht.event(e,t,"windowResizeEvent"),function(e,t){t.classHierarchy.push("vtkWebGPURenderWindow"),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void wy("WebGPU is not enabled.");e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&wy("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),t.deleted||(t.device=ly.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext("webgpu"))},e.releaseGraphicsResources=()=>{const n=wh.newInstance();n.setCurrentOperation("Release"),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Oy,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect();t.renderable.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const l=r.toDataURL(n);r.remove(),e.invokeImageReady(l)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=sT.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*ku.fromHalf(r.colorValues[o]),s[n+1]=255*ku.fromHalf(r.colorValues[o+1]),s[n+2]=255*ku.fromHalf(r.colorValues[o+2]),s[n+3]=255*ku.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=xy.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=Ht.chain(e.delete,e.setViewStream)}(e,t)}),"vtkWebGPURenderWindow");var My;_m("WebGPU",Ry),My=Ry,Cy.vtkRenderWindow=My;const Ey=Sh(),Vy={margin:"0",padding:"0",position:"absolute",top:"0",left:"0",width:"100%",height:"100%",overflow:"hidden"},Dy={position:"absolute",left:"25px",top:"25px",backgroundColor:"white",borderRadius:"5px",listStyle:"none",padding:"5px 10px",margin:"0",display:"block",border:"solid 1px black",maxWidth:"calc(100% - 70px)",maxHeight:"calc(100% - 60px)",overflow:"auto"};function Ly(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}const By={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function Ny(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,By,n),Ht.obj(e,t),Ht.get(e,t,["renderWindow","renderer","apiSpecificRenderWindow","interactor","rootContainer","container","controlContainer"]),function(e,t){t.classHierarchy.push("vtkFullScreenRenderWindow");const n=document.querySelector("body");function r(t){"c"===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement("div"),Ly(t.container,t.containerStyle||Vy),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height="100%",n.style.height="100%",n.style.padding="0",n.style.margin="0"),t.renderWindow=zm.newInstance(),t.renderer=Nm.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(Ey.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=ah.newInstance(),t.interactor.setInteractorStyle(bh.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?"block":"none")},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement("div"),Ly(t.controlContainer,t.controlPanelStyle||Dy),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener("keypress",r)},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=Ht.chain(e.setContainer,t.apiSpecificRenderWindow.delete,(()=>{t.rootContainer?.removeEventListener("keypress",r),window.removeEventListener("resize",e.resize)}),e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener("resize",e.resize),e.resize()}(e,t)}var Fy={newInstance:Ht.newInstance(Ny),extend:Ny},_y={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:ky,Scale:Gy}=_y,{ScalarMappingTarget:Uy}=il,{vtkDebugMacro:zy,vtkErrorMacro:Wy,vtkWarningMacro:Hy}=Ht;function jy(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function Ky(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function $y(e,t,n,r){const o=[],a=[];va(t,o),va(n,a);const i=[],s=[];jy(o,i),jy(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=Ky(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=Ky(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Ta(u,r)}const qy={clamping:!0,colorSpace:ky.RGB,hSVWrap:!0,scale:Gy.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function Xy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qy,n),il.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},Ht.obj(t.buildTime),Ht.get(e,t,["buildTime","mappingRange"]),Ht.setGet(e,t,["useAboveRangeColor","useBelowRangeColor","discretize","numberOfValues",{type:"enum",name:"colorSpace",enum:ky},{type:"enum",name:"scale",enum:Gy}]),Ht.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),Ht.getArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"]),function(e,t){t.classHierarchy.push("vtkColorTransferFunction"),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return Wy("Midpoint outside range [0.0, 1.0]"),-1;if(s<0||s>1)return Wy("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[];return pa([n,r,o],s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];pa([n,r,o],u),pa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.logScaleEnabled=()=>t.scale===Gy.LOG10,e.usingLogScale=()=>e.logScaleEnabled()&&t.mappingRange[0]>0,e.getTable=(n,r,o,a)=>{const i=e.usingLogScale(),s=i?Math.log10(Number(n)):Number(n),l=i?Math.log10(Number(r)):Number(r);if(Pa(s)||Pa(l)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let c=0;const u=t.nodes.length;let d=0,p=0,f=0;0!==u&&(d=t.nodes[u-1].r,p=t.nodes[u-1].g,f=t.nodes[u-1].b);let g=0,m=0,h=0;const v=[0,0,0],T=[0,0,0];let y=0,b=0;const x=[];let C=t.mappingRange;i&&(C=[Math.log10(t.mappingRange[0]),Math.log10(t.mappingRange[1])]);for(let n=0;n<o;n++){const r=3*n;if(g=o>1?s+n/(o-1)*(l-s):.5*(s+l),t.discretize){const e=C;if(g>=e[0]&&g<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)g=e[0]+r/2;else{const t=(g-e[0])/r,o=Co(n*t);g=e[0]+o/(n-1)*r}}}for(;c<u&&g>t.nodes[c].x;)c++,c<u&&(m=t.nodes[c-1].x,h=t.nodes[c].x,v[0]=t.nodes[c-1].r,T[0]=t.nodes[c].r,v[1]=t.nodes[c-1].g,T[1]=t.nodes[c].g,v[2]=t.nodes[c-1].b,T[2]=t.nodes[c].b,y=t.nodes[c-1].midpoint,b=t.nodes[c-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(g>C[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=d,a[r+1]=p,a[r+2]=f));else if(g<C[0]||Ia(g)&&g<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):u>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===c&&(Math.abs(g-s)<1e-6||t.discretize))u>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=(g-m)/(h-m),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),b>.99){if(e<.5){a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}a[r]=T[0],a[r+1]=T[1],a[r+2]=T[2];continue}if(b<.01){if(t.colorSpace===ky.RGB)a[r]=(1-e)*v[0]+e*T[0],a[r+1]=(1-e)*v[1]+e*T[1],a[r+2]=(1-e)*v[2]+e*T[2];else if(t.colorSpace===ky.HSV){const n=[],o=[];da(v,n),da(T,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],pa(i,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else if(t.colorSpace===ky.LAB){const t=[],n=[];va(v,t),va(T,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Ta(o,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else t.colorSpace===ky.DIVERGING?($y(e,v,T,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]):Wy("ColorSpace set to invalid value.",t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*b):e>.5&&(e=1-.5*(2*(1-e))**(1+10*b));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===ky.RGB)for(let e=0;e<3;e++)u=T[e]-v[e],d=(1-b)*u,a[r+e]=i*v[e]+s*T[e]+l*d+c*d;else if(t.colorSpace===ky.HSV){const e=[],n=[];da(v,e),da(T,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-b)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);pa(o,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else if(t.colorSpace===ky.LAB){const e=[],t=[];va(v,e),va(T,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-b)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Ta(n,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else t.colorSpace===ky.DIVERGING?($y(e,v,T,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]):Wy("ColorSpace set to invalid value.");for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return Wy("Attempting to lookup a value with no points in the function"),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(Wy("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return Wy("Index out of range!"),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>{if(t.indexedLookup&&e.getSize())return e.getSize();if(t.tableSize)return t.tableSize;const n=t.nodes?.length??0;return Math.max(4094,n)},e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=[n,r],i=e.getRange(),s=e.logScaleEnabled();if(i[1]===o[1]&&i[0]===o[0])return;if(o[1]===o[0])return void Wy("attempt to set zero width color range");s&&(o[0]<=0?console.warn("attempt to set log scale color range with non-positive minimum"):(a[0]=Math.log10(o[0]),a[1]=Math.log10(o[1])));const l=(a[1]-a[0])/(i[1]-i[0]),c=a[0]-i[0]*l;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*l+c;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):zy("Transfer Function Has No Points!")},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void Hy("Transfer Function Has No Points!");const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===Uy.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===Uy.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===Uy.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===Uy.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=ky[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(Wy(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=ky.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}(e,t)}var Yy={newInstance:Ht.newInstance(Xy,"vtkColorTransferFunction"),extend:Xy,..._y},Zy={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:Qy,ScaleModes:Jy}=Zy,{vtkErrorMacro:eb}=Ht,tb={orient:!0,orientationMode:Qy.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:Jy.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function nb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tb,n),Fl.extend(e,t,n),Ht.algo(e,t,2,0),t.buildTime={},Ht.obj(t.buildTime,{mtime:0}),t.boundsTime={},Ht.obj(t.boundsTime,{mtime:0}),Ht.setGet(e,t,["orient","orientationMode","orientationArray","scaleArray","scaleFactor","scaleMode","scaling"]),Ht.get(e,t,["colorArray","matrixArray","normalArray","buildTime"]),function(e,t){t.classHierarchy.push("vtkGlyph3DMapper"),e.getOrientationModeAsString=()=>Ht.enumToString(Qy,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(Qy.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(Qy.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(Qy.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>Ht.enumToString(Jy,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(Jy.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(Jy.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(Jy.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Ra()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===Jy.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(eb("Cannot scale by components since scale array does not have 3 components."),a=null);const l=r.getBounds(),c=[];Fi.getCorners(l,c),t.bounds[0]=Fi.INIT_BOUNDS[0],t.bounds[1]=Fi.INIT_BOUNDS[1],t.bounds[2]=Fi.INIT_BOUNDS[2],t.bounds[3]=Fi.INIT_BOUNDS[3],t.bounds[4]=Fi.INIT_BOUNDS[4],t.bounds[5]=Fi.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const T=t.normalArray.buffer,w=[],O=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,O),t.orientationMode){case Qy.MATRIX:y(n,n,[...O.slice(0,3),0,...O.slice(3,6),0,...O.slice(6,9),0,0,0,0,1]);break;case Qy.ROTATION:I(n,n,O[2]),S(n,n,O[0]),A(n,n,O[1]);break;case Qy.DIRECTION:if(0===O[1]&&0===O[2])O[0]<0&&A(n,n,3.1415926);else{const e=_o(O),t=[];t[0]=(O[0]+e)/2,t[1]=O[1]/2,t[2]=O[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case Jy.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=_o(w,s),m[1]=m[0],m[2]=m[0];break;case Jy.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case Jy.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)wn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(T,36*e,9);se(r,n),ge(r,r),fe(r,r)}const P=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&P&&(R.build(),t.colorArray=R.mapScalars(P,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}(e,t)}var rb={newInstance:Ht.newInstance(nb,"vtkGlyph3DMapper"),extend:nb,...Zy};const{vtkErrorMacro:ob}=Ht,ab={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function ib(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ab,n),Ht.obj(e,t),t.nodes=[],Ht.setGet(e,t,["allowDuplicateScalars","clamping"]),Ht.setArray(e,t,["range"],2),Ht.getArray(e,t,["range"]),function(e,t){t.classHierarchy.push("vtkPiecewiseFunction"),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return"Constant";case 1:return"NonDecreasing";case 2:return"NonIncreasing";default:return"Varied"}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(ob("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return ob("Index out of range!"),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return ob("Midpoint outside range [0.0, 1.0]"),-1;if(a<0||a>1)return ob("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,T=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>T?T:o[v]}}}}(e,t)}var sb={newInstance:Ht.newInstance(ib,"vtkPiecewiseFunction"),extend:ib};const{InterpolationType:lb,OpacityMode:cb,FilterMode:ub,ColorMixPreset:db}=If,{vtkErrorMacro:pb}=Ht;function fb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,(e=>({colorMixPreset:db.DEFAULT,independentComponents:!0,interpolationType:lb.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1,ipScalarRange:[-1e6,1e6],filterMode:ub.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7,updatedExtents:[],...e}))(n)),Ht.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:cb.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1,forceNearestInterpolation:!1})}Ht.setGet(e,t,["colorMixPreset","independentComponents","interpolationType","shade","ambient","diffuse","specular","specularPower","useLabelOutline","labelOutlineOpacity","filterMode","preferSizeOverAccuracy","computeNormalFromOpacity","volumetricScatteringBlending","globalIlluminationReach","anisotropy","localAmbientOcclusion","LAOKernelSize","LAOKernelRadius","updatedExtents"]),Ht.setGetArray(e,t,["ipScalarRange"],2),Ht.setGetArray(e,t,["labelOutlineThickness"]),function(e,t){t.classHierarchy.push("vtkVolumeProperty");const n={...e};e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(pb("Bad index - must be between 0 and 3"),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=sb.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=Yy.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=sb.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return pb("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(pb("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(lb.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(lb.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(lb.FAST_LINEAR),e.getInterpolationTypeAsString=()=>Ht.enumToString(lb,t.interpolationType),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=Ht.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=Ht.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]})),e.setAverageIPScalarRange=(t,n)=>{console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange"),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>Ht.enumToString(ub,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(ub.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(ub.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(ub.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(xa(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(xa(e,0,1)),e.setAnisotropy=e=>n.setAnisotropy(xa(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Co(xa(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}(e,t)}var gb={newInstance:Ht.newInstance(fb,"vtkVolumeProperty"),extend:fb,...If};const mb={mapper:null};function hb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mb,n),Ki.extend(e,t,n),t.boundsMTime={},Ht.obj(t.boundsMTime),Ht.setGet(e,t,["mapper"]),function(e,t){t.classHierarchy.push("vtkVolume"),e.getVolumes=()=>[e],e.makeProperty=gb.newInstance,e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}(e,t)}var vb={newInstance:Ht.newInstance(hb,"vtkVolume"),extend:hb};const{BlendMode:Tb}=Of,yb=["getAnisotropy","getComputeNormalFromOpacity","getFilterMode","getFilterModeAsString","getGlobalIlluminationReach","getIpScalarRange","getIpScalarRangeByReference","getLAOKernelRadius","getLAOKernelSize","getLocalAmbientOcclusion","getPreferSizeOverAccuracy","getVolumetricScatteringBlending","setAnisotropy","setAverageIPScalarRange","setComputeNormalFromOpacity","setFilterMode","setFilterModeToNormalized","setFilterModeToOff","setFilterModeToRaw","setGlobalIlluminationReach","setIpScalarRange","setIpScalarRangeFrom","setLAOKernelRadius","setLAOKernelSize","setLocalAmbientOcclusion","setPreferSizeOverAccuracy","setVolumetricScatteringBlending"],bb={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=sb.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function xb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,(e=>({bounds:[...Fi.INIT_BOUNDS],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:Tb.COMPOSITE_BLEND,volumeShadowSamplingDistFactor:5,colorTextureWidth:1024,opacityTextureWidth:1024,labelOutlineTextureWidth:1024,...e}))(n)),xs(e,t,n),Ht.setGet(e,t,["sampleDistance","imageSampleDistance","maximumSamplesPerRay","autoAdjustSampleDistances","initialInteractionScale","interactionSampleDistanceFactor","blendMode","volumeShadowSamplingDistFactor","colorTextureWidth","opacityTextureWidth","labelOutlineTextureWidth"]),Ht.event(e,t,"lightingActivated"),function(e,t){t.classHierarchy.push("vtkVolumeMapper");const n={...e};e.getBounds=()=>(t.static||e.update(),t.bounds=[...e.getInputData().getBounds()],t.bounds),e.setBlendModeToComposite=()=>{e.setBlendMode(Tb.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(Tb.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(Tb.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(Tb.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(Tb.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(Tb.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>Ht.enumToString(Tb,t.blendMode),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),yb.forEach((t=>{e[t]=()=>{throw new Error(`The method "volumeMapper.${t}()" doesn't exist anymore. It is a rendering property that has been moved to the volume property. Replace your code with:\nvolumeActor.getProperty().${t}()\n`)}}))}(e,t)}var Cb={newInstance:Ht.newInstance(xb,"vtkVolumeMapper"),extend:xb,...bb};const{InterpolationType:Sb}=ef,{vtkErrorMacro:Ab}=Ht;function Ib(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,(e=>({independentComponents:!1,interpolationType:Sb.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1,updatedExtents:[],...e}))(n)),Ht.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}Ht.setGet(e,t,["independentComponents","interpolationType","colorWindow","colorLevel","ambient","diffuse","opacity","useLookupTableScalarRange","useLabelOutline","labelOutlineOpacity","updatedExtents"]),Ht.setGetArray(e,t,["labelOutlineThickness"]),function(e,t){t.classHierarchy.push("vtkImageProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(n)||(o=n,r=0),t.componentData[r].rGBTransferFunction!==o&&(t.componentData[r].rGBTransferFunction=o,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(n)||(o=n,r=0),t.componentData[r].piecewiseFunction!==o&&(t.componentData[r].piecewiseFunction=o,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=t,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(t)||(r=t,n=0),e.setPiecewiseFunction(n,r)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return Ab("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(Ab("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(Sb.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(Sb.LINEAR),e.getInterpolationTypeAsString=()=>Ht.enumToString(Sb,t.interpolationType)}(e,t)}var wb={newInstance:Ht.newInstance(Ib,"vtkImageProperty"),extend:Ib};const Ob={mapper:null,forceOpaque:!1,forceTranslucent:!1};function Pb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ob,n),Ki.extend(e,t,n),t.boundsMTime={},Ht.obj(t.boundsMTime),Ht.setGet(e,t,["mapper","forceOpaque","forceTranslucent"]),function(e,t){t.classHierarchy.push("vtkImageSlice"),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.properties[0]||e.getProperty();let n=t.properties[0].getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=wb.newInstance,e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!Fi.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),Fi.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return t.properties.forEach((t=>{e=Math.max(e,t.getMTime());const n=t.getRGBTransferFunction();null!==n&&(e=Math.max(e,n.getMTime()))})),e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}(e,t)}var Rb={newInstance:Ht.newInstance(Pb,"vtkImageSlice"),extend:Pb};const Mb={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1],colorTextureWidth:1024,opacityTextureWidth:1024,labelOutlineTextureWidth:1024};var Eb=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mb,n),xs(e,t,n),Ht.setGet(e,t,["slice","useCustomExtents","colorTextureWidth","opacityTextureWidth","labelOutlineTextureWidth"]),Ht.setGetArray(e,t,["customDisplayExtent"],6),Ht.setGetArray(e,t,["backgroundColor"],4),function(e,t){t.classHierarchy.push("vtkAbstractImageMapper"),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(Ht.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED"),Ra())}(e,t)};function Vb(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA("vtkImageArrayMapper")?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Sn(c,c);const u=ti.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:Db,otherStaticMethods:Lb}=bl,{SlicingMode:Bb}=af;const Nb={slicingMode:Bb.NONE,closestIJKAxis:{ijkMode:Bb.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function Fb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Nb,n),Eb(e,t,n),Ht.get(e,t,["slicingMode"]),Ht.setGet(e,t,["closestIJKAxis","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy"]),bl.implementCoincidentTopologyMethods(e,t),function(e,t){function n(){let n;switch(t.slicingMode){case Bb.X:n=0;break;case Bb.Y:n=1;break;case Bb.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=Ma(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push("vtkImageMapper"),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case Bb.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case Bb.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case Bb.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case Bb.I:l=xa(a[0],i[0],i[1]);break;case Bb.J:l=xa(a[1],i[2],i[3]);break;case Bb.K:l=xa(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case Bb.I:case Bb.J:case Bb.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case Bb.X:e.setSlice(r[0]);break;case Bb.Y:e.setSlice(r[1]);break;case Bb.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(Bb.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(Bb.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(Bb.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(Bb.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(Bb.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(Bb.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case Bb.X:n[0]=1;break;case Bb.Y:n[1]=1;break;case Bb.Z:n[2]=1;break;case Bb.I:jo(r,[1,0,0],n);break;case Bb.J:jo(r,[0,1,0],n);break;case Bb.K:jo(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==Bb.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Ra();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case Bb.I:r[0]=a,r[1]=a;break;case Bb.J:r[2]=a,r[3]=a;break;case Bb.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Ra();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case Bb.I:a[0]=s-r,a[1]=s+r;break;case Bb.J:a[2]=s-r,a[3]=s+r;break;case Bb.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=Vb(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=Vb(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}(e,t)}var _b={newInstance:Ht.newInstance(Fb,"vtkImageMapper"),extend:Fb,...Db,...Lb,...af};const{vtkErrorMacro:kb}=Ht;function Gb(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}const Ub={outputPointsPrecision:Os.DEFAULT};function zb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ub,n),Ht.setGet(e,t,["outputPointsPrecision"]),Ht.obj(e,t),Ht.algo(e,t,1,1),function(e,t){t.classHierarchy.push("vtkAppendPolyData"),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void kb("No input specified.");if(1===o)return void(r[0]=n[0]);const a=kc.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===Os.SINGLE?s=is.FLOAT:t.outputPointsPrecision===Os.DOUBLE&&(s=is.DOUBLE);const v=$l.newInstance({dataType:s});v.setNumberOfPoints(i);const T=v.getData(),y=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Ts.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Ts.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Ts.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];T.set(t.getPoints().getData(),3*i),Gb(y,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),Gb(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),Gb(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),Gb(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(y),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}(e,t)}var Wb={newInstance:Ht.newInstance(zb,"vtkAppendPolyData"),extend:zb};const Hb={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:"Float64Array"};function jb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hb,n),Ht.obj(e,t),Ht.setGet(e,t,["height","radius","resolution","capping"]),Ht.setGetArray(e,t,["center","direction"],3),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkConeSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=Ht.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Fp().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=kc.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}(e,t)}var Kb={newInstance:Ht.newInstance(jb,"vtkConeSource"),extend:jb};const $b={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:"Float64Array"};function qb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$b,n),Ht.obj(e,t),Ht.setGet(e,t,["height","initAngle","otherRadius","radius","resolution","capping"]),Ht.setGetArray(e,t,["center","direction"],3),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkCylinderSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=Ht.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Ts.newInstance({numberOfComponents:3,values:u,name:"Normals"}),p=new Float32Array(2*a),f=Ts.newInstance({numberOfComponents:2,values:p,name:"TCoords"}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],T=[0,0],y=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],T[0]=Math.abs(2*e/t.resolution-1),y[0]=T[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],T[1]=0,y[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=T[e],p[2*(n+1)+e]=y[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],T[0]=h[0],y[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],T[1]=h[2],y[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=T[e],p[2*r+e]=y[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Fp().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=kc.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}(e,t)}var Xb={newInstance:Ht.newInstance(qb,"vtkCylinderSource"),extend:qb};const Yb={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:"Float64Array"};function Zb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yb,n),Ht.obj(e,t),Ht.setGet(e,t,["tipResolution","tipRadius","tipLength","shaftResolution","shaftRadius","invert"]),Ht.setGetArray(e,t,["direction"],3),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkArrowSource"),e.requestData=function(e,n){if(t.deleted)return;const r=Xb.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();Np().rotateZ(-90).apply(a).apply(i);const s=Kb.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Fp().translate(1-.5*t.tipLength,0,0).apply(c);const u=Wb.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Fp().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Fp().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Fp().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}(e,t)}var Qb={newInstance:Ht.newInstance(Zb,"vtkArrowSource"),extend:Zb};function Jb(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];Np().translate(...n).apply(e.getPoints().getData())}function ex(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=e.getPoints().getBounds(),o=[0,0,0];o[t]=n?-r[2*t+1]:-r[2*t],Np().translate(...o).apply(e.getPoints().getData())}function tx(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8ClampedArray(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Ts.newInstance({name:"color",numberOfComponents:3,values:a}))}function nx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};os.extend(e,t,function(e){return{config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1,...e?.config},xConfig:{color:[255,0,0],invert:!1,...e?.xConfig},yConfig:{color:[255,255,0],invert:!1,...e?.yConfig},zConfig:{color:[0,128,0],invert:!1,...e?.zConfig}}}(n)),Ht.setGet(e,t,["config","xConfig","yConfig","zConfig"]),function(e,t){t.classHierarchy.push("vtkAxesActor");const n=Fl.newInstance();e.setMapper(n),e.update=()=>{let e={...t.config,...t.xConfig};const r=Qb.newInstance({direction:[1,0,0],...e}).getOutputData();t.config.recenter?Jb(r):ex(r,0,e.invert),tx(r,...e.color),e={...t.config,...t.yConfig};const o=Qb.newInstance({direction:[0,1,0],...e}).getOutputData();t.config.recenter?Jb(o):ex(o,1,e.invert),tx(o,...e.color),e={...t.config,...t.zConfig};const a=Qb.newInstance({direction:[0,0,1],...e}).getOutputData();t.config.recenter?Jb(a):ex(a,2,e.invert),tx(a,...e.color);const i=Wb.newInstance();i.setInputData(r),i.addInputData(o),i.addInputData(a),n.setInputConnection(i.getOutputPort())},e.update();const r=Ht.debounce(e.update,0);e.setXAxisColor=t=>e.setXConfig({...e.getXConfig(),color:t}),e.setYAxisColor=t=>e.setYConfig({...e.getYConfig(),color:t}),e.setZAxisColor=t=>e.setZConfig({...e.getZConfig(),color:t}),e.getXAxisColor=()=>t.getXConfig().color,e.getYAxisColor=()=>t.getYConfig().color,e.getZAxisColor=()=>t.getZConfig().color,t._onConfigChanged=r,t._onXConfigChanged=r,t._onYConfigChanged=r,t._onZConfigChanged=r}(e,t)}var rx={newInstance:Ht.newInstance(nx,"vtkAxesActor"),extend:nx};const ox="resetcamera",ax="orientation",ix={MODE_RESET_CAMERA:ox,MODE_ORIENTATION:ax,MODE_SAME:"same"};const sx={mode:ax,focalPoint:[0,0,0],distance:6.8,active:!0};function lx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sx,n),vt(e,t),St(e,t,["mode","active","srcRenderer","dstRenderer","distance"]),wt(e,t,["focalPoint"],3,0),function(e,t){t.classHierarchy.push("vtkCameraSynchronizer");const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._onSrcRendererChanged=a,t._onDstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName("position"),s=e.getReferenceByName("focalPoint"),l=e.getReferenceByName("viewUp"),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===ax?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],ko(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===ox&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}(e,t)}var cx={newInstance:Et(lx,"vtkCameraSynchronizer"),extend:lx,SynchronizationMode:ix};const ux={},dx={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=cx.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:cx.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var px=function(e,t,n){const r=e.get("synchronizedViewId").synchronizedViewId;if(!t.behaviors||!r)return;ux[r]||(ux[r]={});const o=ux[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=cx.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];dx[e.type]?o[r]=new dx[e.type](n,e):console.log("No mapping for",e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const fx={},gx=/instance:\${([^}]+)}/,mx={},hx=[],vx={},Tx={vtkPoints:$l,vtkCellArray:zl,vtkDataArray:Ts};function yx(e){return e.map((e=>gx.exec(e))).filter((e=>e)).map((e=>e[1]))}function bx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),bx(e,t)})),t}function xx(e,t,n,r){if(!t)return Promise.reject(new Error("No instance provided."));const o=fx[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function Cx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=fx[e];return n&&n.build?n.build(t):(console.log("No builder for",e),null)}function Sx(){Object.keys(fx).forEach((e=>{delete fx[e]}))}function Ax(e){if(1===e[1].length)return-1===hx.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===hx.indexOf(e[1][n]);return t}function Ix(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(vx[r]){const{key:n,value:o}=vx[r];if(!n||e.properties[n]===o)return void hx.push((e=>`instance:\${${e}}`)(t))}let o=n.getInstance(t);o||(o=Cx(r,{managedInstanceId:t}),n.registerInstance(t,o)),xx(r,o,e,n)})),t.calls&&t.calls.filter(Ax).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=gx.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:"addArray",a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:"vtkDataArray",l=Tx[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log("Error fetching array",JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error("Error in array handling for state",JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function wx(e,t,n){mx[t.id]||Ix(e,t,n),mx[t.id]=!0}function Ox(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function Px(e){const t=e.name?`_${e.name}`:"";return`${e.hash}_${e.dataType}${t}`}function Rx(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${lt(r)}`;const t=Px(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=Px(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),Ox(t.getPointData(),i.pointData),Ox(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=Ix(t,s,r);return r.end(),l}}const Mx=Rx(["points","polys","verts","lines","strips"]),Ex=Rx([]);function Vx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Ix;Cx||xx?fx[e]={build:t,update:n}:delete fx[e]}const Dx={vtkMapper:["vtkOpenGLPolyDataMapper","vtkCompositePolyDataMapper2","vtkDataSetMapper"],vtkProperty:["vtkOpenGLProperty"],vtkRenderer:["vtkOpenGLRenderer"],vtkCamera:["vtkOpenGLCamera"],vtkColorTransferFunction:["vtkPVDiscretizableColorTransferFunction"],vtkActor:["vtkOpenGLActor","vtkPVLODActor"],vtkLight:["vtkOpenGLLight","vtkPVLight"],vtkTexture:["vtkOpenGLTexture"],vtkImageMapper:["vtkOpenGLImageSliceMapper"],vtkVolumeMapper:["vtkFixedPointVolumeRayCastMapper"]},Lx={vtkAxesActor:{build:rx.newInstance,update:Ix},vtkRenderWindow:{build:zm.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(Ax).filter((e=>"removeRenderer"===e[0])).forEach((e=>{yx(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),Ix(e,t,n),px(e,t,n)}},vtkRenderer:{build:Nm.newInstance,update:function(e,t,n){Ix(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=bx(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(Ax).filter((e=>"removeViewProp"===e[0])).forEach((e=>{yx(e[1]).forEach((e=>{const t=n.getInstance(e).get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:ul.newInstance,update:Ix},vtkCamera:{build:Cm.newInstance,update:wx},vtkPolyData:{build:kc.newInstance,update:Mx},vtkImageData:{build:Ks.newInstance,update:Ex},vtkMapper:{build:Fl.newInstance,update:Ix},vtkGlyph3DMapper:{build:rb.newInstance,update:Ix},vtkProperty:{build:ts.newInstance,update:Ix},vtkActor:{build:os.newInstance,update:Ix},vtkLight:{build:Im.newInstance,update:Ix},vtkColorTransferFunction:{build:Yy.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:zc.newInstance,update:Ix},vtkVolume:{build:vb.newInstance,update:Ix},vtkVolumeMapper:{build:Cb.newInstance,update:Ix},vtkVolumeProperty:{build:gb.newInstance,update:Ix},vtkImageSlice:{build:Rb.newInstance,update:Ix},vtkImageMapper:{build:_b.newInstance,update:Ix},vtkImageProperty:{build:wb.newInstance,update:Ix},vtkPiecewiseFunction:{build:sb.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:au.newInstance,update:Ix},vtkScalarBarActor:{build:kd.newInstance,update:Ix}};function Bx(){(!(arguments.length>0&&void 0!==arguments[0])||arguments[0])&&Sx(),Object.keys(Lx).forEach((e=>{const t=Lx[e];Vx(e,t.build,t.update)}))}function Nx(){Object.keys(Dx).forEach((e=>{Dx[e].forEach((t=>{fx[t]=fx[e]}))}))}Bx(),Nx(),vx.vtkPVLight={};var Fx={build:Cx,update:xx,genericUpdater:Ix,oneTimeGenericUpdater:wx,setTypeMapping:Vx,clearTypeMapping:Sx,getSupportedTypes:function(){return Object.keys(fx)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return void Object.keys(mx).forEach((e=>{delete mx[e]}));let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete mx[e]})),r},updateRenderWindow:function(e,t,n){return xx("vtkRenderWindow",e,t,n)},excludeInstance:function(e,t,n){vx[e]={key:t,value:n}},setDefaultMapping:Bx,applyDefaultAliases:Nx,alwaysUpdateCamera:function(){Vx("vtkCamera",Cm.newInstance),Nx()}};const _x={};function kx(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if("string"==typeof t&&(i=yg.toArrayBuffer(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=it(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=it(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log("Error getting data array:"),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use "setArrayFetcher" to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function Gx(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function Ux(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Mt(t,n,"progressEvent"),Mt(t,n,"progressDone"),t}function zx(){const e={};let t="default";return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function Wx(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"default",t=_x[e];return t||(t={...kx(),...Gx(),...Ux(),...zx()},_x[e]=t),t}function Hx(e,t){let n=-1,r=100;const o=e=>e.get("managedInstanceId").managedInstanceId,a=()=>Lt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get("synchronizedViewId").synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),Fx.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){Fx.clearOneTimeUpdaters(a())}}}const jx={synchronizerContextName:"default",synchronizerContext:null,synchronizedViewId:null};function Kx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jx,n),zm.extend(e,t),yt(e,t,["synchronizerContext"]),function(e,t){t.classHierarchy.push("vtkSynchronizableRenderWindow"),t.synchronizerContext||(t.synchronizerContext=Wx(t.synchronizerContextName));const n=Hx(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}(e,t)}var $x={newInstance:Et(Kx,"vtkSynchronizableRenderWindow"),extend:Kx,getSynchronizerContext:Wx,setSynchronizerContext:function(e,t){_x[e]=t},clearSynchronizerContext:function(e){if(e&&_x[e]&&delete _x[e],!e){const e=Object.keys(_x);for(let t=0;t<e.length;t++)delete _x[e[t]]}},decorate:function(e){const t=Hx(e,Wx(arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default"));return{...t,...e,delete:Vt(e.delete,t.delete)}},createInstanceMap:Gx,createArrayHandler:kx,createProgressHandler:Ux,createSceneMtimeHandler:zx,vtkObjectManager:Fx};const{vtkErrorMacro:qx,vtkDebugMacro:Xx}=Ht;let Yx=0;function Zx(e){const t=document.querySelector(`.webResource[data-url="${e}"]`);return t?t.innerHTML:null}function Qx(e){return"/"===e[0]?e.substr(1):e}const Jx={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=Zx(Qx(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=Zx(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=Qx([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/")),s=Zx(i);if(null===s)a(new Error(`No such array ${i}`));else{if("string"===n.dataType){let e=atob(s);r.compression&&(e=im(rm(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(yg.toArrayBuffer(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=im(rm(new Uint8Array(n.buffer))):n.buffer=rm(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(pm!==n.ref.encode&&pm&&(Xx(`Swap bytes of ${n.name}`),fm(n.buffer,as[n.dataType])),n.values=Ht.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&qx(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--Yx&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url="${e}"]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};xg("html",(e=>Jx));const{vtkErrorMacro:eC,vtkDebugMacro:tC}=Ht;function nC(e){return function(e){return"/"===e[0]?e.substr(1):e}(function(e){return new URL(e,"http://any").pathname}(e))}const rC=function(e){let t=!1,n=0,r=null,o="";var a;return(a=e.zipContent,new Promise(((e,t)=>{"string"==typeof a?e(function(e,t){if(t){for(var n=new Sg(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(om)return om.encode(e);var o=e.length,a=new Sg(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new Sg(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return Kg(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error("Invalid datatype to unpack."))}))).then((n=>{r=um(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith("index.json")&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\.json$/,""),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||eC("ERROR!!! zip not ready...");const u=nC([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join("/"));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if("string"!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&("string"===e.dataType||"JSON"===e.dataType?e.buffer=im(rm(new Uint8Array(e.buffer))):e.buffer=rm(new Uint8Array(e.buffer)).buffer),"JSON"===e.ref.encode?e.values=JSON.parse(e.buffer):(pm!==e.ref.encode&&pm&&(tC(`Swap bytes of ${e.name}`),fm(e.buffer,as[e.dataType])),e.values=Ht.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&eC(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(im(rm(r))):JSON.parse(r),n()}}(i,s.compression,d);e(im(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=nC(n);t||eC("ERROR!!! zip not ready...");const s=r[`${o}${i}`];if(a.compression){if("gz"===a.compression){const e=im(rm(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error("Invalid compression"))}return Promise.resolve(JSON.parse(im(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=nC(n);t||eC("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(im(um(s))):Promise.reject(new Error("Invalid compression")):Promise.resolve(im(s))},fetchImage(e,n){const a=nC(n);t||eC("ERROR!!! zip not ready...");const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=Tg(i.buffer);n.src=`data:image/${function(e){const t=e.split(".").pop().toLowerCase();return"jpg"===t?"jpeg":t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=nC(n);t||eC("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(rm(s).buffer):Promise.reject(new Error("Invalid compression")):Promise.resolve(s.buffer)}}};xg("zip",(e=>rC(e)));var oC=n(911),aC=n.n(oC),iC=n(893),sC=n.n(iC),lC=n(383),cC=n.n(lC),uC=n(884),dC=n.n(uC),pC=n(88),fC=n.n(pC),gC=n(997),mC=n.n(gC),hC=n(96),vC={};vC.styleTagTransform=mC(),vC.setAttributes=dC(),vC.insert=cC().bind(null,"head"),vC.domAPI=sC(),vC.insertStyleElement=fC(),aC()(hC.A,vC);var TC=hC.A&&hC.A.locals?hC.A.locals:void 0;let yC=!0;function bC(e){e.preventDefault(),e.stopPropagation()}function xC(e,t){yC=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=Fy.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:"100%",width:"100%",position:"absolute"}}).getRenderWindow(),o=$x.getSynchronizerContext(),a=$x.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement("div");n.setAttribute("class",TC.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=Ht.formatBytesToProperUnit(e.loaded)};t.fileURL?Tm.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=Cg.get("zip",{zipContent:t,callback:e=>{r.fetchJSON(null,"index.json").then(i)}})})):Tm.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=Cg.get("zip",{zipContent:t.file,callback:t=>{e.fetchJSON(null,"index.json").then(i)}})}else if(t.base64Str){const e=yg.toArrayBuffer(t.base64Str),n=Cg.get("zip",{zipContent:e,callback:e=>{n.fetchJSON(null,"index.json").then(i)}})}}function CC(e){yC=!1;const t=document.querySelector(".content"),n=document.querySelector("body"),r=e||t||n;r!==e?(r.classList.add(TC.fullScreen),n.style.margin="0",n.style.padding="0"):(n.style.margin="0",n.style.padding="0");const o=document.createElement("div");o.innerHTML=`<div class="${TC.bigFileDrop}"/><input type="file" accept=".zip,.vtksz" style="display: none;"/>`,r.appendChild(o);const a=o.querySelector("input");function i(e){bC(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(".").slice(-1)[0];xC(r,{file:n[0],ext:e})}}a.addEventListener("change",i),o.addEventListener("drop",i),o.addEventListener("click",(e=>a.click())),o.addEventListener("dragover",bC)}const SC=Sh();if(SC.url||SC.fileURL){const e=document.querySelector(".content"),t=document.querySelector("body"),n=e||t;n&&(n.classList.add(TC.fullScreen),t.style.margin="0",t.style.padding="0"),yC=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>xC(n,SC)))}setTimeout((()=>{yC&&CC()}),100),window.OfflineLocalView={initLocalFileLoader:CC,load:xC}},613:function(e){"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,o,a){"string"==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=a),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),o&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=o):u[4]="".concat(o)),t.push(u))}},t}},336:function(e){"use strict";e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/["'() \t\n]|(%20)/.test(e)||t.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e):e}},20:function(e){"use strict";e.exports=function(e){return e[1]}},555:function(e,t,n){"use strict";var r=n(382),o="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,"x",{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||"function"==typeof(o=r)&&"[object Function]"===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},77:function(e,t,n){"use strict";e.exports=function(){if("object"==typeof globalThis)return globalThis;var e;try{e=this||new Function("return this")()}catch(e){if("object"==typeof window)return window;if("object"==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},730:function(e){"use strict";e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&"object"==typeof t&&"object"==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},979:function(e){"use strict";"undefined"!=typeof self?e.exports=self:"undefined"!=typeof window?e.exports=window:e.exports=Function("return this")()},59:function(e,t,n){"use strict";var r=n(555),o=n(979),a=n(920),i=n(482),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},920:function(e,t,n){"use strict";var r=n(979);e.exports=function(){return"object"==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},482:function(e,t,n){"use strict";var r=n(555),o=n(920);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,"globalThis");t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,"globalThis",{configurable:!0,enumerable:!1,value:e,writable:!0})}else"object"==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},982:function(e,t,n){"use strict";var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(642),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},"toString"),c=s.call((function(){}),"prototype"),u=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if("undefined"==typeof window)return!1;for(var e in window)try{if(!p["$"+e]&&o.call(window,e)&&null!==window[e]&&"object"==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&"object"==typeof e,n="[object Function]"===a.call(e),r=i(e),s=t&&"[object String]"===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError("Object.keys called on a non-object");var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&"prototype"===v||!o.call(e,v)||p.push(String(v));if(l)for(var T=function(e){if("undefined"==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),y=0;y<u.length;++y)T&&"constructor"===u[y]||!o.call(e,u[y])||p.push(u[y]);return p}}e.exports=r},382:function(e,t,n){"use strict";var r=Array.prototype.slice,o=n(642),a=Object.keys,i=a?function(e){return a(e)}:n(982),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},642:function(e){"use strict";var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r="[object Arguments]"===n;return r||(r="[object Array]"!==n&&null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Function]"===t.call(e.callee)),r}},318:function(e,t,n){var r=n(767),o=n(698),a=n(744),i=n(402),s=n(576),l=n(886),c=n(262);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},767:function(e,t,n){var r;!function(e,o){function a(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new a(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.alea=s}(0,e=n.nmd(e),n.amdD)},886:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.tychei=s}(0,e=n.nmd(e),n.amdD)},698:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xor128=s}(0,e=n.nmd(e),n.amdD)},576:function(e,t,n){var r;!function(e,o){function a(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xor4096=s}(0,e=n.nmd(e),n.amdD)},402:function(e,t,n){var r;!function(e,o){function a(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xorshift7=s}(0,e=n.nmd(e),n.amdD)},744:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xorwow=s}(0,e=n.nmd(e),n.amdD)},262:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,T(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),T(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,T(a)]}}():e,3),r),f=new g(r),y=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return y.int32=function(){return 0|f.g(4)},y.quick=function(){return f.g(4)/4294967296},y.double=y,v(T(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(y,p,"global"in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&"object"==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:"string"==o?e:e+"\0"}function v(e,t){for(var n,r=e+"",o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return T(t)}function T(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(1)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},292:function(e){e.exports=function(){"use strict";var e=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];function t(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function n(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function o(e){var r,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(r=64;r<=c;r+=64)t(u,n(e.substring(r-64,r)));for(o=(e=e.substring(r-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],r=0;r<o;r+=1)a[r>>2]|=e.charCodeAt(r)<<(r%4<<3);if(a[r>>2]|=128<<(r%4<<3),r>55)for(t(u,a),r=0;r<16;r+=1)a[r]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,t(u,a),u}function a(t){var n,r="";for(n=0;n<4;n+=1)r+=e[t>>8*n+4&15]+e[t>>8*n&15];return r}function i(e){var t;for(t=0;t<e.length;t+=1)e[t]=a(e[t]);return e.join("")}function s(e){return/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function l(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function c(){this.reset()}return i(o("hello")),"undefined"==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),c.prototype.append=function(e){return this.appendBinary(s(e)),this},c.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var r,o=this._buff.length;for(r=64;r<=o;r+=64)t(this._hash,n(this._buff.substring(r-64,r)));return this._buff=this._buff.substring(r-64),this},c.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=i(this._hash),e&&(n=l(n)),this.reset(),n},c.prototype.reset=function(){return this._buff="",this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},c.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},c.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},c.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},c.prototype._finish=function(e,n){var r,o,a,i=n;if(e[i>>2]|=128<<(i%4<<3),i>55)for(t(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,t(this._hash,e)},c.hash=function(e,t){return c.hashBinary(s(e),t)},c.hashBinary=function(e,t){var n=i(o(e));return t?l(n):n},c.ArrayBuffer=function(){this.reset()},c.ArrayBuffer.prototype.append=function(e){var n,o,a,i,s,l=(o=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(o.byteLength+a.byteLength)).set(new Uint8Array(o)),s.set(new Uint8Array(a),o.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,n=64;n<=c;n+=64)t(this._hash,r(l.subarray(n-64,n)));return this._buff=n-64<c?new Uint8Array(l.buffer.slice(n-64)):new Uint8Array(0),this},c.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=i(this._hash),e&&(n=l(n)),this.reset(),n},c.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},c.ArrayBuffer.prototype.getState=function(){var e,t=c.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},c.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),c.prototype.setState.call(this,e)},c.ArrayBuffer.prototype.destroy=c.prototype.destroy,c.ArrayBuffer.prototype._finish=c.prototype._finish,c.ArrayBuffer.hash=function(e,n){var o=i(function(e){var n,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(n=64;n<=c;n+=64)t(u,r(e.subarray(n-64,n)));for(o=(e=n-64<c?e.subarray(n-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],n=0;n<o;n+=1)a[n>>2]|=e[n]<<(n%4<<3);if(a[n>>2]|=128<<(n%4<<3),n>55)for(t(u,a),n=0;n<16;n+=1)a[n]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,t(u,a),u}(new Uint8Array(e)));return n?l(o):o},c}()},96:function(e,t,n){"use strict";var r=n(20),o=n.n(r),a=n(613),i=n.n(a),s=n(336),l=n.n(s),c=new URL(n(183),n.b),u=i()(o()),d=l()(c);u.push([e.id,".viewer-module-fullScreen_bbk9Y {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n  background: black;\n  margin: 0;\n  padding: 0;\n  z-index: -1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.viewer-module-fullParentSize_ETopO {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n.viewer-module-bigFileDrop_aqCgh {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  background-color: white;\n  background-image: url("+d+");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: contain;\n  border-radius: 10px;\n  width: 50px;\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\n  cursor: pointer;\n}\n\n.viewer-module-progress_cYjQJ {\n  flex: none;\n  font-size: 50px;\n  color: black;\n  z-index: 1;\n  background: rgba(128,128,128,.5);\n  padding: 20px;\n  border-radius: 10px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n\nbody {\n  margin: 0;\n}\n\nhtml { \n  overflow: hidden; \n}\n",""]),u.locals={fullScreen:"viewer-module-fullScreen_bbk9Y",fullParentSize:"viewer-module-fullParentSize_ETopO",bigFileDrop:"viewer-module-bigFileDrop_aqCgh",progress:"viewer-module-progress_cYjQJ"},t.A=u},50:function(e,t,n){var r=n(422),o=n(77);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},911:function(e){"use strict";var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d="".concat(c," ").concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},383:function(e){"use strict";var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},88:function(e){"use strict";e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},884:function(e,t,n){"use strict";e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},893:function(e){"use strict";e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var o=void 0!==n.layer;o&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,o&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var a=n.sourceMap;a&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},997:function(e){"use strict";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},183:function(e,t,n){"use strict";e.exports=n.p+"138e7b1469f64156810a.jpg"},1:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p="",n.b=document.baseURI||self.location.href,n.nc=void 0,n(50)}();
</script>
<script>
var container = document.querySelector('.content');
var base64Str = "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";

OfflineLocalView.load(container, { base64Str });
</script>
</body>
</html>
